# ! [ doc = "Peripheral access API for NRF51 microcontrollers (generated using svd2rust v0.6.1)" ] # ! [ deny ( missing_docs ) ] # ! [ deny ( warnings ) ] # ! [ feature ( const_fn ) ] # ! [ no_std ]extern crate cortex_m ;
extern crate vcell ;
use core::ops::Deref;
use cortex_m::peripheral::Peripheral;
# [ doc = r" Interrupts" ]
pub mod interrupt {
    use cortex_m::ctxt::Context;
    use cortex_m::exception;
    use cortex_m::interrupt::Nr;
    # [ doc = "0 - POWER_CLOCK" ]
    pub struct PowerClock {
        _0: (),
    }
    unsafe impl Context for PowerClock {}
    unsafe impl Nr for PowerClock {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            0
        }
    }
    # [ doc = "1 - RADIO" ]
    pub struct Radio {
        _0: (),
    }
    unsafe impl Context for Radio {}
    unsafe impl Nr for Radio {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            1
        }
    }
    # [ doc = "2 - UART0" ]
    pub struct Uart0 {
        _0: (),
    }
    unsafe impl Context for Uart0 {}
    unsafe impl Nr for Uart0 {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            2
        }
    }
    # [ doc = "3 - SPI0_TWI0" ]
    pub struct Spi0Twi0 {
        _0: (),
    }
    unsafe impl Context for Spi0Twi0 {}
    unsafe impl Nr for Spi0Twi0 {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            3
        }
    }
    # [ doc = "4 - SPI1_TWI1" ]
    pub struct Spi1Twi1 {
        _0: (),
    }
    unsafe impl Context for Spi1Twi1 {}
    unsafe impl Nr for Spi1Twi1 {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            4
        }
    }
    # [ doc = "6 - GPIOTE" ]
    pub struct Gpiote {
        _0: (),
    }
    unsafe impl Context for Gpiote {}
    unsafe impl Nr for Gpiote {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            6
        }
    }
    # [ doc = "7 - ADC" ]
    pub struct Adc {
        _0: (),
    }
    unsafe impl Context for Adc {}
    unsafe impl Nr for Adc {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            7
        }
    }
    # [ doc = "8 - TIMER0" ]
    pub struct Timer0 {
        _0: (),
    }
    unsafe impl Context for Timer0 {}
    unsafe impl Nr for Timer0 {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            8
        }
    }
    # [ doc = "9 - TIMER1" ]
    pub struct Timer1 {
        _0: (),
    }
    unsafe impl Context for Timer1 {}
    unsafe impl Nr for Timer1 {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            9
        }
    }
    # [ doc = "10 - TIMER2" ]
    pub struct Timer2 {
        _0: (),
    }
    unsafe impl Context for Timer2 {}
    unsafe impl Nr for Timer2 {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            10
        }
    }
    # [ doc = "11 - RTC0" ]
    pub struct Rtc0 {
        _0: (),
    }
    unsafe impl Context for Rtc0 {}
    unsafe impl Nr for Rtc0 {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            11
        }
    }
    # [ doc = "12 - TEMP" ]
    pub struct Temp {
        _0: (),
    }
    unsafe impl Context for Temp {}
    unsafe impl Nr for Temp {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            12
        }
    }
    # [ doc = "13 - RNG" ]
    pub struct Rng {
        _0: (),
    }
    unsafe impl Context for Rng {}
    unsafe impl Nr for Rng {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            13
        }
    }
    # [ doc = "14 - ECB" ]
    pub struct Ecb {
        _0: (),
    }
    unsafe impl Context for Ecb {}
    unsafe impl Nr for Ecb {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            14
        }
    }
    # [ doc = "15 - CCM_AAR" ]
    pub struct CcmAar {
        _0: (),
    }
    unsafe impl Context for CcmAar {}
    unsafe impl Nr for CcmAar {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            15
        }
    }
    # [ doc = "16 - WDT" ]
    pub struct Wdt {
        _0: (),
    }
    unsafe impl Context for Wdt {}
    unsafe impl Nr for Wdt {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            16
        }
    }
    # [ doc = "17 - RTC1" ]
    pub struct Rtc1 {
        _0: (),
    }
    unsafe impl Context for Rtc1 {}
    unsafe impl Nr for Rtc1 {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            17
        }
    }
    # [ doc = "18 - QDEC" ]
    pub struct Qdec {
        _0: (),
    }
    unsafe impl Context for Qdec {}
    unsafe impl Nr for Qdec {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            18
        }
    }
    # [ doc = "19 - LPCOMP" ]
    pub struct Lpcomp {
        _0: (),
    }
    unsafe impl Context for Lpcomp {}
    unsafe impl Nr for Lpcomp {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            19
        }
    }
    # [ doc = "20 - SWI0" ]
    pub struct Swi0 {
        _0: (),
    }
    unsafe impl Context for Swi0 {}
    unsafe impl Nr for Swi0 {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            20
        }
    }
    # [ doc = "21 - SWI1" ]
    pub struct Swi1 {
        _0: (),
    }
    unsafe impl Context for Swi1 {}
    unsafe impl Nr for Swi1 {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            21
        }
    }
    # [ doc = "22 - SWI2" ]
    pub struct Swi2 {
        _0: (),
    }
    unsafe impl Context for Swi2 {}
    unsafe impl Nr for Swi2 {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            22
        }
    }
    # [ doc = "23 - SWI3" ]
    pub struct Swi3 {
        _0: (),
    }
    unsafe impl Context for Swi3 {}
    unsafe impl Nr for Swi3 {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            23
        }
    }
    # [ doc = "24 - SWI4" ]
    pub struct Swi4 {
        _0: (),
    }
    unsafe impl Context for Swi4 {}
    unsafe impl Nr for Swi4 {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            24
        }
    }
    # [ doc = "25 - SWI5" ]
    pub struct Swi5 {
        _0: (),
    }
    unsafe impl Context for Swi5 {}
    unsafe impl Nr for Swi5 {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            25
        }
    }
    use cortex_m::Reserved;
    # [ doc = r" Interrupt handlers" ]
    # [ allow ( non_snake_case ) ]
    # [ repr ( C ) ]
    pub struct Handlers {
        # [ doc = "0 - POWER_CLOCK" ]
        pub PowerClock: extern "C" fn(PowerClock),
        # [ doc = "1 - RADIO" ]
        pub Radio: extern "C" fn(Radio),
        # [ doc = "2 - UART0" ]
        pub Uart0: extern "C" fn(Uart0),
        # [ doc = "3 - SPI0_TWI0" ]
        pub Spi0Twi0: extern "C" fn(Spi0Twi0),
        # [ doc = "4 - SPI1_TWI1" ]
        pub Spi1Twi1: extern "C" fn(Spi1Twi1),
        # [ doc = r" Reserved spot in the vector table" ]
        pub _reserved0: [Reserved; 1],
        # [ doc = "6 - GPIOTE" ]
        pub Gpiote: extern "C" fn(Gpiote),
        # [ doc = "7 - ADC" ]
        pub Adc: extern "C" fn(Adc),
        # [ doc = "8 - TIMER0" ]
        pub Timer0: extern "C" fn(Timer0),
        # [ doc = "9 - TIMER1" ]
        pub Timer1: extern "C" fn(Timer1),
        # [ doc = "10 - TIMER2" ]
        pub Timer2: extern "C" fn(Timer2),
        # [ doc = "11 - RTC0" ]
        pub Rtc0: extern "C" fn(Rtc0),
        # [ doc = "12 - TEMP" ]
        pub Temp: extern "C" fn(Temp),
        # [ doc = "13 - RNG" ]
        pub Rng: extern "C" fn(Rng),
        # [ doc = "14 - ECB" ]
        pub Ecb: extern "C" fn(Ecb),
        # [ doc = "15 - CCM_AAR" ]
        pub CcmAar: extern "C" fn(CcmAar),
        # [ doc = "16 - WDT" ]
        pub Wdt: extern "C" fn(Wdt),
        # [ doc = "17 - RTC1" ]
        pub Rtc1: extern "C" fn(Rtc1),
        # [ doc = "18 - QDEC" ]
        pub Qdec: extern "C" fn(Qdec),
        # [ doc = "19 - LPCOMP" ]
        pub Lpcomp: extern "C" fn(Lpcomp),
        # [ doc = "20 - SWI0" ]
        pub Swi0: extern "C" fn(Swi0),
        # [ doc = "21 - SWI1" ]
        pub Swi1: extern "C" fn(Swi1),
        # [ doc = "22 - SWI2" ]
        pub Swi2: extern "C" fn(Swi2),
        # [ doc = "23 - SWI3" ]
        pub Swi3: extern "C" fn(Swi3),
        # [ doc = "24 - SWI4" ]
        pub Swi4: extern "C" fn(Swi4),
        # [ doc = "25 - SWI5" ]
        pub Swi5: extern "C" fn(Swi5),
    }
    # [ doc = r" Default interrupt handlers" ]
    pub const DEFAULT_HANDLERS: Handlers = Handlers {
        PowerClock: exception::default_handler,
        Radio: exception::default_handler,
        Uart0: exception::default_handler,
        Spi0Twi0: exception::default_handler,
        Spi1Twi1: exception::default_handler,
        _reserved0: [Reserved::Vector; 1],
        Gpiote: exception::default_handler,
        Adc: exception::default_handler,
        Timer0: exception::default_handler,
        Timer1: exception::default_handler,
        Timer2: exception::default_handler,
        Rtc0: exception::default_handler,
        Temp: exception::default_handler,
        Rng: exception::default_handler,
        Ecb: exception::default_handler,
        CcmAar: exception::default_handler,
        Wdt: exception::default_handler,
        Rtc1: exception::default_handler,
        Qdec: exception::default_handler,
        Lpcomp: exception::default_handler,
        Swi0: exception::default_handler,
        Swi1: exception::default_handler,
        Swi2: exception::default_handler,
        Swi3: exception::default_handler,
        Swi4: exception::default_handler,
        Swi5: exception::default_handler,
    };
    # [ doc = r" Enumeration of all the interrupts" ]
    pub enum Interrupt {
        # [ doc = "0 - POWER_CLOCK" ]
        PowerClock,
        # [ doc = "1 - RADIO" ]
        Radio,
        # [ doc = "2 - UART0" ]
        Uart0,
        # [ doc = "3 - SPI0_TWI0" ]
        Spi0Twi0,
        # [ doc = "4 - SPI1_TWI1" ]
        Spi1Twi1,
        # [ doc = "6 - GPIOTE" ]
        Gpiote,
        # [ doc = "7 - ADC" ]
        Adc,
        # [ doc = "8 - TIMER0" ]
        Timer0,
        # [ doc = "9 - TIMER1" ]
        Timer1,
        # [ doc = "10 - TIMER2" ]
        Timer2,
        # [ doc = "11 - RTC0" ]
        Rtc0,
        # [ doc = "12 - TEMP" ]
        Temp,
        # [ doc = "13 - RNG" ]
        Rng,
        # [ doc = "14 - ECB" ]
        Ecb,
        # [ doc = "15 - CCM_AAR" ]
        CcmAar,
        # [ doc = "16 - WDT" ]
        Wdt,
        # [ doc = "17 - RTC1" ]
        Rtc1,
        # [ doc = "18 - QDEC" ]
        Qdec,
        # [ doc = "19 - LPCOMP" ]
        Lpcomp,
        # [ doc = "20 - SWI0" ]
        Swi0,
        # [ doc = "21 - SWI1" ]
        Swi1,
        # [ doc = "22 - SWI2" ]
        Swi2,
        # [ doc = "23 - SWI3" ]
        Swi3,
        # [ doc = "24 - SWI4" ]
        Swi4,
        # [ doc = "25 - SWI5" ]
        Swi5,
    }
    unsafe impl Nr for Interrupt {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            match *self {
                Interrupt::PowerClock => 0,
                Interrupt::Radio => 1,
                Interrupt::Uart0 => 2,
                Interrupt::Spi0Twi0 => 3,
                Interrupt::Spi1Twi1 => 4,
                Interrupt::Gpiote => 6,
                Interrupt::Adc => 7,
                Interrupt::Timer0 => 8,
                Interrupt::Timer1 => 9,
                Interrupt::Timer2 => 10,
                Interrupt::Rtc0 => 11,
                Interrupt::Temp => 12,
                Interrupt::Rng => 13,
                Interrupt::Ecb => 14,
                Interrupt::CcmAar => 15,
                Interrupt::Wdt => 16,
                Interrupt::Rtc1 => 17,
                Interrupt::Qdec => 18,
                Interrupt::Lpcomp => 19,
                Interrupt::Swi0 => 20,
                Interrupt::Swi1 => 21,
                Interrupt::Swi2 => 22,
                Interrupt::Swi3 => 23,
                Interrupt::Swi4 => 24,
                Interrupt::Swi5 => 25,
            }
        }
    }
}
# [ doc = "Power Control." ]
pub const POWER: Peripheral<Power> = unsafe { Peripheral::new(1073741824) };
# [ doc = "Power Control." ]
pub mod power {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 120usize],
        # [ doc = "0x78 - Enable constant latency mode." ]
        pub tasks_constlat: TasksConstlat,
        # [ doc = "0x7c - Enable low power mode (variable latency)." ]
        pub tasks_lowpwr: TasksLowpwr,
        _reserved1: [u8; 136usize],
        # [ doc = "0x108 - Power failure warning." ]
        pub events_pofwarn: EventsPofwarn,
        _reserved2: [u8; 504usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved3: [u8; 244usize],
        # [ doc = "0x400 - Reset reason." ]
        pub resetreas: Resetreas,
        _reserved4: [u8; 36usize],
        # [ doc = "0x428 - Ram status register." ]
        pub ramstatus: Ramstatus,
        _reserved5: [u8; 212usize],
        # [ doc = "0x500 - System off register." ]
        pub systemoff: Systemoff,
        _reserved6: [u8; 12usize],
        # [ doc = "0x510 - Power failure configuration." ]
        pub pofcon: Pofcon,
        _reserved7: [u8; 8usize],
        # [ doc = "0x51c - General purpose retention register. This register is a retained register." ]
        pub gpregret: Gpregret,
        _reserved8: [u8; 4usize],
        # [ doc = "0x524 - Ram on/off." ]
        pub ramon: Ramon,
        _reserved9: [u8; 28usize],
        # [ doc = "0x544 - Pin reset functionality configuration register. This register is a retained register." ]
        pub reset: Reset,
        _reserved10: [u8; 12usize],
        # [ doc = "0x554 - Ram on/off." ]
        pub ramonb: Ramonb,
        _reserved11: [u8; 32usize],
        # [ doc = "0x578 - DCDC converter enable configuration register." ]
        pub dcdcen: Dcdcen,
        _reserved12: [u8; 1164usize],
        # [ doc = "0xa08 - DCDC power-up force register." ]
        pub dcdcforce: Dcdcforce,
    }
    # [ doc = "Enable constant latency mode." ]
    pub struct TasksConstlat {
        register: VolatileCell<u32>,
    }
    # [ doc = "Enable constant latency mode." ]
    pub mod tasks_constlat {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksConstlat {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Enable low power mode (variable latency)." ]
    pub struct TasksLowpwr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Enable low power mode (variable latency)." ]
    pub mod tasks_lowpwr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksLowpwr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Power failure warning." ]
    pub struct EventsPofwarn {
        register: VolatileCell<u32>,
    }
    # [ doc = "Power failure warning." ]
    pub mod events_pofwarn {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsPofwarn {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POFWARN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PofwarnR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl PofwarnR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PofwarnR::Disabled => 0,
                    PofwarnR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PofwarnR {
                match bits {
                    0 => PofwarnR::Disabled,
                    1 => PofwarnR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PofwarnR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PofwarnR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POFWARN`" ]
        pub enum PofwarnW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl PofwarnW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PofwarnW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PofwarnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PofwarnW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PofwarnW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(PofwarnW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 2 - Enable interrupt on POFWARN event." ]
            # [ inline ( always ) ]
            pub fn pofwarn(&self) -> PofwarnR {
                PofwarnR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 2 - Enable interrupt on POFWARN event." ]
            # [ inline ( always ) ]
            pub fn pofwarn(&mut self) -> _PofwarnW {
                _PofwarnW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POFWARN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PofwarnR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl PofwarnR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PofwarnR::Disabled => 0,
                    PofwarnR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PofwarnR {
                match bits {
                    0 => PofwarnR::Disabled,
                    1 => PofwarnR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PofwarnR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PofwarnR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POFWARN`" ]
        pub enum PofwarnW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl PofwarnW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PofwarnW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PofwarnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PofwarnW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PofwarnW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(PofwarnW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 2 - Disable interrupt on POFWARN event." ]
            # [ inline ( always ) ]
            pub fn pofwarn(&self) -> PofwarnR {
                PofwarnR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 2 - Disable interrupt on POFWARN event." ]
            # [ inline ( always ) ]
            pub fn pofwarn(&mut self) -> _PofwarnW {
                _PofwarnW { w: self }
            }
        }
    }
    # [ doc = "Reset reason." ]
    pub struct Resetreas {
        register: VolatileCell<u32>,
    }
    # [ doc = "Reset reason." ]
    pub mod resetreas {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Resetreas {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `RESETPIN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ResetpinR {
            # [ doc = "Reset not detected." ]
            NotDetected,
            # [ doc = "Reset detected." ]
            Detected,
        }
        impl ResetpinR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ResetpinR::NotDetected => 0,
                    ResetpinR::Detected => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ResetpinR {
                match bits {
                    0 => ResetpinR::NotDetected,
                    1 => ResetpinR::Detected,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotDetected`" ]
            # [ inline ( always ) ]
            pub fn is_not_detected(&self) -> bool {
                *self == ResetpinR::NotDetected
            }
            # [ doc = "Checks if the value of the field is `Detected`" ]
            # [ inline ( always ) ]
            pub fn is_detected(&self) -> bool {
                *self == ResetpinR::Detected
            }
        }
        # [ doc = "Possible values of the field `DOG`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DogR {
            # [ doc = "Reset not detected." ]
            NotDetected,
            # [ doc = "Reset detected." ]
            Detected,
        }
        impl DogR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DogR::NotDetected => 0,
                    DogR::Detected => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DogR {
                match bits {
                    0 => DogR::NotDetected,
                    1 => DogR::Detected,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotDetected`" ]
            # [ inline ( always ) ]
            pub fn is_not_detected(&self) -> bool {
                *self == DogR::NotDetected
            }
            # [ doc = "Checks if the value of the field is `Detected`" ]
            # [ inline ( always ) ]
            pub fn is_detected(&self) -> bool {
                *self == DogR::Detected
            }
        }
        # [ doc = "Possible values of the field `SREQ`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SreqR {
            # [ doc = "Reset not detected." ]
            NotDetected,
            # [ doc = "Reset detected." ]
            Detected,
        }
        impl SreqR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SreqR::NotDetected => 0,
                    SreqR::Detected => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SreqR {
                match bits {
                    0 => SreqR::NotDetected,
                    1 => SreqR::Detected,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotDetected`" ]
            # [ inline ( always ) ]
            pub fn is_not_detected(&self) -> bool {
                *self == SreqR::NotDetected
            }
            # [ doc = "Checks if the value of the field is `Detected`" ]
            # [ inline ( always ) ]
            pub fn is_detected(&self) -> bool {
                *self == SreqR::Detected
            }
        }
        # [ doc = "Possible values of the field `LOCKUP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum LockupR {
            # [ doc = "Reset not detected." ]
            NotDetected,
            # [ doc = "Reset detected." ]
            Detected,
        }
        impl LockupR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    LockupR::NotDetected => 0,
                    LockupR::Detected => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> LockupR {
                match bits {
                    0 => LockupR::NotDetected,
                    1 => LockupR::Detected,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotDetected`" ]
            # [ inline ( always ) ]
            pub fn is_not_detected(&self) -> bool {
                *self == LockupR::NotDetected
            }
            # [ doc = "Checks if the value of the field is `Detected`" ]
            # [ inline ( always ) ]
            pub fn is_detected(&self) -> bool {
                *self == LockupR::Detected
            }
        }
        # [ doc = "Possible values of the field `OFF`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OffR {
            # [ doc = "Reset not detected." ]
            NotDetected,
            # [ doc = "Reset detected." ]
            Detected,
        }
        impl OffR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OffR::NotDetected => 0,
                    OffR::Detected => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OffR {
                match bits {
                    0 => OffR::NotDetected,
                    1 => OffR::Detected,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotDetected`" ]
            # [ inline ( always ) ]
            pub fn is_not_detected(&self) -> bool {
                *self == OffR::NotDetected
            }
            # [ doc = "Checks if the value of the field is `Detected`" ]
            # [ inline ( always ) ]
            pub fn is_detected(&self) -> bool {
                *self == OffR::Detected
            }
        }
        # [ doc = "Possible values of the field `LPCOMP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum LpcompR {
            # [ doc = "Reset not detected." ]
            NotDetected,
            # [ doc = "Reset detected." ]
            Detected,
        }
        impl LpcompR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    LpcompR::NotDetected => 0,
                    LpcompR::Detected => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> LpcompR {
                match bits {
                    0 => LpcompR::NotDetected,
                    1 => LpcompR::Detected,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotDetected`" ]
            # [ inline ( always ) ]
            pub fn is_not_detected(&self) -> bool {
                *self == LpcompR::NotDetected
            }
            # [ doc = "Checks if the value of the field is `Detected`" ]
            # [ inline ( always ) ]
            pub fn is_detected(&self) -> bool {
                *self == LpcompR::Detected
            }
        }
        # [ doc = "Possible values of the field `DIF`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DifR {
            # [ doc = "Reset not detected." ]
            NotDetected,
            # [ doc = "Reset detected." ]
            Detected,
        }
        impl DifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DifR::NotDetected => 0,
                    DifR::Detected => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DifR {
                match bits {
                    0 => DifR::NotDetected,
                    1 => DifR::Detected,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotDetected`" ]
            # [ inline ( always ) ]
            pub fn is_not_detected(&self) -> bool {
                *self == DifR::NotDetected
            }
            # [ doc = "Checks if the value of the field is `Detected`" ]
            # [ inline ( always ) ]
            pub fn is_detected(&self) -> bool {
                *self == DifR::Detected
            }
        }
        # [ doc = "Values that can be written to the field `RESETPIN`" ]
        pub enum ResetpinW {
            # [ doc = "Reset not detected." ]
            NotDetected,
            # [ doc = "Reset detected." ]
            Detected,
        }
        impl ResetpinW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ResetpinW::NotDetected => 0,
                    ResetpinW::Detected => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ResetpinW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ResetpinW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ResetpinW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Reset not detected." ]
            # [ inline ( always ) ]
            pub fn not_detected(self) -> &'a mut W {
                self.variant(ResetpinW::NotDetected)
            }
            # [ doc = "Reset detected." ]
            # [ inline ( always ) ]
            pub fn detected(self) -> &'a mut W {
                self.variant(ResetpinW::Detected)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DOG`" ]
        pub enum DogW {
            # [ doc = "Reset not detected." ]
            NotDetected,
            # [ doc = "Reset detected." ]
            Detected,
        }
        impl DogW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DogW::NotDetected => 0,
                    DogW::Detected => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DogW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DogW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DogW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Reset not detected." ]
            # [ inline ( always ) ]
            pub fn not_detected(self) -> &'a mut W {
                self.variant(DogW::NotDetected)
            }
            # [ doc = "Reset detected." ]
            # [ inline ( always ) ]
            pub fn detected(self) -> &'a mut W {
                self.variant(DogW::Detected)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `SREQ`" ]
        pub enum SreqW {
            # [ doc = "Reset not detected." ]
            NotDetected,
            # [ doc = "Reset detected." ]
            Detected,
        }
        impl SreqW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SreqW::NotDetected => 0,
                    SreqW::Detected => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SreqW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SreqW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SreqW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Reset not detected." ]
            # [ inline ( always ) ]
            pub fn not_detected(self) -> &'a mut W {
                self.variant(SreqW::NotDetected)
            }
            # [ doc = "Reset detected." ]
            # [ inline ( always ) ]
            pub fn detected(self) -> &'a mut W {
                self.variant(SreqW::Detected)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `LOCKUP`" ]
        pub enum LockupW {
            # [ doc = "Reset not detected." ]
            NotDetected,
            # [ doc = "Reset detected." ]
            Detected,
        }
        impl LockupW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    LockupW::NotDetected => 0,
                    LockupW::Detected => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LockupW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LockupW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: LockupW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Reset not detected." ]
            # [ inline ( always ) ]
            pub fn not_detected(self) -> &'a mut W {
                self.variant(LockupW::NotDetected)
            }
            # [ doc = "Reset detected." ]
            # [ inline ( always ) ]
            pub fn detected(self) -> &'a mut W {
                self.variant(LockupW::Detected)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OFF`" ]
        pub enum OffW {
            # [ doc = "Reset not detected." ]
            NotDetected,
            # [ doc = "Reset detected." ]
            Detected,
        }
        impl OffW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OffW::NotDetected => 0,
                    OffW::Detected => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OffW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OffW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OffW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Reset not detected." ]
            # [ inline ( always ) ]
            pub fn not_detected(self) -> &'a mut W {
                self.variant(OffW::NotDetected)
            }
            # [ doc = "Reset detected." ]
            # [ inline ( always ) ]
            pub fn detected(self) -> &'a mut W {
                self.variant(OffW::Detected)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `LPCOMP`" ]
        pub enum LpcompW {
            # [ doc = "Reset not detected." ]
            NotDetected,
            # [ doc = "Reset detected." ]
            Detected,
        }
        impl LpcompW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    LpcompW::NotDetected => 0,
                    LpcompW::Detected => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LpcompW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LpcompW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: LpcompW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Reset not detected." ]
            # [ inline ( always ) ]
            pub fn not_detected(self) -> &'a mut W {
                self.variant(LpcompW::NotDetected)
            }
            # [ doc = "Reset detected." ]
            # [ inline ( always ) ]
            pub fn detected(self) -> &'a mut W {
                self.variant(LpcompW::Detected)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DIF`" ]
        pub enum DifW {
            # [ doc = "Reset not detected." ]
            NotDetected,
            # [ doc = "Reset detected." ]
            Detected,
        }
        impl DifW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DifW::NotDetected => 0,
                    DifW::Detected => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DifW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DifW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Reset not detected." ]
            # [ inline ( always ) ]
            pub fn not_detected(self) -> &'a mut W {
                self.variant(DifW::NotDetected)
            }
            # [ doc = "Reset detected." ]
            # [ inline ( always ) ]
            pub fn detected(self) -> &'a mut W {
                self.variant(DifW::Detected)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Reset from pin-reset detected." ]
            # [ inline ( always ) ]
            pub fn resetpin(&self) -> ResetpinR {
                ResetpinR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Reset from watchdog detected." ]
            # [ inline ( always ) ]
            pub fn dog(&self) -> DogR {
                DogR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Reset from AIRCR.SYSRESETREQ detected." ]
            # [ inline ( always ) ]
            pub fn sreq(&self) -> SreqR {
                SreqR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Reset from CPU lock-up detected." ]
            # [ inline ( always ) ]
            pub fn lockup(&self) -> LockupR {
                LockupR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - Reset from wake-up from OFF mode detected by the use of DETECT signal from GPIO." ]
            # [ inline ( always ) ]
            pub fn off(&self) -> OffR {
                OffR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Reset from wake-up from OFF mode detected by the use of ANADETECT signal from LPCOMP." ]
            # [ inline ( always ) ]
            pub fn lpcomp(&self) -> LpcompR {
                LpcompR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Reset from wake-up from OFF mode detected by entering into debug interface mode." ]
            # [ inline ( always ) ]
            pub fn dif(&self) -> DifR {
                DifR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Reset from pin-reset detected." ]
            # [ inline ( always ) ]
            pub fn resetpin(&mut self) -> _ResetpinW {
                _ResetpinW { w: self }
            }
            # [ doc = "Bit 1 - Reset from watchdog detected." ]
            # [ inline ( always ) ]
            pub fn dog(&mut self) -> _DogW {
                _DogW { w: self }
            }
            # [ doc = "Bit 2 - Reset from AIRCR.SYSRESETREQ detected." ]
            # [ inline ( always ) ]
            pub fn sreq(&mut self) -> _SreqW {
                _SreqW { w: self }
            }
            # [ doc = "Bit 3 - Reset from CPU lock-up detected." ]
            # [ inline ( always ) ]
            pub fn lockup(&mut self) -> _LockupW {
                _LockupW { w: self }
            }
            # [ doc = "Bit 16 - Reset from wake-up from OFF mode detected by the use of DETECT signal from GPIO." ]
            # [ inline ( always ) ]
            pub fn off(&mut self) -> _OffW {
                _OffW { w: self }
            }
            # [ doc = "Bit 17 - Reset from wake-up from OFF mode detected by the use of ANADETECT signal from LPCOMP." ]
            # [ inline ( always ) ]
            pub fn lpcomp(&mut self) -> _LpcompW {
                _LpcompW { w: self }
            }
            # [ doc = "Bit 18 - Reset from wake-up from OFF mode detected by entering into debug interface mode." ]
            # [ inline ( always ) ]
            pub fn dif(&mut self) -> _DifW {
                _DifW { w: self }
            }
        }
    }
    # [ doc = "Ram status register." ]
    pub struct Ramstatus {
        register: VolatileCell<u32>,
    }
    # [ doc = "Ram status register." ]
    pub mod ramstatus {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Ramstatus {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = "Possible values of the field `RAMBLOCK0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ramblock0R {
            # [ doc = "RAM block 0 is off or powering up." ]
            Off,
            # [ doc = "RAM block 0 is on." ]
            On,
        }
        impl Ramblock0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ramblock0R::Off => 0,
                    Ramblock0R::On => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ramblock0R {
                match bits {
                    0 => Ramblock0R::Off,
                    1 => Ramblock0R::On,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Off`" ]
            # [ inline ( always ) ]
            pub fn is_off(&self) -> bool {
                *self == Ramblock0R::Off
            }
            # [ doc = "Checks if the value of the field is `On`" ]
            # [ inline ( always ) ]
            pub fn is_on(&self) -> bool {
                *self == Ramblock0R::On
            }
        }
        # [ doc = "Possible values of the field `RAMBLOCK1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ramblock1R {
            # [ doc = "RAM block 1 is off or powering up." ]
            Off,
            # [ doc = "RAM block 1 is on." ]
            On,
        }
        impl Ramblock1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ramblock1R::Off => 0,
                    Ramblock1R::On => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ramblock1R {
                match bits {
                    0 => Ramblock1R::Off,
                    1 => Ramblock1R::On,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Off`" ]
            # [ inline ( always ) ]
            pub fn is_off(&self) -> bool {
                *self == Ramblock1R::Off
            }
            # [ doc = "Checks if the value of the field is `On`" ]
            # [ inline ( always ) ]
            pub fn is_on(&self) -> bool {
                *self == Ramblock1R::On
            }
        }
        # [ doc = "Possible values of the field `RAMBLOCK2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ramblock2R {
            # [ doc = "RAM block 2 is off or powering up." ]
            Off,
            # [ doc = "RAM block 2 is on." ]
            On,
        }
        impl Ramblock2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ramblock2R::Off => 0,
                    Ramblock2R::On => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ramblock2R {
                match bits {
                    0 => Ramblock2R::Off,
                    1 => Ramblock2R::On,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Off`" ]
            # [ inline ( always ) ]
            pub fn is_off(&self) -> bool {
                *self == Ramblock2R::Off
            }
            # [ doc = "Checks if the value of the field is `On`" ]
            # [ inline ( always ) ]
            pub fn is_on(&self) -> bool {
                *self == Ramblock2R::On
            }
        }
        # [ doc = "Possible values of the field `RAMBLOCK3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ramblock3R {
            # [ doc = "RAM block 3 is off or powering up." ]
            Off,
            # [ doc = "RAM block 3 is on." ]
            On,
        }
        impl Ramblock3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ramblock3R::Off => 0,
                    Ramblock3R::On => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ramblock3R {
                match bits {
                    0 => Ramblock3R::Off,
                    1 => Ramblock3R::On,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Off`" ]
            # [ inline ( always ) ]
            pub fn is_off(&self) -> bool {
                *self == Ramblock3R::Off
            }
            # [ doc = "Checks if the value of the field is `On`" ]
            # [ inline ( always ) ]
            pub fn is_on(&self) -> bool {
                *self == Ramblock3R::On
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - RAM block 0 status." ]
            # [ inline ( always ) ]
            pub fn ramblock0(&self) -> Ramblock0R {
                Ramblock0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - RAM block 1 status." ]
            # [ inline ( always ) ]
            pub fn ramblock1(&self) -> Ramblock1R {
                Ramblock1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - RAM block 2 status." ]
            # [ inline ( always ) ]
            pub fn ramblock2(&self) -> Ramblock2R {
                Ramblock2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - RAM block 3 status." ]
            # [ inline ( always ) ]
            pub fn ramblock3(&self) -> Ramblock3R {
                Ramblock3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
    }
    # [ doc = "System off register." ]
    pub struct Systemoff {
        register: VolatileCell<u32>,
    }
    # [ doc = "System off register." ]
    pub mod systemoff {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Systemoff {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Values that can be written to the field `SYSTEMOFF`" ]
        pub enum SystemoffW {
            # [ doc = "Enter system off mode." ]
            Enter,
        }
        impl SystemoffW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SystemoffW::Enter => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SystemoffW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SystemoffW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SystemoffW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enter system off mode." ]
            # [ inline ( always ) ]
            pub fn enter(self) -> &'a mut W {
                self.variant(SystemoffW::Enter)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enter system off mode." ]
            # [ inline ( always ) ]
            pub fn systemoff(&mut self) -> _SystemoffW {
                _SystemoffW { w: self }
            }
        }
    }
    # [ doc = "Power failure configuration." ]
    pub struct Pofcon {
        register: VolatileCell<u32>,
    }
    # [ doc = "Power failure configuration." ]
    pub mod pofcon {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pofcon {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POF`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PofR {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl PofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PofR::Disabled => 0,
                    PofR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PofR {
                match bits {
                    0 => PofR::Disabled,
                    1 => PofR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PofR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PofR::Enabled
            }
        }
        # [ doc = "Possible values of the field `THRESHOLD`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ThresholdR {
            # [ doc = "Set threshold to 2.1Volts." ]
            V21,
            # [ doc = "Set threshold to 2.3Volts." ]
            V23,
            # [ doc = "Set threshold to 2.5Volts." ]
            V25,
            # [ doc = "Set threshold to 2.7Volts." ]
            V27,
        }
        impl ThresholdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ThresholdR::V21 => 0,
                    ThresholdR::V23 => 1,
                    ThresholdR::V25 => 2,
                    ThresholdR::V27 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ThresholdR {
                match bits {
                    0 => ThresholdR::V21,
                    1 => ThresholdR::V23,
                    2 => ThresholdR::V25,
                    3 => ThresholdR::V27,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `V21`" ]
            # [ inline ( always ) ]
            pub fn is_v21(&self) -> bool {
                *self == ThresholdR::V21
            }
            # [ doc = "Checks if the value of the field is `V23`" ]
            # [ inline ( always ) ]
            pub fn is_v23(&self) -> bool {
                *self == ThresholdR::V23
            }
            # [ doc = "Checks if the value of the field is `V25`" ]
            # [ inline ( always ) ]
            pub fn is_v25(&self) -> bool {
                *self == ThresholdR::V25
            }
            # [ doc = "Checks if the value of the field is `V27`" ]
            # [ inline ( always ) ]
            pub fn is_v27(&self) -> bool {
                *self == ThresholdR::V27
            }
        }
        # [ doc = "Values that can be written to the field `POF`" ]
        pub enum PofW {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl PofW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PofW::Disabled => 0,
                    PofW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PofW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PofW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PofW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PofW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `THRESHOLD`" ]
        pub enum ThresholdW {
            # [ doc = "Set threshold to 2.1Volts." ]
            V21,
            # [ doc = "Set threshold to 2.3Volts." ]
            V23,
            # [ doc = "Set threshold to 2.5Volts." ]
            V25,
            # [ doc = "Set threshold to 2.7Volts." ]
            V27,
        }
        impl ThresholdW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ThresholdW::V21 => 0,
                    ThresholdW::V23 => 1,
                    ThresholdW::V25 => 2,
                    ThresholdW::V27 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ThresholdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ThresholdW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ThresholdW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Set threshold to 2.1Volts." ]
            # [ inline ( always ) ]
            pub fn v21(self) -> &'a mut W {
                self.variant(ThresholdW::V21)
            }
            # [ doc = "Set threshold to 2.3Volts." ]
            # [ inline ( always ) ]
            pub fn v23(self) -> &'a mut W {
                self.variant(ThresholdW::V23)
            }
            # [ doc = "Set threshold to 2.5Volts." ]
            # [ inline ( always ) ]
            pub fn v25(self) -> &'a mut W {
                self.variant(ThresholdW::V25)
            }
            # [ doc = "Set threshold to 2.7Volts." ]
            # [ inline ( always ) ]
            pub fn v27(self) -> &'a mut W {
                self.variant(ThresholdW::V27)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Power failure comparator enable." ]
            # [ inline ( always ) ]
            pub fn pof(&self) -> PofR {
                PofR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bits 1:2 - Set threshold level." ]
            # [ inline ( always ) ]
            pub fn threshold(&self) -> ThresholdR {
                ThresholdR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Power failure comparator enable." ]
            # [ inline ( always ) ]
            pub fn pof(&mut self) -> _PofW {
                _PofW { w: self }
            }
            # [ doc = "Bits 1:2 - Set threshold level." ]
            # [ inline ( always ) ]
            pub fn threshold(&mut self) -> _ThresholdW {
                _ThresholdW { w: self }
            }
        }
    }
    # [ doc = "General purpose retention register. This register is a retained register." ]
    pub struct Gpregret {
        register: VolatileCell<u32>,
    }
    # [ doc = "General purpose retention register. This register is a retained register." ]
    pub mod gpregret {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Gpregret {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct GpregretR {
            bits: u8,
        }
        impl GpregretR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _GpregretW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GpregretW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - General purpose retention register." ]
            # [ inline ( always ) ]
            pub fn gpregret(&self) -> GpregretR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                GpregretR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - General purpose retention register." ]
            # [ inline ( always ) ]
            pub fn gpregret(&mut self) -> _GpregretW {
                _GpregretW { w: self }
            }
        }
    }
    # [ doc = "Ram on/off." ]
    pub struct Ramon {
        register: VolatileCell<u32>,
    }
    # [ doc = "Ram on/off." ]
    pub mod ramon {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ramon {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ONRAM0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Onram0R {
            # [ doc = "RAM block 0 OFF in ON mode." ]
            Ram0off,
            # [ doc = "RAM block 0 ON in ON mode." ]
            Ram0on,
        }
        impl Onram0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Onram0R::Ram0off => 0,
                    Onram0R::Ram0on => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Onram0R {
                match bits {
                    0 => Onram0R::Ram0off,
                    1 => Onram0R::Ram0on,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ram0off`" ]
            # [ inline ( always ) ]
            pub fn is_ram0off(&self) -> bool {
                *self == Onram0R::Ram0off
            }
            # [ doc = "Checks if the value of the field is `Ram0on`" ]
            # [ inline ( always ) ]
            pub fn is_ram0on(&self) -> bool {
                *self == Onram0R::Ram0on
            }
        }
        # [ doc = "Possible values of the field `ONRAM1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Onram1R {
            # [ doc = "RAM block 1 OFF in ON mode." ]
            Ram1off,
            # [ doc = "RAM block 1 ON in ON mode." ]
            Ram1on,
        }
        impl Onram1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Onram1R::Ram1off => 0,
                    Onram1R::Ram1on => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Onram1R {
                match bits {
                    0 => Onram1R::Ram1off,
                    1 => Onram1R::Ram1on,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ram1off`" ]
            # [ inline ( always ) ]
            pub fn is_ram1off(&self) -> bool {
                *self == Onram1R::Ram1off
            }
            # [ doc = "Checks if the value of the field is `Ram1on`" ]
            # [ inline ( always ) ]
            pub fn is_ram1on(&self) -> bool {
                *self == Onram1R::Ram1on
            }
        }
        # [ doc = "Possible values of the field `OFFRAM0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Offram0R {
            # [ doc = "RAM block 0 OFF in OFF mode." ]
            Ram0off,
            # [ doc = "RAM block 0 ON in OFF mode." ]
            Ram0on,
        }
        impl Offram0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Offram0R::Ram0off => 0,
                    Offram0R::Ram0on => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Offram0R {
                match bits {
                    0 => Offram0R::Ram0off,
                    1 => Offram0R::Ram0on,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ram0off`" ]
            # [ inline ( always ) ]
            pub fn is_ram0off(&self) -> bool {
                *self == Offram0R::Ram0off
            }
            # [ doc = "Checks if the value of the field is `Ram0on`" ]
            # [ inline ( always ) ]
            pub fn is_ram0on(&self) -> bool {
                *self == Offram0R::Ram0on
            }
        }
        # [ doc = "Possible values of the field `OFFRAM1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Offram1R {
            # [ doc = "RAM block 1 OFF in OFF mode." ]
            Ram1off,
            # [ doc = "RAM block 1 ON in OFF mode." ]
            Ram1on,
        }
        impl Offram1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Offram1R::Ram1off => 0,
                    Offram1R::Ram1on => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Offram1R {
                match bits {
                    0 => Offram1R::Ram1off,
                    1 => Offram1R::Ram1on,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ram1off`" ]
            # [ inline ( always ) ]
            pub fn is_ram1off(&self) -> bool {
                *self == Offram1R::Ram1off
            }
            # [ doc = "Checks if the value of the field is `Ram1on`" ]
            # [ inline ( always ) ]
            pub fn is_ram1on(&self) -> bool {
                *self == Offram1R::Ram1on
            }
        }
        # [ doc = "Values that can be written to the field `ONRAM0`" ]
        pub enum Onram0W {
            # [ doc = "RAM block 0 OFF in ON mode." ]
            Ram0off,
            # [ doc = "RAM block 0 ON in ON mode." ]
            Ram0on,
        }
        impl Onram0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Onram0W::Ram0off => 0,
                    Onram0W::Ram0on => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Onram0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Onram0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Onram0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RAM block 0 OFF in ON mode." ]
            # [ inline ( always ) ]
            pub fn ram0off(self) -> &'a mut W {
                self.variant(Onram0W::Ram0off)
            }
            # [ doc = "RAM block 0 ON in ON mode." ]
            # [ inline ( always ) ]
            pub fn ram0on(self) -> &'a mut W {
                self.variant(Onram0W::Ram0on)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ONRAM1`" ]
        pub enum Onram1W {
            # [ doc = "RAM block 1 OFF in ON mode." ]
            Ram1off,
            # [ doc = "RAM block 1 ON in ON mode." ]
            Ram1on,
        }
        impl Onram1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Onram1W::Ram1off => 0,
                    Onram1W::Ram1on => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Onram1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Onram1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Onram1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RAM block 1 OFF in ON mode." ]
            # [ inline ( always ) ]
            pub fn ram1off(self) -> &'a mut W {
                self.variant(Onram1W::Ram1off)
            }
            # [ doc = "RAM block 1 ON in ON mode." ]
            # [ inline ( always ) ]
            pub fn ram1on(self) -> &'a mut W {
                self.variant(Onram1W::Ram1on)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OFFRAM0`" ]
        pub enum Offram0W {
            # [ doc = "RAM block 0 OFF in OFF mode." ]
            Ram0off,
            # [ doc = "RAM block 0 ON in OFF mode." ]
            Ram0on,
        }
        impl Offram0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Offram0W::Ram0off => 0,
                    Offram0W::Ram0on => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Offram0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Offram0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Offram0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RAM block 0 OFF in OFF mode." ]
            # [ inline ( always ) ]
            pub fn ram0off(self) -> &'a mut W {
                self.variant(Offram0W::Ram0off)
            }
            # [ doc = "RAM block 0 ON in OFF mode." ]
            # [ inline ( always ) ]
            pub fn ram0on(self) -> &'a mut W {
                self.variant(Offram0W::Ram0on)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OFFRAM1`" ]
        pub enum Offram1W {
            # [ doc = "RAM block 1 OFF in OFF mode." ]
            Ram1off,
            # [ doc = "RAM block 1 ON in OFF mode." ]
            Ram1on,
        }
        impl Offram1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Offram1W::Ram1off => 0,
                    Offram1W::Ram1on => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Offram1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Offram1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Offram1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RAM block 1 OFF in OFF mode." ]
            # [ inline ( always ) ]
            pub fn ram1off(self) -> &'a mut W {
                self.variant(Offram1W::Ram1off)
            }
            # [ doc = "RAM block 1 ON in OFF mode." ]
            # [ inline ( always ) ]
            pub fn ram1on(self) -> &'a mut W {
                self.variant(Offram1W::Ram1on)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - RAM block 0 behaviour in ON mode." ]
            # [ inline ( always ) ]
            pub fn onram0(&self) -> Onram0R {
                Onram0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - RAM block 1 behaviour in ON mode." ]
            # [ inline ( always ) ]
            pub fn onram1(&self) -> Onram1R {
                Onram1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - RAM block 0 behaviour in OFF mode." ]
            # [ inline ( always ) ]
            pub fn offram0(&self) -> Offram0R {
                Offram0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - RAM block 1 behaviour in OFF mode." ]
            # [ inline ( always ) ]
            pub fn offram1(&self) -> Offram1R {
                Offram1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 3 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - RAM block 0 behaviour in ON mode." ]
            # [ inline ( always ) ]
            pub fn onram0(&mut self) -> _Onram0W {
                _Onram0W { w: self }
            }
            # [ doc = "Bit 1 - RAM block 1 behaviour in ON mode." ]
            # [ inline ( always ) ]
            pub fn onram1(&mut self) -> _Onram1W {
                _Onram1W { w: self }
            }
            # [ doc = "Bit 16 - RAM block 0 behaviour in OFF mode." ]
            # [ inline ( always ) ]
            pub fn offram0(&mut self) -> _Offram0W {
                _Offram0W { w: self }
            }
            # [ doc = "Bit 17 - RAM block 1 behaviour in OFF mode." ]
            # [ inline ( always ) ]
            pub fn offram1(&mut self) -> _Offram1W {
                _Offram1W { w: self }
            }
        }
    }
    # [ doc = "Pin reset functionality configuration register. This register is a retained register." ]
    pub struct Reset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin reset functionality configuration register. This register is a retained register." ]
    pub mod reset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Reset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `RESET`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ResetR {
            # [ doc = "Pin reset in debug interface mode disabled." ]
            Disabled,
            # [ doc = "Pin reset in debug interface mode enabled." ]
            Enabled,
        }
        impl ResetR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ResetR::Disabled => 0,
                    ResetR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ResetR {
                match bits {
                    0 => ResetR::Disabled,
                    1 => ResetR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ResetR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ResetR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `RESET`" ]
        pub enum ResetW {
            # [ doc = "Pin reset in debug interface mode disabled." ]
            Disabled,
            # [ doc = "Pin reset in debug interface mode enabled." ]
            Enabled,
        }
        impl ResetW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ResetW::Disabled => 0,
                    ResetW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ResetW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ResetW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ResetW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin reset in debug interface mode disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ResetW::Disabled)
            }
            # [ doc = "Pin reset in debug interface mode enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ResetW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable or disable pin reset in debug interface mode." ]
            # [ inline ( always ) ]
            pub fn reset(&self) -> ResetR {
                ResetR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable or disable pin reset in debug interface mode." ]
            # [ inline ( always ) ]
            pub fn reset(&mut self) -> _ResetW {
                _ResetW { w: self }
            }
        }
    }
    # [ doc = "Ram on/off." ]
    pub struct Ramonb {
        register: VolatileCell<u32>,
    }
    # [ doc = "Ram on/off." ]
    pub mod ramonb {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ramonb {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ONRAM2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Onram2R {
            # [ doc = "RAM block 2 OFF in ON mode." ]
            Ram2off,
            # [ doc = "RAM block 2 ON in ON mode." ]
            Ram2on,
        }
        impl Onram2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Onram2R::Ram2off => 0,
                    Onram2R::Ram2on => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Onram2R {
                match bits {
                    0 => Onram2R::Ram2off,
                    1 => Onram2R::Ram2on,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ram2off`" ]
            # [ inline ( always ) ]
            pub fn is_ram2off(&self) -> bool {
                *self == Onram2R::Ram2off
            }
            # [ doc = "Checks if the value of the field is `Ram2on`" ]
            # [ inline ( always ) ]
            pub fn is_ram2on(&self) -> bool {
                *self == Onram2R::Ram2on
            }
        }
        # [ doc = "Possible values of the field `ONRAM3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Onram3R {
            # [ doc = "RAM block 33 OFF in ON mode." ]
            Ram3off,
            # [ doc = "RAM block 3 ON in ON mode." ]
            Ram3on,
        }
        impl Onram3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Onram3R::Ram3off => 0,
                    Onram3R::Ram3on => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Onram3R {
                match bits {
                    0 => Onram3R::Ram3off,
                    1 => Onram3R::Ram3on,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ram3off`" ]
            # [ inline ( always ) ]
            pub fn is_ram3off(&self) -> bool {
                *self == Onram3R::Ram3off
            }
            # [ doc = "Checks if the value of the field is `Ram3on`" ]
            # [ inline ( always ) ]
            pub fn is_ram3on(&self) -> bool {
                *self == Onram3R::Ram3on
            }
        }
        # [ doc = "Possible values of the field `OFFRAM2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Offram2R {
            # [ doc = "RAM block 2 OFF in OFF mode." ]
            Ram2off,
            # [ doc = "RAM block 2 ON in OFF mode." ]
            Ram2on,
        }
        impl Offram2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Offram2R::Ram2off => 0,
                    Offram2R::Ram2on => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Offram2R {
                match bits {
                    0 => Offram2R::Ram2off,
                    1 => Offram2R::Ram2on,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ram2off`" ]
            # [ inline ( always ) ]
            pub fn is_ram2off(&self) -> bool {
                *self == Offram2R::Ram2off
            }
            # [ doc = "Checks if the value of the field is `Ram2on`" ]
            # [ inline ( always ) ]
            pub fn is_ram2on(&self) -> bool {
                *self == Offram2R::Ram2on
            }
        }
        # [ doc = "Possible values of the field `OFFRAM3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Offram3R {
            # [ doc = "RAM block 3 OFF in OFF mode." ]
            Ram3off,
            # [ doc = "RAM block 3 ON in OFF mode." ]
            Ram3on,
        }
        impl Offram3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Offram3R::Ram3off => 0,
                    Offram3R::Ram3on => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Offram3R {
                match bits {
                    0 => Offram3R::Ram3off,
                    1 => Offram3R::Ram3on,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ram3off`" ]
            # [ inline ( always ) ]
            pub fn is_ram3off(&self) -> bool {
                *self == Offram3R::Ram3off
            }
            # [ doc = "Checks if the value of the field is `Ram3on`" ]
            # [ inline ( always ) ]
            pub fn is_ram3on(&self) -> bool {
                *self == Offram3R::Ram3on
            }
        }
        # [ doc = "Values that can be written to the field `ONRAM2`" ]
        pub enum Onram2W {
            # [ doc = "RAM block 2 OFF in ON mode." ]
            Ram2off,
            # [ doc = "RAM block 2 ON in ON mode." ]
            Ram2on,
        }
        impl Onram2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Onram2W::Ram2off => 0,
                    Onram2W::Ram2on => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Onram2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Onram2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Onram2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RAM block 2 OFF in ON mode." ]
            # [ inline ( always ) ]
            pub fn ram2off(self) -> &'a mut W {
                self.variant(Onram2W::Ram2off)
            }
            # [ doc = "RAM block 2 ON in ON mode." ]
            # [ inline ( always ) ]
            pub fn ram2on(self) -> &'a mut W {
                self.variant(Onram2W::Ram2on)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ONRAM3`" ]
        pub enum Onram3W {
            # [ doc = "RAM block 33 OFF in ON mode." ]
            Ram3off,
            # [ doc = "RAM block 3 ON in ON mode." ]
            Ram3on,
        }
        impl Onram3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Onram3W::Ram3off => 0,
                    Onram3W::Ram3on => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Onram3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Onram3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Onram3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RAM block 33 OFF in ON mode." ]
            # [ inline ( always ) ]
            pub fn ram3off(self) -> &'a mut W {
                self.variant(Onram3W::Ram3off)
            }
            # [ doc = "RAM block 3 ON in ON mode." ]
            # [ inline ( always ) ]
            pub fn ram3on(self) -> &'a mut W {
                self.variant(Onram3W::Ram3on)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OFFRAM2`" ]
        pub enum Offram2W {
            # [ doc = "RAM block 2 OFF in OFF mode." ]
            Ram2off,
            # [ doc = "RAM block 2 ON in OFF mode." ]
            Ram2on,
        }
        impl Offram2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Offram2W::Ram2off => 0,
                    Offram2W::Ram2on => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Offram2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Offram2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Offram2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RAM block 2 OFF in OFF mode." ]
            # [ inline ( always ) ]
            pub fn ram2off(self) -> &'a mut W {
                self.variant(Offram2W::Ram2off)
            }
            # [ doc = "RAM block 2 ON in OFF mode." ]
            # [ inline ( always ) ]
            pub fn ram2on(self) -> &'a mut W {
                self.variant(Offram2W::Ram2on)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OFFRAM3`" ]
        pub enum Offram3W {
            # [ doc = "RAM block 3 OFF in OFF mode." ]
            Ram3off,
            # [ doc = "RAM block 3 ON in OFF mode." ]
            Ram3on,
        }
        impl Offram3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Offram3W::Ram3off => 0,
                    Offram3W::Ram3on => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Offram3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Offram3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Offram3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RAM block 3 OFF in OFF mode." ]
            # [ inline ( always ) ]
            pub fn ram3off(self) -> &'a mut W {
                self.variant(Offram3W::Ram3off)
            }
            # [ doc = "RAM block 3 ON in OFF mode." ]
            # [ inline ( always ) ]
            pub fn ram3on(self) -> &'a mut W {
                self.variant(Offram3W::Ram3on)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - RAM block 2 behaviour in ON mode." ]
            # [ inline ( always ) ]
            pub fn onram2(&self) -> Onram2R {
                Onram2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - RAM block 3 behaviour in ON mode." ]
            # [ inline ( always ) ]
            pub fn onram3(&self) -> Onram3R {
                Onram3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - RAM block 2 behaviour in OFF mode." ]
            # [ inline ( always ) ]
            pub fn offram2(&self) -> Offram2R {
                Offram2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - RAM block 3 behaviour in OFF mode." ]
            # [ inline ( always ) ]
            pub fn offram3(&self) -> Offram3R {
                Offram3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 3 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - RAM block 2 behaviour in ON mode." ]
            # [ inline ( always ) ]
            pub fn onram2(&mut self) -> _Onram2W {
                _Onram2W { w: self }
            }
            # [ doc = "Bit 1 - RAM block 3 behaviour in ON mode." ]
            # [ inline ( always ) ]
            pub fn onram3(&mut self) -> _Onram3W {
                _Onram3W { w: self }
            }
            # [ doc = "Bit 16 - RAM block 2 behaviour in OFF mode." ]
            # [ inline ( always ) ]
            pub fn offram2(&mut self) -> _Offram2W {
                _Offram2W { w: self }
            }
            # [ doc = "Bit 17 - RAM block 3 behaviour in OFF mode." ]
            # [ inline ( always ) ]
            pub fn offram3(&mut self) -> _Offram3W {
                _Offram3W { w: self }
            }
        }
    }
    # [ doc = "DCDC converter enable configuration register." ]
    pub struct Dcdcen {
        register: VolatileCell<u32>,
    }
    # [ doc = "DCDC converter enable configuration register." ]
    pub mod dcdcen {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dcdcen {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `DCDCEN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DcdcenR {
            # [ doc = "DCDC converter disabled." ]
            Disabled,
            # [ doc = "DCDC converter enabled." ]
            Enabled,
        }
        impl DcdcenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DcdcenR::Disabled => 0,
                    DcdcenR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DcdcenR {
                match bits {
                    0 => DcdcenR::Disabled,
                    1 => DcdcenR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DcdcenR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DcdcenR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `DCDCEN`" ]
        pub enum DcdcenW {
            # [ doc = "DCDC converter disabled." ]
            Disabled,
            # [ doc = "DCDC converter enabled." ]
            Enabled,
        }
        impl DcdcenW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DcdcenW::Disabled => 0,
                    DcdcenW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DcdcenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DcdcenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DcdcenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "DCDC converter disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DcdcenW::Disabled)
            }
            # [ doc = "DCDC converter enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DcdcenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable DCDC converter." ]
            # [ inline ( always ) ]
            pub fn dcdcen(&self) -> DcdcenR {
                DcdcenR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable DCDC converter." ]
            # [ inline ( always ) ]
            pub fn dcdcen(&mut self) -> _DcdcenW {
                _DcdcenW { w: self }
            }
        }
    }
    # [ doc = "DCDC power-up force register." ]
    pub struct Dcdcforce {
        register: VolatileCell<u32>,
    }
    # [ doc = "DCDC power-up force register." ]
    pub mod dcdcforce {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dcdcforce {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `FORCEOFF`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ForceoffR {
            # [ doc = "No force." ]
            NoForce,
            # [ doc = "Force." ]
            Force,
        }
        impl ForceoffR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ForceoffR::NoForce => 0,
                    ForceoffR::Force => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ForceoffR {
                match bits {
                    0 => ForceoffR::NoForce,
                    1 => ForceoffR::Force,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NoForce`" ]
            # [ inline ( always ) ]
            pub fn is_no_force(&self) -> bool {
                *self == ForceoffR::NoForce
            }
            # [ doc = "Checks if the value of the field is `Force`" ]
            # [ inline ( always ) ]
            pub fn is_force(&self) -> bool {
                *self == ForceoffR::Force
            }
        }
        # [ doc = "Possible values of the field `FORCEON`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ForceonR {
            # [ doc = "No force." ]
            NoForce,
            # [ doc = "Force." ]
            Force,
        }
        impl ForceonR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ForceonR::NoForce => 0,
                    ForceonR::Force => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ForceonR {
                match bits {
                    0 => ForceonR::NoForce,
                    1 => ForceonR::Force,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NoForce`" ]
            # [ inline ( always ) ]
            pub fn is_no_force(&self) -> bool {
                *self == ForceonR::NoForce
            }
            # [ doc = "Checks if the value of the field is `Force`" ]
            # [ inline ( always ) ]
            pub fn is_force(&self) -> bool {
                *self == ForceonR::Force
            }
        }
        # [ doc = "Values that can be written to the field `FORCEOFF`" ]
        pub enum ForceoffW {
            # [ doc = "No force." ]
            NoForce,
            # [ doc = "Force." ]
            Force,
        }
        impl ForceoffW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ForceoffW::NoForce => 0,
                    ForceoffW::Force => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ForceoffW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ForceoffW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ForceoffW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "No force." ]
            # [ inline ( always ) ]
            pub fn no_force(self) -> &'a mut W {
                self.variant(ForceoffW::NoForce)
            }
            # [ doc = "Force." ]
            # [ inline ( always ) ]
            pub fn force(self) -> &'a mut W {
                self.variant(ForceoffW::Force)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `FORCEON`" ]
        pub enum ForceonW {
            # [ doc = "No force." ]
            NoForce,
            # [ doc = "Force." ]
            Force,
        }
        impl ForceonW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ForceonW::NoForce => 0,
                    ForceonW::Force => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ForceonW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ForceonW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ForceonW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "No force." ]
            # [ inline ( always ) ]
            pub fn no_force(self) -> &'a mut W {
                self.variant(ForceonW::NoForce)
            }
            # [ doc = "Force." ]
            # [ inline ( always ) ]
            pub fn force(self) -> &'a mut W {
                self.variant(ForceonW::Force)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - DCDC power-up force off." ]
            # [ inline ( always ) ]
            pub fn forceoff(&self) -> ForceoffR {
                ForceoffR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - DCDC power-up force on." ]
            # [ inline ( always ) ]
            pub fn forceon(&self) -> ForceonR {
                ForceonR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - DCDC power-up force off." ]
            # [ inline ( always ) ]
            pub fn forceoff(&mut self) -> _ForceoffW {
                _ForceoffW { w: self }
            }
            # [ doc = "Bit 1 - DCDC power-up force on." ]
            # [ inline ( always ) ]
            pub fn forceon(&mut self) -> _ForceonW {
                _ForceonW { w: self }
            }
        }
    }
}
# [ doc = "Power Control." ]
pub struct Power {
    register_block: power::RegisterBlock,
}
impl Deref for Power {
    type Target = power::RegisterBlock;
    fn deref(&self) -> &power::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Clock control." ]
pub const CLOCK: Peripheral<Clock> = unsafe { Peripheral::new(1073741824) };
# [ doc = "Clock control." ]
pub mod clock {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Start HFCLK clock source." ]
        pub tasks_hfclkstart: TasksHfclkstart,
        # [ doc = "0x04 - Stop HFCLK clock source." ]
        pub tasks_hfclkstop: TasksHfclkstop,
        # [ doc = "0x08 - Start LFCLK clock source." ]
        pub tasks_lfclkstart: TasksLfclkstart,
        # [ doc = "0x0c - Stop LFCLK clock source." ]
        pub tasks_lfclkstop: TasksLfclkstop,
        # [ doc = "0x10 - Start calibration of LFCLK RC oscillator." ]
        pub tasks_cal: TasksCal,
        # [ doc = "0x14 - Start calibration timer." ]
        pub tasks_ctstart: TasksCtstart,
        # [ doc = "0x18 - Stop calibration timer." ]
        pub tasks_ctstop: TasksCtstop,
        _reserved0: [u8; 228usize],
        # [ doc = "0x100 - HFCLK oscillator started." ]
        pub events_hfclkstarted: EventsHfclkstarted,
        # [ doc = "0x104 - LFCLK oscillator started." ]
        pub events_lfclkstarted: EventsLfclkstarted,
        _reserved1: [u8; 4usize],
        # [ doc = "0x10c - Calibration of LFCLK RC oscillator completed." ]
        pub events_done: EventsDone,
        # [ doc = "0x110 - Calibration timer timeout." ]
        pub events_ctto: EventsCtto,
        _reserved2: [u8; 496usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved3: [u8; 252usize],
        # [ doc = "0x408 - Task HFCLKSTART trigger status." ]
        pub hfclkrun: Hfclkrun,
        # [ doc = "0x40c - High frequency clock status." ]
        pub hfclkstat: Hfclkstat,
        _reserved4: [u8; 4usize],
        # [ doc = "0x414 - Task LFCLKSTART triggered status." ]
        pub lfclkrun: Lfclkrun,
        # [ doc = "0x418 - Low frequency clock status." ]
        pub lfclkstat: Lfclkstat,
        # [ doc = "0x41c - Clock source for the LFCLK clock, set when task LKCLKSTART is triggered." ]
        pub lfclksrccopy: Lfclksrccopy,
        _reserved5: [u8; 248usize],
        # [ doc = "0x518 - Clock source for the LFCLK clock." ]
        pub lfclksrc: Lfclksrc,
        _reserved6: [u8; 28usize],
        # [ doc = "0x538 - Calibration timer interval." ]
        pub ctiv: Ctiv,
        _reserved7: [u8; 20usize],
        # [ doc = "0x550 - Crystal frequency." ]
        pub xtalfreq: Xtalfreq,
    }
    # [ doc = "Start HFCLK clock source." ]
    pub struct TasksHfclkstart {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start HFCLK clock source." ]
    pub mod tasks_hfclkstart {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksHfclkstart {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop HFCLK clock source." ]
    pub struct TasksHfclkstop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop HFCLK clock source." ]
    pub mod tasks_hfclkstop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksHfclkstop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Start LFCLK clock source." ]
    pub struct TasksLfclkstart {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start LFCLK clock source." ]
    pub mod tasks_lfclkstart {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksLfclkstart {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop LFCLK clock source." ]
    pub struct TasksLfclkstop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop LFCLK clock source." ]
    pub mod tasks_lfclkstop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksLfclkstop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Start calibration of LFCLK RC oscillator." ]
    pub struct TasksCal {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start calibration of LFCLK RC oscillator." ]
    pub mod tasks_cal {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksCal {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Start calibration timer." ]
    pub struct TasksCtstart {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start calibration timer." ]
    pub mod tasks_ctstart {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksCtstart {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop calibration timer." ]
    pub struct TasksCtstop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop calibration timer." ]
    pub mod tasks_ctstop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksCtstop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "HFCLK oscillator started." ]
    pub struct EventsHfclkstarted {
        register: VolatileCell<u32>,
    }
    # [ doc = "HFCLK oscillator started." ]
    pub mod events_hfclkstarted {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsHfclkstarted {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "LFCLK oscillator started." ]
    pub struct EventsLfclkstarted {
        register: VolatileCell<u32>,
    }
    # [ doc = "LFCLK oscillator started." ]
    pub mod events_lfclkstarted {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsLfclkstarted {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Calibration of LFCLK RC oscillator completed." ]
    pub struct EventsDone {
        register: VolatileCell<u32>,
    }
    # [ doc = "Calibration of LFCLK RC oscillator completed." ]
    pub mod events_done {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsDone {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Calibration timer timeout." ]
    pub struct EventsCtto {
        register: VolatileCell<u32>,
    }
    # [ doc = "Calibration timer timeout." ]
    pub mod events_ctto {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsCtto {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `HFCLKSTARTED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum HfclkstartedR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl HfclkstartedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    HfclkstartedR::Disabled => 0,
                    HfclkstartedR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> HfclkstartedR {
                match bits {
                    0 => HfclkstartedR::Disabled,
                    1 => HfclkstartedR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == HfclkstartedR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == HfclkstartedR::Enabled
            }
        }
        # [ doc = "Possible values of the field `LFCLKSTARTED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum LfclkstartedR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl LfclkstartedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    LfclkstartedR::Disabled => 0,
                    LfclkstartedR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> LfclkstartedR {
                match bits {
                    0 => LfclkstartedR::Disabled,
                    1 => LfclkstartedR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == LfclkstartedR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == LfclkstartedR::Enabled
            }
        }
        # [ doc = "Possible values of the field `DONE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DoneR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl DoneR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DoneR::Disabled => 0,
                    DoneR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DoneR {
                match bits {
                    0 => DoneR::Disabled,
                    1 => DoneR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DoneR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DoneR::Enabled
            }
        }
        # [ doc = "Possible values of the field `CTTO`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CttoR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl CttoR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CttoR::Disabled => 0,
                    CttoR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CttoR {
                match bits {
                    0 => CttoR::Disabled,
                    1 => CttoR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == CttoR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == CttoR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `HFCLKSTARTED`" ]
        pub enum HfclkstartedW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl HfclkstartedW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    HfclkstartedW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HfclkstartedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HfclkstartedW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: HfclkstartedW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(HfclkstartedW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `LFCLKSTARTED`" ]
        pub enum LfclkstartedW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl LfclkstartedW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    LfclkstartedW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LfclkstartedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LfclkstartedW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: LfclkstartedW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(LfclkstartedW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DONE`" ]
        pub enum DoneW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl DoneW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DoneW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DoneW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DoneW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DoneW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(DoneW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CTTO`" ]
        pub enum CttoW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl CttoW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CttoW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CttoW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CttoW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CttoW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(CttoW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable interrupt on HFCLKSTARTED event." ]
            # [ inline ( always ) ]
            pub fn hfclkstarted(&self) -> HfclkstartedR {
                HfclkstartedR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Enable interrupt on LFCLKSTARTED event." ]
            # [ inline ( always ) ]
            pub fn lfclkstarted(&self) -> LfclkstartedR {
                LfclkstartedR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Enable interrupt on DONE event." ]
            # [ inline ( always ) ]
            pub fn done(&self) -> DoneR {
                DoneR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Enable interrupt on CTTO event." ]
            # [ inline ( always ) ]
            pub fn ctto(&self) -> CttoR {
                CttoR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable interrupt on HFCLKSTARTED event." ]
            # [ inline ( always ) ]
            pub fn hfclkstarted(&mut self) -> _HfclkstartedW {
                _HfclkstartedW { w: self }
            }
            # [ doc = "Bit 1 - Enable interrupt on LFCLKSTARTED event." ]
            # [ inline ( always ) ]
            pub fn lfclkstarted(&mut self) -> _LfclkstartedW {
                _LfclkstartedW { w: self }
            }
            # [ doc = "Bit 3 - Enable interrupt on DONE event." ]
            # [ inline ( always ) ]
            pub fn done(&mut self) -> _DoneW {
                _DoneW { w: self }
            }
            # [ doc = "Bit 4 - Enable interrupt on CTTO event." ]
            # [ inline ( always ) ]
            pub fn ctto(&mut self) -> _CttoW {
                _CttoW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `HFCLKSTARTED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum HfclkstartedR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl HfclkstartedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    HfclkstartedR::Disabled => 0,
                    HfclkstartedR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> HfclkstartedR {
                match bits {
                    0 => HfclkstartedR::Disabled,
                    1 => HfclkstartedR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == HfclkstartedR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == HfclkstartedR::Enabled
            }
        }
        # [ doc = "Possible values of the field `LFCLKSTARTED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum LfclkstartedR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl LfclkstartedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    LfclkstartedR::Disabled => 0,
                    LfclkstartedR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> LfclkstartedR {
                match bits {
                    0 => LfclkstartedR::Disabled,
                    1 => LfclkstartedR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == LfclkstartedR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == LfclkstartedR::Enabled
            }
        }
        # [ doc = "Possible values of the field `DONE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DoneR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl DoneR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DoneR::Disabled => 0,
                    DoneR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DoneR {
                match bits {
                    0 => DoneR::Disabled,
                    1 => DoneR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DoneR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DoneR::Enabled
            }
        }
        # [ doc = "Possible values of the field `CTTO`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CttoR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl CttoR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CttoR::Disabled => 0,
                    CttoR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CttoR {
                match bits {
                    0 => CttoR::Disabled,
                    1 => CttoR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == CttoR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == CttoR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `HFCLKSTARTED`" ]
        pub enum HfclkstartedW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl HfclkstartedW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    HfclkstartedW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HfclkstartedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HfclkstartedW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: HfclkstartedW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(HfclkstartedW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `LFCLKSTARTED`" ]
        pub enum LfclkstartedW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl LfclkstartedW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    LfclkstartedW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LfclkstartedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LfclkstartedW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: LfclkstartedW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(LfclkstartedW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DONE`" ]
        pub enum DoneW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl DoneW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DoneW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DoneW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DoneW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DoneW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(DoneW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CTTO`" ]
        pub enum CttoW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl CttoW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CttoW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CttoW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CttoW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CttoW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(CttoW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable interrupt on HFCLKSTARTED event." ]
            # [ inline ( always ) ]
            pub fn hfclkstarted(&self) -> HfclkstartedR {
                HfclkstartedR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Disable interrupt on LFCLKSTARTED event." ]
            # [ inline ( always ) ]
            pub fn lfclkstarted(&self) -> LfclkstartedR {
                LfclkstartedR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Disable interrupt on DONE event." ]
            # [ inline ( always ) ]
            pub fn done(&self) -> DoneR {
                DoneR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Disable interrupt on CTTO event." ]
            # [ inline ( always ) ]
            pub fn ctto(&self) -> CttoR {
                CttoR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable interrupt on HFCLKSTARTED event." ]
            # [ inline ( always ) ]
            pub fn hfclkstarted(&mut self) -> _HfclkstartedW {
                _HfclkstartedW { w: self }
            }
            # [ doc = "Bit 1 - Disable interrupt on LFCLKSTARTED event." ]
            # [ inline ( always ) ]
            pub fn lfclkstarted(&mut self) -> _LfclkstartedW {
                _LfclkstartedW { w: self }
            }
            # [ doc = "Bit 3 - Disable interrupt on DONE event." ]
            # [ inline ( always ) ]
            pub fn done(&mut self) -> _DoneW {
                _DoneW { w: self }
            }
            # [ doc = "Bit 4 - Disable interrupt on CTTO event." ]
            # [ inline ( always ) ]
            pub fn ctto(&mut self) -> _CttoW {
                _CttoW { w: self }
            }
        }
    }
    # [ doc = "Task HFCLKSTART trigger status." ]
    pub struct Hfclkrun {
        register: VolatileCell<u32>,
    }
    # [ doc = "Task HFCLKSTART trigger status." ]
    pub mod hfclkrun {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Hfclkrun {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = "Possible values of the field `STATUS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum StatusR {
            # [ doc = "Task HFCLKSTART has not been triggered." ]
            NotTriggered,
            # [ doc = "Task HFCLKSTART has been triggered." ]
            Triggered,
        }
        impl StatusR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    StatusR::NotTriggered => 0,
                    StatusR::Triggered => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> StatusR {
                match bits {
                    0 => StatusR::NotTriggered,
                    1 => StatusR::Triggered,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotTriggered`" ]
            # [ inline ( always ) ]
            pub fn is_not_triggered(&self) -> bool {
                *self == StatusR::NotTriggered
            }
            # [ doc = "Checks if the value of the field is `Triggered`" ]
            # [ inline ( always ) ]
            pub fn is_triggered(&self) -> bool {
                *self == StatusR::Triggered
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Task HFCLKSTART trigger status." ]
            # [ inline ( always ) ]
            pub fn status(&self) -> StatusR {
                StatusR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
    }
    # [ doc = "High frequency clock status." ]
    pub struct Hfclkstat {
        register: VolatileCell<u32>,
    }
    # [ doc = "High frequency clock status." ]
    pub mod hfclkstat {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Hfclkstat {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = "Possible values of the field `SRC`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SrcR {
            # [ doc = "Internal 16MHz RC oscillator running and generating the HFCLK clock." ]
            Rc,
            # [ doc = "External 16MHz/32MHz crystal oscillator running and generating the HFCLK clock." ]
            Xtal,
        }
        impl SrcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SrcR::Rc => 0,
                    SrcR::Xtal => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SrcR {
                match bits {
                    0 => SrcR::Rc,
                    1 => SrcR::Xtal,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Rc`" ]
            # [ inline ( always ) ]
            pub fn is_rc(&self) -> bool {
                *self == SrcR::Rc
            }
            # [ doc = "Checks if the value of the field is `Xtal`" ]
            # [ inline ( always ) ]
            pub fn is_xtal(&self) -> bool {
                *self == SrcR::Xtal
            }
        }
        # [ doc = "Possible values of the field `STATE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum StateR {
            # [ doc = "HFCLK clock not running." ]
            NotRunning,
            # [ doc = "HFCLK clock running." ]
            Running,
        }
        impl StateR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    StateR::NotRunning => 0,
                    StateR::Running => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> StateR {
                match bits {
                    0 => StateR::NotRunning,
                    1 => StateR::Running,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotRunning`" ]
            # [ inline ( always ) ]
            pub fn is_not_running(&self) -> bool {
                *self == StateR::NotRunning
            }
            # [ doc = "Checks if the value of the field is `Running`" ]
            # [ inline ( always ) ]
            pub fn is_running(&self) -> bool {
                *self == StateR::Running
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Active clock source for the HF clock." ]
            # [ inline ( always ) ]
            pub fn src(&self) -> SrcR {
                SrcR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - State for the HFCLK." ]
            # [ inline ( always ) ]
            pub fn state(&self) -> StateR {
                StateR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
    }
    # [ doc = "Task LFCLKSTART triggered status." ]
    pub struct Lfclkrun {
        register: VolatileCell<u32>,
    }
    # [ doc = "Task LFCLKSTART triggered status." ]
    pub mod lfclkrun {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Lfclkrun {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = "Possible values of the field `STATUS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum StatusR {
            # [ doc = "Task LFCLKSTART has not been triggered." ]
            NotTriggered,
            # [ doc = "Task LFCLKSTART has been triggered." ]
            Triggered,
        }
        impl StatusR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    StatusR::NotTriggered => 0,
                    StatusR::Triggered => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> StatusR {
                match bits {
                    0 => StatusR::NotTriggered,
                    1 => StatusR::Triggered,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotTriggered`" ]
            # [ inline ( always ) ]
            pub fn is_not_triggered(&self) -> bool {
                *self == StatusR::NotTriggered
            }
            # [ doc = "Checks if the value of the field is `Triggered`" ]
            # [ inline ( always ) ]
            pub fn is_triggered(&self) -> bool {
                *self == StatusR::Triggered
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Task LFCLKSTART triggered status." ]
            # [ inline ( always ) ]
            pub fn status(&self) -> StatusR {
                StatusR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
    }
    # [ doc = "Low frequency clock status." ]
    pub struct Lfclkstat {
        register: VolatileCell<u32>,
    }
    # [ doc = "Low frequency clock status." ]
    pub mod lfclkstat {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Lfclkstat {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = "Possible values of the field `SRC`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SrcR {
            # [ doc = "Internal 32KiHz RC oscillator running and generating the LFCLK clock." ]
            Rc,
            # [ doc = "External 32KiHz crystal oscillator running and generating the LFCLK clock." ]
            Xtal,
            # [ doc = "Internal 32KiHz synthesizer from the HFCLK running and generating the LFCLK clock." ]
            Synth,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl SrcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SrcR::Rc => 0,
                    SrcR::Xtal => 1,
                    SrcR::Synth => 2,
                    SrcR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SrcR {
                match bits {
                    0 => SrcR::Rc,
                    1 => SrcR::Xtal,
                    2 => SrcR::Synth,
                    i => SrcR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Rc`" ]
            # [ inline ( always ) ]
            pub fn is_rc(&self) -> bool {
                *self == SrcR::Rc
            }
            # [ doc = "Checks if the value of the field is `Xtal`" ]
            # [ inline ( always ) ]
            pub fn is_xtal(&self) -> bool {
                *self == SrcR::Xtal
            }
            # [ doc = "Checks if the value of the field is `Synth`" ]
            # [ inline ( always ) ]
            pub fn is_synth(&self) -> bool {
                *self == SrcR::Synth
            }
        }
        # [ doc = "Possible values of the field `STATE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum StateR {
            # [ doc = "LFCLK clock not running." ]
            NotRunning,
            # [ doc = "LFCLK clock running." ]
            Running,
        }
        impl StateR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    StateR::NotRunning => 0,
                    StateR::Running => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> StateR {
                match bits {
                    0 => StateR::NotRunning,
                    1 => StateR::Running,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotRunning`" ]
            # [ inline ( always ) ]
            pub fn is_not_running(&self) -> bool {
                *self == StateR::NotRunning
            }
            # [ doc = "Checks if the value of the field is `Running`" ]
            # [ inline ( always ) ]
            pub fn is_running(&self) -> bool {
                *self == StateR::Running
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - Active clock source for the LF clock." ]
            # [ inline ( always ) ]
            pub fn src(&self) -> SrcR {
                SrcR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - State for the LF clock." ]
            # [ inline ( always ) ]
            pub fn state(&self) -> StateR {
                StateR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
    }
    # [ doc = "Clock source for the LFCLK clock, set when task LKCLKSTART is triggered." ]
    pub struct Lfclksrccopy {
        register: VolatileCell<u32>,
    }
    # [ doc = "Clock source for the LFCLK clock, set when task LKCLKSTART is triggered." ]
    pub mod lfclksrccopy {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Lfclksrccopy {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = "Possible values of the field `SRC`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SrcR {
            # [ doc = "Internal 32KiHz RC oscillator." ]
            Rc,
            # [ doc = "External 32KiHz crystal." ]
            Xtal,
            # [ doc = "Internal 32KiHz synthesizer from HFCLK system clock." ]
            Synth,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl SrcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SrcR::Rc => 0,
                    SrcR::Xtal => 1,
                    SrcR::Synth => 2,
                    SrcR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SrcR {
                match bits {
                    0 => SrcR::Rc,
                    1 => SrcR::Xtal,
                    2 => SrcR::Synth,
                    i => SrcR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Rc`" ]
            # [ inline ( always ) ]
            pub fn is_rc(&self) -> bool {
                *self == SrcR::Rc
            }
            # [ doc = "Checks if the value of the field is `Xtal`" ]
            # [ inline ( always ) ]
            pub fn is_xtal(&self) -> bool {
                *self == SrcR::Xtal
            }
            # [ doc = "Checks if the value of the field is `Synth`" ]
            # [ inline ( always ) ]
            pub fn is_synth(&self) -> bool {
                *self == SrcR::Synth
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - Clock source for the LFCLK clock, set when task LKCLKSTART is triggered." ]
            # [ inline ( always ) ]
            pub fn src(&self) -> SrcR {
                SrcR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
    }
    # [ doc = "Clock source for the LFCLK clock." ]
    pub struct Lfclksrc {
        register: VolatileCell<u32>,
    }
    # [ doc = "Clock source for the LFCLK clock." ]
    pub mod lfclksrc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Lfclksrc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `SRC`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SrcR {
            # [ doc = "Internal 32KiHz RC oscillator." ]
            Rc,
            # [ doc = "External 32KiHz crystal." ]
            Xtal,
            # [ doc = "Internal 32KiHz synthesizer from HFCLK system clock." ]
            Synth,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl SrcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SrcR::Rc => 0,
                    SrcR::Xtal => 1,
                    SrcR::Synth => 2,
                    SrcR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SrcR {
                match bits {
                    0 => SrcR::Rc,
                    1 => SrcR::Xtal,
                    2 => SrcR::Synth,
                    i => SrcR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Rc`" ]
            # [ inline ( always ) ]
            pub fn is_rc(&self) -> bool {
                *self == SrcR::Rc
            }
            # [ doc = "Checks if the value of the field is `Xtal`" ]
            # [ inline ( always ) ]
            pub fn is_xtal(&self) -> bool {
                *self == SrcR::Xtal
            }
            # [ doc = "Checks if the value of the field is `Synth`" ]
            # [ inline ( always ) ]
            pub fn is_synth(&self) -> bool {
                *self == SrcR::Synth
            }
        }
        # [ doc = "Values that can be written to the field `SRC`" ]
        pub enum SrcW {
            # [ doc = "Internal 32KiHz RC oscillator." ]
            Rc,
            # [ doc = "External 32KiHz crystal." ]
            Xtal,
            # [ doc = "Internal 32KiHz synthesizer from HFCLK system clock." ]
            Synth,
        }
        impl SrcW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SrcW::Rc => 0,
                    SrcW::Xtal => 1,
                    SrcW::Synth => 2,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SrcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SrcW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SrcW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Internal 32KiHz RC oscillator." ]
            # [ inline ( always ) ]
            pub fn rc(self) -> &'a mut W {
                self.variant(SrcW::Rc)
            }
            # [ doc = "External 32KiHz crystal." ]
            # [ inline ( always ) ]
            pub fn xtal(self) -> &'a mut W {
                self.variant(SrcW::Xtal)
            }
            # [ doc = "Internal 32KiHz synthesizer from HFCLK system clock." ]
            # [ inline ( always ) ]
            pub fn synth(self) -> &'a mut W {
                self.variant(SrcW::Synth)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - Clock source." ]
            # [ inline ( always ) ]
            pub fn src(&self) -> SrcR {
                SrcR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - Clock source." ]
            # [ inline ( always ) ]
            pub fn src(&mut self) -> _SrcW {
                _SrcW { w: self }
            }
        }
    }
    # [ doc = "Calibration timer interval." ]
    pub struct Ctiv {
        register: VolatileCell<u32>,
    }
    # [ doc = "Calibration timer interval." ]
    pub mod ctiv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ctiv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CtivR {
            bits: u8,
        }
        impl CtivR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CtivW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CtivW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:6 - Calibration timer interval in 0.25s resolution." ]
            # [ inline ( always ) ]
            pub fn ctiv(&self) -> CtivR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CtivR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:6 - Calibration timer interval in 0.25s resolution." ]
            # [ inline ( always ) ]
            pub fn ctiv(&mut self) -> _CtivW {
                _CtivW { w: self }
            }
        }
    }
    # [ doc = "Crystal frequency." ]
    pub struct Xtalfreq {
        register: VolatileCell<u32>,
    }
    # [ doc = "Crystal frequency." ]
    pub mod xtalfreq {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Xtalfreq {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `XTALFREQ`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum XtalfreqR {
            # [ doc = "16MHz xtal is used as source for the HFCLK oscillator." ]
            _16mhz,
            # [ doc = "32MHz xtal is used as source for the HFCLK oscillator." ]
            _32mhz,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl XtalfreqR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    XtalfreqR::_16mhz => 255,
                    XtalfreqR::_32mhz => 0,
                    XtalfreqR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> XtalfreqR {
                match bits {
                    255 => XtalfreqR::_16mhz,
                    0 => XtalfreqR::_32mhz,
                    i => XtalfreqR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `_16mhz`" ]
            # [ inline ( always ) ]
            pub fn is_16mhz(&self) -> bool {
                *self == XtalfreqR::_16mhz
            }
            # [ doc = "Checks if the value of the field is `_32mhz`" ]
            # [ inline ( always ) ]
            pub fn is_32mhz(&self) -> bool {
                *self == XtalfreqR::_32mhz
            }
        }
        # [ doc = "Values that can be written to the field `XTALFREQ`" ]
        pub enum XtalfreqW {
            # [ doc = "16MHz xtal is used as source for the HFCLK oscillator." ]
            _16mhz,
            # [ doc = "32MHz xtal is used as source for the HFCLK oscillator." ]
            _32mhz,
        }
        impl XtalfreqW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    XtalfreqW::_16mhz => 255,
                    XtalfreqW::_32mhz => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _XtalfreqW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XtalfreqW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: XtalfreqW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "16MHz xtal is used as source for the HFCLK oscillator." ]
            # [ inline ( always ) ]
            pub fn _16mhz(self) -> &'a mut W {
                self.variant(XtalfreqW::_16mhz)
            }
            # [ doc = "32MHz xtal is used as source for the HFCLK oscillator." ]
            # [ inline ( always ) ]
            pub fn _32mhz(self) -> &'a mut W {
                self.variant(XtalfreqW::_32mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - External Xtal frequency selection." ]
            # [ inline ( always ) ]
            pub fn xtalfreq(&self) -> XtalfreqR {
                XtalfreqR::_from(
                    {
                        const MASK: u8 = 255;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - External Xtal frequency selection." ]
            # [ inline ( always ) ]
            pub fn xtalfreq(&mut self) -> _XtalfreqW {
                _XtalfreqW { w: self }
            }
        }
    }
}
# [ doc = "Clock control." ]
pub struct Clock {
    register_block: clock::RegisterBlock,
}
impl Deref for Clock {
    type Target = clock::RegisterBlock;
    fn deref(&self) -> &clock::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Memory Protection Unit." ]
pub const MPU: Peripheral<Mpu> = unsafe { Peripheral::new(1073741824) };
# [ doc = "Memory Protection Unit." ]
pub mod mpu {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 1320usize],
        # [ doc = "0x528 - Configuration of peripherals in mpu regions." ]
        pub perr0: Perr0,
        # [ doc = "0x52c - Length of RAM region 0." ]
        pub rlenr0: Rlenr0,
        _reserved1: [u8; 208usize],
        # [ doc = "0x600 - Erase and write protection bit enable set register." ]
        pub protenset0: Protenset0,
        # [ doc = "0x604 - Erase and write protection bit enable set register." ]
        pub protenset1: Protenset1,
        # [ doc = "0x608 - Disable erase and write protection mechanism in debug mode." ]
        pub disableindebug: Disableindebug,
        # [ doc = "0x60c - Erase and write protection block size." ]
        pub protblocksize: Protblocksize,
    }
    # [ doc = "Configuration of peripherals in mpu regions." ]
    pub struct Perr0 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Configuration of peripherals in mpu regions." ]
    pub mod perr0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Perr0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER_CLOCK`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerClockR {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl PowerClockR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerClockR::InRegion0 => 1,
                    PowerClockR::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerClockR {
                match bits {
                    1 => PowerClockR::InRegion0,
                    0 => PowerClockR::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == PowerClockR::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == PowerClockR::InRegion1
            }
        }
        # [ doc = "Possible values of the field `RADIO`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RadioR {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl RadioR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RadioR::InRegion0 => 1,
                    RadioR::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RadioR {
                match bits {
                    1 => RadioR::InRegion0,
                    0 => RadioR::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == RadioR::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == RadioR::InRegion1
            }
        }
        # [ doc = "Possible values of the field `UART0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Uart0R {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl Uart0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Uart0R::InRegion0 => 1,
                    Uart0R::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Uart0R {
                match bits {
                    1 => Uart0R::InRegion0,
                    0 => Uart0R::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == Uart0R::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == Uart0R::InRegion1
            }
        }
        # [ doc = "Possible values of the field `SPI0_TWI0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Spi0Twi0R {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl Spi0Twi0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Spi0Twi0R::InRegion0 => 1,
                    Spi0Twi0R::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Spi0Twi0R {
                match bits {
                    1 => Spi0Twi0R::InRegion0,
                    0 => Spi0Twi0R::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == Spi0Twi0R::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == Spi0Twi0R::InRegion1
            }
        }
        # [ doc = "Possible values of the field `SPI1_TWI1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Spi1Twi1R {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl Spi1Twi1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Spi1Twi1R::InRegion0 => 1,
                    Spi1Twi1R::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Spi1Twi1R {
                match bits {
                    1 => Spi1Twi1R::InRegion0,
                    0 => Spi1Twi1R::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == Spi1Twi1R::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == Spi1Twi1R::InRegion1
            }
        }
        # [ doc = "Possible values of the field `GPIOTE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum GpioteR {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl GpioteR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    GpioteR::InRegion0 => 1,
                    GpioteR::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> GpioteR {
                match bits {
                    1 => GpioteR::InRegion0,
                    0 => GpioteR::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == GpioteR::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == GpioteR::InRegion1
            }
        }
        # [ doc = "Possible values of the field `ADC`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum AdcR {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl AdcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    AdcR::InRegion0 => 1,
                    AdcR::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> AdcR {
                match bits {
                    1 => AdcR::InRegion0,
                    0 => AdcR::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == AdcR::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == AdcR::InRegion1
            }
        }
        # [ doc = "Possible values of the field `TIMER0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Timer0R {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl Timer0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Timer0R::InRegion0 => 1,
                    Timer0R::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Timer0R {
                match bits {
                    1 => Timer0R::InRegion0,
                    0 => Timer0R::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == Timer0R::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == Timer0R::InRegion1
            }
        }
        # [ doc = "Possible values of the field `TIMER1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Timer1R {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl Timer1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Timer1R::InRegion0 => 1,
                    Timer1R::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Timer1R {
                match bits {
                    1 => Timer1R::InRegion0,
                    0 => Timer1R::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == Timer1R::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == Timer1R::InRegion1
            }
        }
        # [ doc = "Possible values of the field `TIMER2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Timer2R {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl Timer2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Timer2R::InRegion0 => 1,
                    Timer2R::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Timer2R {
                match bits {
                    1 => Timer2R::InRegion0,
                    0 => Timer2R::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == Timer2R::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == Timer2R::InRegion1
            }
        }
        # [ doc = "Possible values of the field `RTC0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rtc0R {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl Rtc0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rtc0R::InRegion0 => 1,
                    Rtc0R::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rtc0R {
                match bits {
                    1 => Rtc0R::InRegion0,
                    0 => Rtc0R::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == Rtc0R::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == Rtc0R::InRegion1
            }
        }
        # [ doc = "Possible values of the field `TEMP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TempR {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl TempR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TempR::InRegion0 => 1,
                    TempR::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TempR {
                match bits {
                    1 => TempR::InRegion0,
                    0 => TempR::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == TempR::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == TempR::InRegion1
            }
        }
        # [ doc = "Possible values of the field `RNG`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RngR {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl RngR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RngR::InRegion0 => 1,
                    RngR::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RngR {
                match bits {
                    1 => RngR::InRegion0,
                    0 => RngR::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == RngR::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == RngR::InRegion1
            }
        }
        # [ doc = "Possible values of the field `ECB`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EcbR {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl EcbR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EcbR::InRegion0 => 1,
                    EcbR::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EcbR {
                match bits {
                    1 => EcbR::InRegion0,
                    0 => EcbR::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == EcbR::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == EcbR::InRegion1
            }
        }
        # [ doc = "Possible values of the field `CCM_AAR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CcmAarR {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl CcmAarR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CcmAarR::InRegion0 => 1,
                    CcmAarR::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CcmAarR {
                match bits {
                    1 => CcmAarR::InRegion0,
                    0 => CcmAarR::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == CcmAarR::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == CcmAarR::InRegion1
            }
        }
        # [ doc = "Possible values of the field `WDT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum WdtR {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl WdtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    WdtR::InRegion0 => 1,
                    WdtR::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> WdtR {
                match bits {
                    1 => WdtR::InRegion0,
                    0 => WdtR::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == WdtR::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == WdtR::InRegion1
            }
        }
        # [ doc = "Possible values of the field `RTC1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rtc1R {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl Rtc1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rtc1R::InRegion0 => 1,
                    Rtc1R::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rtc1R {
                match bits {
                    1 => Rtc1R::InRegion0,
                    0 => Rtc1R::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == Rtc1R::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == Rtc1R::InRegion1
            }
        }
        # [ doc = "Possible values of the field `QDEC`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum QdecR {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl QdecR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    QdecR::InRegion0 => 1,
                    QdecR::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> QdecR {
                match bits {
                    1 => QdecR::InRegion0,
                    0 => QdecR::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == QdecR::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == QdecR::InRegion1
            }
        }
        # [ doc = "Possible values of the field `LPCOMP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum LpcompR {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl LpcompR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    LpcompR::InRegion0 => 1,
                    LpcompR::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> LpcompR {
                match bits {
                    1 => LpcompR::InRegion0,
                    0 => LpcompR::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == LpcompR::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == LpcompR::InRegion1
            }
        }
        # [ doc = "Possible values of the field `NVMC`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum NvmcR {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl NvmcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    NvmcR::InRegion0 => 1,
                    NvmcR::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> NvmcR {
                match bits {
                    1 => NvmcR::InRegion0,
                    0 => NvmcR::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == NvmcR::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == NvmcR::InRegion1
            }
        }
        # [ doc = "Possible values of the field `PPI`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PpiR {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl PpiR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PpiR::InRegion0 => 1,
                    PpiR::InRegion1 => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PpiR {
                match bits {
                    1 => PpiR::InRegion0,
                    0 => PpiR::InRegion1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `InRegion0`" ]
            # [ inline ( always ) ]
            pub fn is_in_region0(&self) -> bool {
                *self == PpiR::InRegion0
            }
            # [ doc = "Checks if the value of the field is `InRegion1`" ]
            # [ inline ( always ) ]
            pub fn is_in_region1(&self) -> bool {
                *self == PpiR::InRegion1
            }
        }
        # [ doc = "Values that can be written to the field `POWER_CLOCK`" ]
        pub enum PowerClockW {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl PowerClockW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerClockW::InRegion0 => 1,
                    PowerClockW::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerClockW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerClockW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerClockW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(PowerClockW::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(PowerClockW::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RADIO`" ]
        pub enum RadioW {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl RadioW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RadioW::InRegion0 => 1,
                    RadioW::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RadioW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RadioW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RadioW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(RadioW::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(RadioW::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `UART0`" ]
        pub enum Uart0W {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl Uart0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Uart0W::InRegion0 => 1,
                    Uart0W::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Uart0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Uart0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Uart0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(Uart0W::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(Uart0W::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `SPI0_TWI0`" ]
        pub enum Spi0Twi0W {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl Spi0Twi0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Spi0Twi0W::InRegion0 => 1,
                    Spi0Twi0W::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Spi0Twi0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Spi0Twi0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Spi0Twi0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(Spi0Twi0W::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(Spi0Twi0W::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `SPI1_TWI1`" ]
        pub enum Spi1Twi1W {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl Spi1Twi1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Spi1Twi1W::InRegion0 => 1,
                    Spi1Twi1W::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Spi1Twi1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Spi1Twi1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Spi1Twi1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(Spi1Twi1W::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(Spi1Twi1W::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `GPIOTE`" ]
        pub enum GpioteW {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl GpioteW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    GpioteW::InRegion0 => 1,
                    GpioteW::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _GpioteW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GpioteW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: GpioteW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(GpioteW::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(GpioteW::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADC`" ]
        pub enum AdcW {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl AdcW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AdcW::InRegion0 => 1,
                    AdcW::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AdcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AdcW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: AdcW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(AdcW::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(AdcW::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TIMER0`" ]
        pub enum Timer0W {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl Timer0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Timer0W::InRegion0 => 1,
                    Timer0W::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Timer0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Timer0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Timer0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(Timer0W::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(Timer0W::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TIMER1`" ]
        pub enum Timer1W {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl Timer1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Timer1W::InRegion0 => 1,
                    Timer1W::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Timer1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Timer1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Timer1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(Timer1W::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(Timer1W::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TIMER2`" ]
        pub enum Timer2W {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl Timer2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Timer2W::InRegion0 => 1,
                    Timer2W::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Timer2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Timer2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Timer2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(Timer2W::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(Timer2W::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RTC0`" ]
        pub enum Rtc0W {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl Rtc0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Rtc0W::InRegion0 => 1,
                    Rtc0W::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rtc0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rtc0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Rtc0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(Rtc0W::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(Rtc0W::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TEMP`" ]
        pub enum TempW {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl TempW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TempW::InRegion0 => 1,
                    TempW::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TempW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TempW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TempW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(TempW::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(TempW::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RNG`" ]
        pub enum RngW {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl RngW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RngW::InRegion0 => 1,
                    RngW::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RngW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RngW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RngW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(RngW::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(RngW::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ECB`" ]
        pub enum EcbW {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl EcbW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EcbW::InRegion0 => 1,
                    EcbW::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EcbW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EcbW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EcbW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(EcbW::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(EcbW::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CCM_AAR`" ]
        pub enum CcmAarW {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl CcmAarW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CcmAarW::InRegion0 => 1,
                    CcmAarW::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcmAarW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcmAarW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CcmAarW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(CcmAarW::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(CcmAarW::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `WDT`" ]
        pub enum WdtW {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl WdtW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WdtW::InRegion0 => 1,
                    WdtW::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WdtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WdtW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: WdtW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(WdtW::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(WdtW::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RTC1`" ]
        pub enum Rtc1W {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl Rtc1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Rtc1W::InRegion0 => 1,
                    Rtc1W::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rtc1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rtc1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Rtc1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(Rtc1W::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(Rtc1W::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `QDEC`" ]
        pub enum QdecW {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl QdecW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    QdecW::InRegion0 => 1,
                    QdecW::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _QdecW<'a> {
            w: &'a mut W,
        }
        impl<'a> _QdecW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: QdecW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(QdecW::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(QdecW::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `LPCOMP`" ]
        pub enum LpcompW {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl LpcompW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    LpcompW::InRegion0 => 1,
                    LpcompW::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LpcompW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LpcompW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: LpcompW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(LpcompW::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(LpcompW::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `NVMC`" ]
        pub enum NvmcW {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl NvmcW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    NvmcW::InRegion0 => 1,
                    NvmcW::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NvmcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NvmcW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: NvmcW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(NvmcW::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(NvmcW::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PPI`" ]
        pub enum PpiW {
            # [ doc = "Peripheral configured in region 0." ]
            InRegion0,
            # [ doc = "Peripheral configured in region 1." ]
            InRegion1,
        }
        impl PpiW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PpiW::InRegion0 => 1,
                    PpiW::InRegion1 => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PpiW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PpiW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PpiW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Peripheral configured in region 0." ]
            # [ inline ( always ) ]
            pub fn in_region0(self) -> &'a mut W {
                self.variant(PpiW::InRegion0)
            }
            # [ doc = "Peripheral configured in region 1." ]
            # [ inline ( always ) ]
            pub fn in_region1(self) -> &'a mut W {
                self.variant(PpiW::InRegion1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - POWER_CLOCK region configuration." ]
            # [ inline ( always ) ]
            pub fn power_clock(&self) -> PowerClockR {
                PowerClockR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - RADIO region configuration." ]
            # [ inline ( always ) ]
            pub fn radio(&self) -> RadioR {
                RadioR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - UART0 region configuration." ]
            # [ inline ( always ) ]
            pub fn uart0(&self) -> Uart0R {
                Uart0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - SPI0 and TWI0 region configuration." ]
            # [ inline ( always ) ]
            pub fn spi0_twi0(&self) -> Spi0Twi0R {
                Spi0Twi0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - SPI1 and TWI1 region configuration." ]
            # [ inline ( always ) ]
            pub fn spi1_twi1(&self) -> Spi1Twi1R {
                Spi1Twi1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - GPIOTE region configuration." ]
            # [ inline ( always ) ]
            pub fn gpiote(&self) -> GpioteR {
                GpioteR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - ADC region configuration." ]
            # [ inline ( always ) ]
            pub fn adc(&self) -> AdcR {
                AdcR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - TIMER0 region configuration." ]
            # [ inline ( always ) ]
            pub fn timer0(&self) -> Timer0R {
                Timer0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - TIMER1 region configuration." ]
            # [ inline ( always ) ]
            pub fn timer1(&self) -> Timer1R {
                Timer1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - TIMER2 region configuration." ]
            # [ inline ( always ) ]
            pub fn timer2(&self) -> Timer2R {
                Timer2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 11 - RTC0 region configuration." ]
            # [ inline ( always ) ]
            pub fn rtc0(&self) -> Rtc0R {
                Rtc0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 12 - TEMP region configuration." ]
            # [ inline ( always ) ]
            pub fn temp(&self) -> TempR {
                TempR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 13 - RNG region configuration." ]
            # [ inline ( always ) ]
            pub fn rng(&self) -> RngR {
                RngR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 13;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 14 - ECB region configuration." ]
            # [ inline ( always ) ]
            pub fn ecb(&self) -> EcbR {
                EcbR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 15 - CCM and AAR region configuration." ]
            # [ inline ( always ) ]
            pub fn ccm_aar(&self) -> CcmAarR {
                CcmAarR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 15;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - WDT region configuration." ]
            # [ inline ( always ) ]
            pub fn wdt(&self) -> WdtR {
                WdtR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - RTC1 region configuration." ]
            # [ inline ( always ) ]
            pub fn rtc1(&self) -> Rtc1R {
                Rtc1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - QDEC region configuration." ]
            # [ inline ( always ) ]
            pub fn qdec(&self) -> QdecR {
                QdecR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - LPCOMP region configuration." ]
            # [ inline ( always ) ]
            pub fn lpcomp(&self) -> LpcompR {
                LpcompR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 30 - NVMC region configuration." ]
            # [ inline ( always ) ]
            pub fn nvmc(&self) -> NvmcR {
                NvmcR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 30;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 31 - PPI region configuration." ]
            # [ inline ( always ) ]
            pub fn ppi(&self) -> PpiR {
                PpiR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - POWER_CLOCK region configuration." ]
            # [ inline ( always ) ]
            pub fn power_clock(&mut self) -> _PowerClockW {
                _PowerClockW { w: self }
            }
            # [ doc = "Bit 1 - RADIO region configuration." ]
            # [ inline ( always ) ]
            pub fn radio(&mut self) -> _RadioW {
                _RadioW { w: self }
            }
            # [ doc = "Bit 2 - UART0 region configuration." ]
            # [ inline ( always ) ]
            pub fn uart0(&mut self) -> _Uart0W {
                _Uart0W { w: self }
            }
            # [ doc = "Bit 3 - SPI0 and TWI0 region configuration." ]
            # [ inline ( always ) ]
            pub fn spi0_twi0(&mut self) -> _Spi0Twi0W {
                _Spi0Twi0W { w: self }
            }
            # [ doc = "Bit 4 - SPI1 and TWI1 region configuration." ]
            # [ inline ( always ) ]
            pub fn spi1_twi1(&mut self) -> _Spi1Twi1W {
                _Spi1Twi1W { w: self }
            }
            # [ doc = "Bit 6 - GPIOTE region configuration." ]
            # [ inline ( always ) ]
            pub fn gpiote(&mut self) -> _GpioteW {
                _GpioteW { w: self }
            }
            # [ doc = "Bit 7 - ADC region configuration." ]
            # [ inline ( always ) ]
            pub fn adc(&mut self) -> _AdcW {
                _AdcW { w: self }
            }
            # [ doc = "Bit 8 - TIMER0 region configuration." ]
            # [ inline ( always ) ]
            pub fn timer0(&mut self) -> _Timer0W {
                _Timer0W { w: self }
            }
            # [ doc = "Bit 9 - TIMER1 region configuration." ]
            # [ inline ( always ) ]
            pub fn timer1(&mut self) -> _Timer1W {
                _Timer1W { w: self }
            }
            # [ doc = "Bit 10 - TIMER2 region configuration." ]
            # [ inline ( always ) ]
            pub fn timer2(&mut self) -> _Timer2W {
                _Timer2W { w: self }
            }
            # [ doc = "Bit 11 - RTC0 region configuration." ]
            # [ inline ( always ) ]
            pub fn rtc0(&mut self) -> _Rtc0W {
                _Rtc0W { w: self }
            }
            # [ doc = "Bit 12 - TEMP region configuration." ]
            # [ inline ( always ) ]
            pub fn temp(&mut self) -> _TempW {
                _TempW { w: self }
            }
            # [ doc = "Bit 13 - RNG region configuration." ]
            # [ inline ( always ) ]
            pub fn rng(&mut self) -> _RngW {
                _RngW { w: self }
            }
            # [ doc = "Bit 14 - ECB region configuration." ]
            # [ inline ( always ) ]
            pub fn ecb(&mut self) -> _EcbW {
                _EcbW { w: self }
            }
            # [ doc = "Bit 15 - CCM and AAR region configuration." ]
            # [ inline ( always ) ]
            pub fn ccm_aar(&mut self) -> _CcmAarW {
                _CcmAarW { w: self }
            }
            # [ doc = "Bit 16 - WDT region configuration." ]
            # [ inline ( always ) ]
            pub fn wdt(&mut self) -> _WdtW {
                _WdtW { w: self }
            }
            # [ doc = "Bit 17 - RTC1 region configuration." ]
            # [ inline ( always ) ]
            pub fn rtc1(&mut self) -> _Rtc1W {
                _Rtc1W { w: self }
            }
            # [ doc = "Bit 18 - QDEC region configuration." ]
            # [ inline ( always ) ]
            pub fn qdec(&mut self) -> _QdecW {
                _QdecW { w: self }
            }
            # [ doc = "Bit 19 - LPCOMP region configuration." ]
            # [ inline ( always ) ]
            pub fn lpcomp(&mut self) -> _LpcompW {
                _LpcompW { w: self }
            }
            # [ doc = "Bit 30 - NVMC region configuration." ]
            # [ inline ( always ) ]
            pub fn nvmc(&mut self) -> _NvmcW {
                _NvmcW { w: self }
            }
            # [ doc = "Bit 31 - PPI region configuration." ]
            # [ inline ( always ) ]
            pub fn ppi(&mut self) -> _PpiW {
                _PpiW { w: self }
            }
        }
    }
    # [ doc = "Length of RAM region 0." ]
    pub struct Rlenr0 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Length of RAM region 0." ]
    pub mod rlenr0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Rlenr0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Erase and write protection bit enable set register." ]
    pub struct Protenset0 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Erase and write protection bit enable set register." ]
    pub mod protenset0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Protenset0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `PROTREG0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg0R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg0R::Disabled => 0,
                    Protreg0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg0R {
                match bits {
                    0 => Protreg0R::Disabled,
                    1 => Protreg0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg1R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg1R::Disabled => 0,
                    Protreg1R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg1R {
                match bits {
                    0 => Protreg1R::Disabled,
                    1 => Protreg1R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg1R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg1R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg2R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg2R::Disabled => 0,
                    Protreg2R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg2R {
                match bits {
                    0 => Protreg2R::Disabled,
                    1 => Protreg2R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg2R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg2R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg3R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg3R::Disabled => 0,
                    Protreg3R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg3R {
                match bits {
                    0 => Protreg3R::Disabled,
                    1 => Protreg3R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg3R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg3R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG4`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg4R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg4R::Disabled => 0,
                    Protreg4R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg4R {
                match bits {
                    0 => Protreg4R::Disabled,
                    1 => Protreg4R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg4R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg4R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG5`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg5R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg5R::Disabled => 0,
                    Protreg5R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg5R {
                match bits {
                    0 => Protreg5R::Disabled,
                    1 => Protreg5R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg5R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg5R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG6`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg6R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg6R::Disabled => 0,
                    Protreg6R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg6R {
                match bits {
                    0 => Protreg6R::Disabled,
                    1 => Protreg6R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg6R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg6R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG7`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg7R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg7R::Disabled => 0,
                    Protreg7R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg7R {
                match bits {
                    0 => Protreg7R::Disabled,
                    1 => Protreg7R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg7R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg7R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG8`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg8R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg8R::Disabled => 0,
                    Protreg8R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg8R {
                match bits {
                    0 => Protreg8R::Disabled,
                    1 => Protreg8R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg8R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg8R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG9`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg9R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg9R::Disabled => 0,
                    Protreg9R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg9R {
                match bits {
                    0 => Protreg9R::Disabled,
                    1 => Protreg9R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg9R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg9R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG10`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg10R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg10R::Disabled => 0,
                    Protreg10R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg10R {
                match bits {
                    0 => Protreg10R::Disabled,
                    1 => Protreg10R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg10R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg10R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG11`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg11R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg11R::Disabled => 0,
                    Protreg11R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg11R {
                match bits {
                    0 => Protreg11R::Disabled,
                    1 => Protreg11R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg11R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg11R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG12`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg12R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg12R::Disabled => 0,
                    Protreg12R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg12R {
                match bits {
                    0 => Protreg12R::Disabled,
                    1 => Protreg12R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg12R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg12R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG13`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg13R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg13R::Disabled => 0,
                    Protreg13R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg13R {
                match bits {
                    0 => Protreg13R::Disabled,
                    1 => Protreg13R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg13R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg13R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG14`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg14R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg14R::Disabled => 0,
                    Protreg14R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg14R {
                match bits {
                    0 => Protreg14R::Disabled,
                    1 => Protreg14R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg14R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg14R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG15`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg15R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg15R::Disabled => 0,
                    Protreg15R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg15R {
                match bits {
                    0 => Protreg15R::Disabled,
                    1 => Protreg15R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg15R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg15R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG16`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg16R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg16R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg16R::Disabled => 0,
                    Protreg16R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg16R {
                match bits {
                    0 => Protreg16R::Disabled,
                    1 => Protreg16R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg16R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg16R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG17`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg17R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg17R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg17R::Disabled => 0,
                    Protreg17R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg17R {
                match bits {
                    0 => Protreg17R::Disabled,
                    1 => Protreg17R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg17R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg17R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG18`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg18R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg18R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg18R::Disabled => 0,
                    Protreg18R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg18R {
                match bits {
                    0 => Protreg18R::Disabled,
                    1 => Protreg18R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg18R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg18R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG19`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg19R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg19R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg19R::Disabled => 0,
                    Protreg19R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg19R {
                match bits {
                    0 => Protreg19R::Disabled,
                    1 => Protreg19R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg19R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg19R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG20`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg20R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg20R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg20R::Disabled => 0,
                    Protreg20R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg20R {
                match bits {
                    0 => Protreg20R::Disabled,
                    1 => Protreg20R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg20R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg20R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG21`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg21R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg21R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg21R::Disabled => 0,
                    Protreg21R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg21R {
                match bits {
                    0 => Protreg21R::Disabled,
                    1 => Protreg21R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg21R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg21R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG22`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg22R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg22R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg22R::Disabled => 0,
                    Protreg22R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg22R {
                match bits {
                    0 => Protreg22R::Disabled,
                    1 => Protreg22R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg22R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg22R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG23`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg23R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg23R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg23R::Disabled => 0,
                    Protreg23R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg23R {
                match bits {
                    0 => Protreg23R::Disabled,
                    1 => Protreg23R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg23R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg23R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG24`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg24R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg24R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg24R::Disabled => 0,
                    Protreg24R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg24R {
                match bits {
                    0 => Protreg24R::Disabled,
                    1 => Protreg24R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg24R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg24R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG25`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg25R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg25R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg25R::Disabled => 0,
                    Protreg25R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg25R {
                match bits {
                    0 => Protreg25R::Disabled,
                    1 => Protreg25R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg25R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg25R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG26`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg26R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg26R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg26R::Disabled => 0,
                    Protreg26R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg26R {
                match bits {
                    0 => Protreg26R::Disabled,
                    1 => Protreg26R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg26R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg26R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG27`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg27R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg27R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg27R::Disabled => 0,
                    Protreg27R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg27R {
                match bits {
                    0 => Protreg27R::Disabled,
                    1 => Protreg27R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg27R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg27R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG28`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg28R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg28R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg28R::Disabled => 0,
                    Protreg28R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg28R {
                match bits {
                    0 => Protreg28R::Disabled,
                    1 => Protreg28R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg28R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg28R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG29`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg29R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg29R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg29R::Disabled => 0,
                    Protreg29R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg29R {
                match bits {
                    0 => Protreg29R::Disabled,
                    1 => Protreg29R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg29R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg29R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG30`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg30R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg30R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg30R::Disabled => 0,
                    Protreg30R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg30R {
                match bits {
                    0 => Protreg30R::Disabled,
                    1 => Protreg30R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg30R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg30R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG31`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg31R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg31R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg31R::Disabled => 0,
                    Protreg31R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg31R {
                match bits {
                    0 => Protreg31R::Disabled,
                    1 => Protreg31R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg31R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg31R::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG0`" ]
        pub enum Protreg0W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg0W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG1`" ]
        pub enum Protreg1W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg1W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg1W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG2`" ]
        pub enum Protreg2W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg2W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg2W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG3`" ]
        pub enum Protreg3W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg3W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg3W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG4`" ]
        pub enum Protreg4W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg4W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg4W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg4W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg4W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG5`" ]
        pub enum Protreg5W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg5W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg5W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg5W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg5W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG6`" ]
        pub enum Protreg6W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg6W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg6W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg6W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg6W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG7`" ]
        pub enum Protreg7W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg7W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg7W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg7W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg7W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG8`" ]
        pub enum Protreg8W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg8W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg8W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg8W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg8W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG9`" ]
        pub enum Protreg9W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg9W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg9W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg9W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg9W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG10`" ]
        pub enum Protreg10W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg10W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg10W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg10W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg10W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG11`" ]
        pub enum Protreg11W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg11W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg11W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg11W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg11W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG12`" ]
        pub enum Protreg12W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg12W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg12W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg12W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg12W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG13`" ]
        pub enum Protreg13W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg13W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg13W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg13W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg13W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG14`" ]
        pub enum Protreg14W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg14W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg14W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg14W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg14W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG15`" ]
        pub enum Protreg15W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg15W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg15W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg15W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg15W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG16`" ]
        pub enum Protreg16W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg16W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg16W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg16W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg16W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg16W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG17`" ]
        pub enum Protreg17W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg17W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg17W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg17W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg17W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg17W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG18`" ]
        pub enum Protreg18W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg18W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg18W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg18W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg18W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg18W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG19`" ]
        pub enum Protreg19W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg19W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg19W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg19W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg19W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg19W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG20`" ]
        pub enum Protreg20W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg20W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg20W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg20W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg20W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg20W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG21`" ]
        pub enum Protreg21W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg21W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg21W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg21W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg21W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg21W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG22`" ]
        pub enum Protreg22W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg22W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg22W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg22W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg22W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg22W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG23`" ]
        pub enum Protreg23W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg23W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg23W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg23W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg23W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg23W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG24`" ]
        pub enum Protreg24W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg24W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg24W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg24W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg24W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg24W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG25`" ]
        pub enum Protreg25W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg25W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg25W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg25W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg25W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg25W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG26`" ]
        pub enum Protreg26W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg26W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg26W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg26W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg26W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg26W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG27`" ]
        pub enum Protreg27W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg27W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg27W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg27W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg27W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg27W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG28`" ]
        pub enum Protreg28W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg28W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg28W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg28W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg28W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg28W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG29`" ]
        pub enum Protreg29W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg29W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg29W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg29W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg29W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg29W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG30`" ]
        pub enum Protreg30W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg30W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg30W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg30W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg30W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg30W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG31`" ]
        pub enum Protreg31W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg31W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg31W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg31W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg31W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg31W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Protection enable for region 0." ]
            # [ inline ( always ) ]
            pub fn protreg0(&self) -> Protreg0R {
                Protreg0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Protection enable for region 1." ]
            # [ inline ( always ) ]
            pub fn protreg1(&self) -> Protreg1R {
                Protreg1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Protection enable for region 2." ]
            # [ inline ( always ) ]
            pub fn protreg2(&self) -> Protreg2R {
                Protreg2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Protection enable for region 3." ]
            # [ inline ( always ) ]
            pub fn protreg3(&self) -> Protreg3R {
                Protreg3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Protection enable for region 4." ]
            # [ inline ( always ) ]
            pub fn protreg4(&self) -> Protreg4R {
                Protreg4R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Protection enable for region 5." ]
            # [ inline ( always ) ]
            pub fn protreg5(&self) -> Protreg5R {
                Protreg5R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Protection enable for region 6." ]
            # [ inline ( always ) ]
            pub fn protreg6(&self) -> Protreg6R {
                Protreg6R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Protection enable for region 7." ]
            # [ inline ( always ) ]
            pub fn protreg7(&self) -> Protreg7R {
                Protreg7R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Protection enable for region 8." ]
            # [ inline ( always ) ]
            pub fn protreg8(&self) -> Protreg8R {
                Protreg8R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Protection enable for region 9." ]
            # [ inline ( always ) ]
            pub fn protreg9(&self) -> Protreg9R {
                Protreg9R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Protection enable for region 10." ]
            # [ inline ( always ) ]
            pub fn protreg10(&self) -> Protreg10R {
                Protreg10R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 11 - Protection enable for region 11." ]
            # [ inline ( always ) ]
            pub fn protreg11(&self) -> Protreg11R {
                Protreg11R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 12 - Protection enable for region 12." ]
            # [ inline ( always ) ]
            pub fn protreg12(&self) -> Protreg12R {
                Protreg12R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 13 - Protection enable for region 13." ]
            # [ inline ( always ) ]
            pub fn protreg13(&self) -> Protreg13R {
                Protreg13R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 13;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 14 - Protection enable for region 14." ]
            # [ inline ( always ) ]
            pub fn protreg14(&self) -> Protreg14R {
                Protreg14R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 15 - Protection enable for region 15." ]
            # [ inline ( always ) ]
            pub fn protreg15(&self) -> Protreg15R {
                Protreg15R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 15;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - Protection enable for region 16." ]
            # [ inline ( always ) ]
            pub fn protreg16(&self) -> Protreg16R {
                Protreg16R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Protection enable for region 17." ]
            # [ inline ( always ) ]
            pub fn protreg17(&self) -> Protreg17R {
                Protreg17R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Protection enable for region 18." ]
            # [ inline ( always ) ]
            pub fn protreg18(&self) -> Protreg18R {
                Protreg18R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Protection enable for region 19." ]
            # [ inline ( always ) ]
            pub fn protreg19(&self) -> Protreg19R {
                Protreg19R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 20 - Protection enable for region 20." ]
            # [ inline ( always ) ]
            pub fn protreg20(&self) -> Protreg20R {
                Protreg20R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 20;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 21 - Protection enable for region 21." ]
            # [ inline ( always ) ]
            pub fn protreg21(&self) -> Protreg21R {
                Protreg21R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 21;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 22 - Protection enable for region 22." ]
            # [ inline ( always ) ]
            pub fn protreg22(&self) -> Protreg22R {
                Protreg22R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 22;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 23 - Protection enable for region 23." ]
            # [ inline ( always ) ]
            pub fn protreg23(&self) -> Protreg23R {
                Protreg23R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 23;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 24 - Protection enable for region 24." ]
            # [ inline ( always ) ]
            pub fn protreg24(&self) -> Protreg24R {
                Protreg24R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 24;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 25 - Protection enable for region 25." ]
            # [ inline ( always ) ]
            pub fn protreg25(&self) -> Protreg25R {
                Protreg25R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 25;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 26 - Protection enable for region 26." ]
            # [ inline ( always ) ]
            pub fn protreg26(&self) -> Protreg26R {
                Protreg26R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 26;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 27 - Protection enable for region 27." ]
            # [ inline ( always ) ]
            pub fn protreg27(&self) -> Protreg27R {
                Protreg27R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 27;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 28 - Protection enable for region 28." ]
            # [ inline ( always ) ]
            pub fn protreg28(&self) -> Protreg28R {
                Protreg28R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 28;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 29 - Protection enable for region 29." ]
            # [ inline ( always ) ]
            pub fn protreg29(&self) -> Protreg29R {
                Protreg29R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 29;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 30 - Protection enable for region 30." ]
            # [ inline ( always ) ]
            pub fn protreg30(&self) -> Protreg30R {
                Protreg30R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 30;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 31 - Protection enable for region 31." ]
            # [ inline ( always ) ]
            pub fn protreg31(&self) -> Protreg31R {
                Protreg31R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Protection enable for region 0." ]
            # [ inline ( always ) ]
            pub fn protreg0(&mut self) -> _Protreg0W {
                _Protreg0W { w: self }
            }
            # [ doc = "Bit 1 - Protection enable for region 1." ]
            # [ inline ( always ) ]
            pub fn protreg1(&mut self) -> _Protreg1W {
                _Protreg1W { w: self }
            }
            # [ doc = "Bit 2 - Protection enable for region 2." ]
            # [ inline ( always ) ]
            pub fn protreg2(&mut self) -> _Protreg2W {
                _Protreg2W { w: self }
            }
            # [ doc = "Bit 3 - Protection enable for region 3." ]
            # [ inline ( always ) ]
            pub fn protreg3(&mut self) -> _Protreg3W {
                _Protreg3W { w: self }
            }
            # [ doc = "Bit 4 - Protection enable for region 4." ]
            # [ inline ( always ) ]
            pub fn protreg4(&mut self) -> _Protreg4W {
                _Protreg4W { w: self }
            }
            # [ doc = "Bit 5 - Protection enable for region 5." ]
            # [ inline ( always ) ]
            pub fn protreg5(&mut self) -> _Protreg5W {
                _Protreg5W { w: self }
            }
            # [ doc = "Bit 6 - Protection enable for region 6." ]
            # [ inline ( always ) ]
            pub fn protreg6(&mut self) -> _Protreg6W {
                _Protreg6W { w: self }
            }
            # [ doc = "Bit 7 - Protection enable for region 7." ]
            # [ inline ( always ) ]
            pub fn protreg7(&mut self) -> _Protreg7W {
                _Protreg7W { w: self }
            }
            # [ doc = "Bit 8 - Protection enable for region 8." ]
            # [ inline ( always ) ]
            pub fn protreg8(&mut self) -> _Protreg8W {
                _Protreg8W { w: self }
            }
            # [ doc = "Bit 9 - Protection enable for region 9." ]
            # [ inline ( always ) ]
            pub fn protreg9(&mut self) -> _Protreg9W {
                _Protreg9W { w: self }
            }
            # [ doc = "Bit 10 - Protection enable for region 10." ]
            # [ inline ( always ) ]
            pub fn protreg10(&mut self) -> _Protreg10W {
                _Protreg10W { w: self }
            }
            # [ doc = "Bit 11 - Protection enable for region 11." ]
            # [ inline ( always ) ]
            pub fn protreg11(&mut self) -> _Protreg11W {
                _Protreg11W { w: self }
            }
            # [ doc = "Bit 12 - Protection enable for region 12." ]
            # [ inline ( always ) ]
            pub fn protreg12(&mut self) -> _Protreg12W {
                _Protreg12W { w: self }
            }
            # [ doc = "Bit 13 - Protection enable for region 13." ]
            # [ inline ( always ) ]
            pub fn protreg13(&mut self) -> _Protreg13W {
                _Protreg13W { w: self }
            }
            # [ doc = "Bit 14 - Protection enable for region 14." ]
            # [ inline ( always ) ]
            pub fn protreg14(&mut self) -> _Protreg14W {
                _Protreg14W { w: self }
            }
            # [ doc = "Bit 15 - Protection enable for region 15." ]
            # [ inline ( always ) ]
            pub fn protreg15(&mut self) -> _Protreg15W {
                _Protreg15W { w: self }
            }
            # [ doc = "Bit 16 - Protection enable for region 16." ]
            # [ inline ( always ) ]
            pub fn protreg16(&mut self) -> _Protreg16W {
                _Protreg16W { w: self }
            }
            # [ doc = "Bit 17 - Protection enable for region 17." ]
            # [ inline ( always ) ]
            pub fn protreg17(&mut self) -> _Protreg17W {
                _Protreg17W { w: self }
            }
            # [ doc = "Bit 18 - Protection enable for region 18." ]
            # [ inline ( always ) ]
            pub fn protreg18(&mut self) -> _Protreg18W {
                _Protreg18W { w: self }
            }
            # [ doc = "Bit 19 - Protection enable for region 19." ]
            # [ inline ( always ) ]
            pub fn protreg19(&mut self) -> _Protreg19W {
                _Protreg19W { w: self }
            }
            # [ doc = "Bit 20 - Protection enable for region 20." ]
            # [ inline ( always ) ]
            pub fn protreg20(&mut self) -> _Protreg20W {
                _Protreg20W { w: self }
            }
            # [ doc = "Bit 21 - Protection enable for region 21." ]
            # [ inline ( always ) ]
            pub fn protreg21(&mut self) -> _Protreg21W {
                _Protreg21W { w: self }
            }
            # [ doc = "Bit 22 - Protection enable for region 22." ]
            # [ inline ( always ) ]
            pub fn protreg22(&mut self) -> _Protreg22W {
                _Protreg22W { w: self }
            }
            # [ doc = "Bit 23 - Protection enable for region 23." ]
            # [ inline ( always ) ]
            pub fn protreg23(&mut self) -> _Protreg23W {
                _Protreg23W { w: self }
            }
            # [ doc = "Bit 24 - Protection enable for region 24." ]
            # [ inline ( always ) ]
            pub fn protreg24(&mut self) -> _Protreg24W {
                _Protreg24W { w: self }
            }
            # [ doc = "Bit 25 - Protection enable for region 25." ]
            # [ inline ( always ) ]
            pub fn protreg25(&mut self) -> _Protreg25W {
                _Protreg25W { w: self }
            }
            # [ doc = "Bit 26 - Protection enable for region 26." ]
            # [ inline ( always ) ]
            pub fn protreg26(&mut self) -> _Protreg26W {
                _Protreg26W { w: self }
            }
            # [ doc = "Bit 27 - Protection enable for region 27." ]
            # [ inline ( always ) ]
            pub fn protreg27(&mut self) -> _Protreg27W {
                _Protreg27W { w: self }
            }
            # [ doc = "Bit 28 - Protection enable for region 28." ]
            # [ inline ( always ) ]
            pub fn protreg28(&mut self) -> _Protreg28W {
                _Protreg28W { w: self }
            }
            # [ doc = "Bit 29 - Protection enable for region 29." ]
            # [ inline ( always ) ]
            pub fn protreg29(&mut self) -> _Protreg29W {
                _Protreg29W { w: self }
            }
            # [ doc = "Bit 30 - Protection enable for region 30." ]
            # [ inline ( always ) ]
            pub fn protreg30(&mut self) -> _Protreg30W {
                _Protreg30W { w: self }
            }
            # [ doc = "Bit 31 - Protection enable for region 31." ]
            # [ inline ( always ) ]
            pub fn protreg31(&mut self) -> _Protreg31W {
                _Protreg31W { w: self }
            }
        }
    }
    # [ doc = "Erase and write protection bit enable set register." ]
    pub struct Protenset1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Erase and write protection bit enable set register." ]
    pub mod protenset1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Protenset1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `PROTREG32`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg32R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg32R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg32R::Disabled => 0,
                    Protreg32R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg32R {
                match bits {
                    0 => Protreg32R::Disabled,
                    1 => Protreg32R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg32R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg32R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG33`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg33R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg33R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg33R::Disabled => 0,
                    Protreg33R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg33R {
                match bits {
                    0 => Protreg33R::Disabled,
                    1 => Protreg33R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg33R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg33R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG34`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg34R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg34R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg34R::Disabled => 0,
                    Protreg34R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg34R {
                match bits {
                    0 => Protreg34R::Disabled,
                    1 => Protreg34R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg34R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg34R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG35`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg35R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg35R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg35R::Disabled => 0,
                    Protreg35R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg35R {
                match bits {
                    0 => Protreg35R::Disabled,
                    1 => Protreg35R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg35R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg35R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG36`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg36R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg36R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg36R::Disabled => 0,
                    Protreg36R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg36R {
                match bits {
                    0 => Protreg36R::Disabled,
                    1 => Protreg36R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg36R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg36R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG37`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg37R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg37R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg37R::Disabled => 0,
                    Protreg37R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg37R {
                match bits {
                    0 => Protreg37R::Disabled,
                    1 => Protreg37R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg37R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg37R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG38`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg38R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg38R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg38R::Disabled => 0,
                    Protreg38R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg38R {
                match bits {
                    0 => Protreg38R::Disabled,
                    1 => Protreg38R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg38R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg38R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG39`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg39R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg39R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg39R::Disabled => 0,
                    Protreg39R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg39R {
                match bits {
                    0 => Protreg39R::Disabled,
                    1 => Protreg39R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg39R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg39R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG40`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg40R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg40R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg40R::Disabled => 0,
                    Protreg40R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg40R {
                match bits {
                    0 => Protreg40R::Disabled,
                    1 => Protreg40R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg40R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg40R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG41`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg41R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg41R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg41R::Disabled => 0,
                    Protreg41R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg41R {
                match bits {
                    0 => Protreg41R::Disabled,
                    1 => Protreg41R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg41R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg41R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG42`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg42R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg42R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg42R::Disabled => 0,
                    Protreg42R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg42R {
                match bits {
                    0 => Protreg42R::Disabled,
                    1 => Protreg42R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg42R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg42R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG43`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg43R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg43R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg43R::Disabled => 0,
                    Protreg43R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg43R {
                match bits {
                    0 => Protreg43R::Disabled,
                    1 => Protreg43R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg43R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg43R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG44`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg44R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg44R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg44R::Disabled => 0,
                    Protreg44R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg44R {
                match bits {
                    0 => Protreg44R::Disabled,
                    1 => Protreg44R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg44R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg44R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG45`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg45R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg45R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg45R::Disabled => 0,
                    Protreg45R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg45R {
                match bits {
                    0 => Protreg45R::Disabled,
                    1 => Protreg45R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg45R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg45R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG46`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg46R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg46R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg46R::Disabled => 0,
                    Protreg46R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg46R {
                match bits {
                    0 => Protreg46R::Disabled,
                    1 => Protreg46R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg46R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg46R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG47`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg47R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg47R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg47R::Disabled => 0,
                    Protreg47R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg47R {
                match bits {
                    0 => Protreg47R::Disabled,
                    1 => Protreg47R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg47R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg47R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG48`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg48R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg48R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg48R::Disabled => 0,
                    Protreg48R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg48R {
                match bits {
                    0 => Protreg48R::Disabled,
                    1 => Protreg48R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg48R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg48R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG49`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg49R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg49R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg49R::Disabled => 0,
                    Protreg49R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg49R {
                match bits {
                    0 => Protreg49R::Disabled,
                    1 => Protreg49R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg49R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg49R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG50`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg50R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg50R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg50R::Disabled => 0,
                    Protreg50R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg50R {
                match bits {
                    0 => Protreg50R::Disabled,
                    1 => Protreg50R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg50R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg50R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG51`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg51R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg51R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg51R::Disabled => 0,
                    Protreg51R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg51R {
                match bits {
                    0 => Protreg51R::Disabled,
                    1 => Protreg51R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg51R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg51R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG52`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg52R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg52R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg52R::Disabled => 0,
                    Protreg52R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg52R {
                match bits {
                    0 => Protreg52R::Disabled,
                    1 => Protreg52R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg52R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg52R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG53`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg53R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg53R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg53R::Disabled => 0,
                    Protreg53R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg53R {
                match bits {
                    0 => Protreg53R::Disabled,
                    1 => Protreg53R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg53R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg53R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG54`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg54R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg54R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg54R::Disabled => 0,
                    Protreg54R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg54R {
                match bits {
                    0 => Protreg54R::Disabled,
                    1 => Protreg54R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg54R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg54R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG55`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg55R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg55R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg55R::Disabled => 0,
                    Protreg55R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg55R {
                match bits {
                    0 => Protreg55R::Disabled,
                    1 => Protreg55R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg55R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg55R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG56`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg56R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg56R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg56R::Disabled => 0,
                    Protreg56R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg56R {
                match bits {
                    0 => Protreg56R::Disabled,
                    1 => Protreg56R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg56R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg56R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG57`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg57R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg57R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg57R::Disabled => 0,
                    Protreg57R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg57R {
                match bits {
                    0 => Protreg57R::Disabled,
                    1 => Protreg57R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg57R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg57R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG58`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg58R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg58R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg58R::Disabled => 0,
                    Protreg58R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg58R {
                match bits {
                    0 => Protreg58R::Disabled,
                    1 => Protreg58R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg58R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg58R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG59`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg59R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg59R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg59R::Disabled => 0,
                    Protreg59R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg59R {
                match bits {
                    0 => Protreg59R::Disabled,
                    1 => Protreg59R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg59R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg59R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG60`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg60R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg60R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg60R::Disabled => 0,
                    Protreg60R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg60R {
                match bits {
                    0 => Protreg60R::Disabled,
                    1 => Protreg60R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg60R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg60R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG61`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg61R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg61R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg61R::Disabled => 0,
                    Protreg61R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg61R {
                match bits {
                    0 => Protreg61R::Disabled,
                    1 => Protreg61R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg61R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg61R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG62`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg62R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg62R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg62R::Disabled => 0,
                    Protreg62R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg62R {
                match bits {
                    0 => Protreg62R::Disabled,
                    1 => Protreg62R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg62R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg62R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PROTREG63`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Protreg63R {
            # [ doc = "Protection disabled." ]
            Disabled,
            # [ doc = "Protection enabled." ]
            Enabled,
        }
        impl Protreg63R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Protreg63R::Disabled => 0,
                    Protreg63R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Protreg63R {
                match bits {
                    0 => Protreg63R::Disabled,
                    1 => Protreg63R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Protreg63R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Protreg63R::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG32`" ]
        pub enum Protreg32W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg32W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg32W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg32W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg32W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg32W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg32W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG33`" ]
        pub enum Protreg33W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg33W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg33W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg33W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg33W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg33W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg33W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG34`" ]
        pub enum Protreg34W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg34W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg34W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg34W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg34W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg34W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg34W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG35`" ]
        pub enum Protreg35W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg35W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg35W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg35W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg35W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg35W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg35W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG36`" ]
        pub enum Protreg36W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg36W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg36W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg36W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg36W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg36W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg36W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG37`" ]
        pub enum Protreg37W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg37W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg37W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg37W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg37W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg37W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg37W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG38`" ]
        pub enum Protreg38W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg38W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg38W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg38W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg38W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg38W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg38W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG39`" ]
        pub enum Protreg39W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg39W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg39W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg39W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg39W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg39W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg39W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG40`" ]
        pub enum Protreg40W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg40W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg40W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg40W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg40W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg40W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg40W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG41`" ]
        pub enum Protreg41W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg41W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg41W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg41W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg41W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg41W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg41W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG42`" ]
        pub enum Protreg42W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg42W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg42W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg42W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg42W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg42W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg42W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG43`" ]
        pub enum Protreg43W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg43W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg43W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg43W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg43W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg43W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg43W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG44`" ]
        pub enum Protreg44W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg44W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg44W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg44W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg44W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg44W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg44W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG45`" ]
        pub enum Protreg45W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg45W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg45W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg45W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg45W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg45W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg45W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG46`" ]
        pub enum Protreg46W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg46W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg46W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg46W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg46W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg46W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg46W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG47`" ]
        pub enum Protreg47W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg47W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg47W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg47W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg47W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg47W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg47W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG48`" ]
        pub enum Protreg48W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg48W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg48W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg48W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg48W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg48W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg48W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG49`" ]
        pub enum Protreg49W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg49W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg49W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg49W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg49W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg49W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg49W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG50`" ]
        pub enum Protreg50W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg50W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg50W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg50W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg50W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg50W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg50W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG51`" ]
        pub enum Protreg51W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg51W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg51W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg51W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg51W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg51W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg51W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG52`" ]
        pub enum Protreg52W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg52W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg52W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg52W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg52W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg52W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg52W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG53`" ]
        pub enum Protreg53W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg53W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg53W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg53W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg53W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg53W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg53W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG54`" ]
        pub enum Protreg54W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg54W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg54W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg54W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg54W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg54W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg54W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG55`" ]
        pub enum Protreg55W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg55W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg55W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg55W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg55W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg55W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg55W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG56`" ]
        pub enum Protreg56W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg56W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg56W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg56W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg56W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg56W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg56W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG57`" ]
        pub enum Protreg57W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg57W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg57W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg57W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg57W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg57W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg57W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG58`" ]
        pub enum Protreg58W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg58W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg58W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg58W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg58W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg58W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg58W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG59`" ]
        pub enum Protreg59W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg59W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg59W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg59W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg59W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg59W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg59W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG60`" ]
        pub enum Protreg60W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg60W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg60W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg60W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg60W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg60W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg60W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG61`" ]
        pub enum Protreg61W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg61W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg61W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg61W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg61W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg61W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg61W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG62`" ]
        pub enum Protreg62W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg62W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg62W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg62W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg62W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg62W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg62W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PROTREG63`" ]
        pub enum Protreg63W {
            # [ doc = "Enable protection on write." ]
            Set,
        }
        impl Protreg63W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Protreg63W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Protreg63W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Protreg63W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Protreg63W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable protection on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Protreg63W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Protection enable for region 32." ]
            # [ inline ( always ) ]
            pub fn protreg32(&self) -> Protreg32R {
                Protreg32R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Protection enable for region 33." ]
            # [ inline ( always ) ]
            pub fn protreg33(&self) -> Protreg33R {
                Protreg33R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Protection enable for region 34." ]
            # [ inline ( always ) ]
            pub fn protreg34(&self) -> Protreg34R {
                Protreg34R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Protection enable for region 35." ]
            # [ inline ( always ) ]
            pub fn protreg35(&self) -> Protreg35R {
                Protreg35R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Protection enable for region 36." ]
            # [ inline ( always ) ]
            pub fn protreg36(&self) -> Protreg36R {
                Protreg36R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Protection enable for region 37." ]
            # [ inline ( always ) ]
            pub fn protreg37(&self) -> Protreg37R {
                Protreg37R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Protection enable for region 38." ]
            # [ inline ( always ) ]
            pub fn protreg38(&self) -> Protreg38R {
                Protreg38R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Protection enable for region 39." ]
            # [ inline ( always ) ]
            pub fn protreg39(&self) -> Protreg39R {
                Protreg39R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Protection enable for region 40." ]
            # [ inline ( always ) ]
            pub fn protreg40(&self) -> Protreg40R {
                Protreg40R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Protection enable for region 41." ]
            # [ inline ( always ) ]
            pub fn protreg41(&self) -> Protreg41R {
                Protreg41R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Protection enable for region 42." ]
            # [ inline ( always ) ]
            pub fn protreg42(&self) -> Protreg42R {
                Protreg42R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 11 - Protection enable for region 43." ]
            # [ inline ( always ) ]
            pub fn protreg43(&self) -> Protreg43R {
                Protreg43R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 12 - Protection enable for region 44." ]
            # [ inline ( always ) ]
            pub fn protreg44(&self) -> Protreg44R {
                Protreg44R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 13 - Protection enable for region 45." ]
            # [ inline ( always ) ]
            pub fn protreg45(&self) -> Protreg45R {
                Protreg45R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 13;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 14 - Protection enable for region 46." ]
            # [ inline ( always ) ]
            pub fn protreg46(&self) -> Protreg46R {
                Protreg46R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 15 - Protection enable for region 47." ]
            # [ inline ( always ) ]
            pub fn protreg47(&self) -> Protreg47R {
                Protreg47R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 15;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - Protection enable for region 48." ]
            # [ inline ( always ) ]
            pub fn protreg48(&self) -> Protreg48R {
                Protreg48R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Protection enable for region 49." ]
            # [ inline ( always ) ]
            pub fn protreg49(&self) -> Protreg49R {
                Protreg49R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Protection enable for region 50." ]
            # [ inline ( always ) ]
            pub fn protreg50(&self) -> Protreg50R {
                Protreg50R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Protection enable for region 51." ]
            # [ inline ( always ) ]
            pub fn protreg51(&self) -> Protreg51R {
                Protreg51R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 20 - Protection enable for region 52." ]
            # [ inline ( always ) ]
            pub fn protreg52(&self) -> Protreg52R {
                Protreg52R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 20;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 21 - Protection enable for region 53." ]
            # [ inline ( always ) ]
            pub fn protreg53(&self) -> Protreg53R {
                Protreg53R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 21;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 22 - Protection enable for region 54." ]
            # [ inline ( always ) ]
            pub fn protreg54(&self) -> Protreg54R {
                Protreg54R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 22;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 23 - Protection enable for region 55." ]
            # [ inline ( always ) ]
            pub fn protreg55(&self) -> Protreg55R {
                Protreg55R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 23;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 24 - Protection enable for region 56." ]
            # [ inline ( always ) ]
            pub fn protreg56(&self) -> Protreg56R {
                Protreg56R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 24;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 25 - Protection enable for region 57." ]
            # [ inline ( always ) ]
            pub fn protreg57(&self) -> Protreg57R {
                Protreg57R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 25;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 26 - Protection enable for region 58." ]
            # [ inline ( always ) ]
            pub fn protreg58(&self) -> Protreg58R {
                Protreg58R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 26;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 27 - Protection enable for region 59." ]
            # [ inline ( always ) ]
            pub fn protreg59(&self) -> Protreg59R {
                Protreg59R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 27;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 28 - Protection enable for region 60." ]
            # [ inline ( always ) ]
            pub fn protreg60(&self) -> Protreg60R {
                Protreg60R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 28;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 29 - Protection enable for region 61." ]
            # [ inline ( always ) ]
            pub fn protreg61(&self) -> Protreg61R {
                Protreg61R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 29;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 30 - Protection enable for region 62." ]
            # [ inline ( always ) ]
            pub fn protreg62(&self) -> Protreg62R {
                Protreg62R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 30;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 31 - Protection enable for region 63." ]
            # [ inline ( always ) ]
            pub fn protreg63(&self) -> Protreg63R {
                Protreg63R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Protection enable for region 32." ]
            # [ inline ( always ) ]
            pub fn protreg32(&mut self) -> _Protreg32W {
                _Protreg32W { w: self }
            }
            # [ doc = "Bit 1 - Protection enable for region 33." ]
            # [ inline ( always ) ]
            pub fn protreg33(&mut self) -> _Protreg33W {
                _Protreg33W { w: self }
            }
            # [ doc = "Bit 2 - Protection enable for region 34." ]
            # [ inline ( always ) ]
            pub fn protreg34(&mut self) -> _Protreg34W {
                _Protreg34W { w: self }
            }
            # [ doc = "Bit 3 - Protection enable for region 35." ]
            # [ inline ( always ) ]
            pub fn protreg35(&mut self) -> _Protreg35W {
                _Protreg35W { w: self }
            }
            # [ doc = "Bit 4 - Protection enable for region 36." ]
            # [ inline ( always ) ]
            pub fn protreg36(&mut self) -> _Protreg36W {
                _Protreg36W { w: self }
            }
            # [ doc = "Bit 5 - Protection enable for region 37." ]
            # [ inline ( always ) ]
            pub fn protreg37(&mut self) -> _Protreg37W {
                _Protreg37W { w: self }
            }
            # [ doc = "Bit 6 - Protection enable for region 38." ]
            # [ inline ( always ) ]
            pub fn protreg38(&mut self) -> _Protreg38W {
                _Protreg38W { w: self }
            }
            # [ doc = "Bit 7 - Protection enable for region 39." ]
            # [ inline ( always ) ]
            pub fn protreg39(&mut self) -> _Protreg39W {
                _Protreg39W { w: self }
            }
            # [ doc = "Bit 8 - Protection enable for region 40." ]
            # [ inline ( always ) ]
            pub fn protreg40(&mut self) -> _Protreg40W {
                _Protreg40W { w: self }
            }
            # [ doc = "Bit 9 - Protection enable for region 41." ]
            # [ inline ( always ) ]
            pub fn protreg41(&mut self) -> _Protreg41W {
                _Protreg41W { w: self }
            }
            # [ doc = "Bit 10 - Protection enable for region 42." ]
            # [ inline ( always ) ]
            pub fn protreg42(&mut self) -> _Protreg42W {
                _Protreg42W { w: self }
            }
            # [ doc = "Bit 11 - Protection enable for region 43." ]
            # [ inline ( always ) ]
            pub fn protreg43(&mut self) -> _Protreg43W {
                _Protreg43W { w: self }
            }
            # [ doc = "Bit 12 - Protection enable for region 44." ]
            # [ inline ( always ) ]
            pub fn protreg44(&mut self) -> _Protreg44W {
                _Protreg44W { w: self }
            }
            # [ doc = "Bit 13 - Protection enable for region 45." ]
            # [ inline ( always ) ]
            pub fn protreg45(&mut self) -> _Protreg45W {
                _Protreg45W { w: self }
            }
            # [ doc = "Bit 14 - Protection enable for region 46." ]
            # [ inline ( always ) ]
            pub fn protreg46(&mut self) -> _Protreg46W {
                _Protreg46W { w: self }
            }
            # [ doc = "Bit 15 - Protection enable for region 47." ]
            # [ inline ( always ) ]
            pub fn protreg47(&mut self) -> _Protreg47W {
                _Protreg47W { w: self }
            }
            # [ doc = "Bit 16 - Protection enable for region 48." ]
            # [ inline ( always ) ]
            pub fn protreg48(&mut self) -> _Protreg48W {
                _Protreg48W { w: self }
            }
            # [ doc = "Bit 17 - Protection enable for region 49." ]
            # [ inline ( always ) ]
            pub fn protreg49(&mut self) -> _Protreg49W {
                _Protreg49W { w: self }
            }
            # [ doc = "Bit 18 - Protection enable for region 50." ]
            # [ inline ( always ) ]
            pub fn protreg50(&mut self) -> _Protreg50W {
                _Protreg50W { w: self }
            }
            # [ doc = "Bit 19 - Protection enable for region 51." ]
            # [ inline ( always ) ]
            pub fn protreg51(&mut self) -> _Protreg51W {
                _Protreg51W { w: self }
            }
            # [ doc = "Bit 20 - Protection enable for region 52." ]
            # [ inline ( always ) ]
            pub fn protreg52(&mut self) -> _Protreg52W {
                _Protreg52W { w: self }
            }
            # [ doc = "Bit 21 - Protection enable for region 53." ]
            # [ inline ( always ) ]
            pub fn protreg53(&mut self) -> _Protreg53W {
                _Protreg53W { w: self }
            }
            # [ doc = "Bit 22 - Protection enable for region 54." ]
            # [ inline ( always ) ]
            pub fn protreg54(&mut self) -> _Protreg54W {
                _Protreg54W { w: self }
            }
            # [ doc = "Bit 23 - Protection enable for region 55." ]
            # [ inline ( always ) ]
            pub fn protreg55(&mut self) -> _Protreg55W {
                _Protreg55W { w: self }
            }
            # [ doc = "Bit 24 - Protection enable for region 56." ]
            # [ inline ( always ) ]
            pub fn protreg56(&mut self) -> _Protreg56W {
                _Protreg56W { w: self }
            }
            # [ doc = "Bit 25 - Protection enable for region 57." ]
            # [ inline ( always ) ]
            pub fn protreg57(&mut self) -> _Protreg57W {
                _Protreg57W { w: self }
            }
            # [ doc = "Bit 26 - Protection enable for region 58." ]
            # [ inline ( always ) ]
            pub fn protreg58(&mut self) -> _Protreg58W {
                _Protreg58W { w: self }
            }
            # [ doc = "Bit 27 - Protection enable for region 59." ]
            # [ inline ( always ) ]
            pub fn protreg59(&mut self) -> _Protreg59W {
                _Protreg59W { w: self }
            }
            # [ doc = "Bit 28 - Protection enable for region 60." ]
            # [ inline ( always ) ]
            pub fn protreg60(&mut self) -> _Protreg60W {
                _Protreg60W { w: self }
            }
            # [ doc = "Bit 29 - Protection enable for region 61." ]
            # [ inline ( always ) ]
            pub fn protreg61(&mut self) -> _Protreg61W {
                _Protreg61W { w: self }
            }
            # [ doc = "Bit 30 - Protection enable for region 62." ]
            # [ inline ( always ) ]
            pub fn protreg62(&mut self) -> _Protreg62W {
                _Protreg62W { w: self }
            }
            # [ doc = "Bit 31 - Protection enable for region 63." ]
            # [ inline ( always ) ]
            pub fn protreg63(&mut self) -> _Protreg63W {
                _Protreg63W { w: self }
            }
        }
    }
    # [ doc = "Disable erase and write protection mechanism in debug mode." ]
    pub struct Disableindebug {
        register: VolatileCell<u32>,
    }
    # [ doc = "Disable erase and write protection mechanism in debug mode." ]
    pub mod disableindebug {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Disableindebug {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `DISABLEINDEBUG`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DisableindebugR {
            # [ doc = "Protection enabled." ]
            Enabled,
            # [ doc = "Protection disabled." ]
            Disabled,
        }
        impl DisableindebugR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DisableindebugR::Enabled => 0,
                    DisableindebugR::Disabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DisableindebugR {
                match bits {
                    0 => DisableindebugR::Enabled,
                    1 => DisableindebugR::Disabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DisableindebugR::Enabled
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DisableindebugR::Disabled
            }
        }
        # [ doc = "Values that can be written to the field `DISABLEINDEBUG`" ]
        pub enum DisableindebugW {
            # [ doc = "Protection enabled." ]
            Enabled,
            # [ doc = "Protection disabled." ]
            Disabled,
        }
        impl DisableindebugW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DisableindebugW::Enabled => 0,
                    DisableindebugW::Disabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DisableindebugW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DisableindebugW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DisableindebugW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Protection enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DisableindebugW::Enabled)
            }
            # [ doc = "Protection disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DisableindebugW::Disabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable protection mechanism in debug mode." ]
            # [ inline ( always ) ]
            pub fn disableindebug(&self) -> DisableindebugR {
                DisableindebugR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 1 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable protection mechanism in debug mode." ]
            # [ inline ( always ) ]
            pub fn disableindebug(&mut self) -> _DisableindebugW {
                _DisableindebugW { w: self }
            }
        }
    }
    # [ doc = "Erase and write protection block size." ]
    pub struct Protblocksize {
        register: VolatileCell<u32>,
    }
    # [ doc = "Erase and write protection block size." ]
    pub mod protblocksize {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Protblocksize {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `PROTBLOCKSIZE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ProtblocksizeR {
            # [ doc = "Erase and write protection block size is 4k." ]
            _4k,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl ProtblocksizeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ProtblocksizeR::_4k => 0,
                    ProtblocksizeR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ProtblocksizeR {
                match bits {
                    0 => ProtblocksizeR::_4k,
                    i => ProtblocksizeR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `_4k`" ]
            # [ inline ( always ) ]
            pub fn is_4k(&self) -> bool {
                *self == ProtblocksizeR::_4k
            }
        }
        # [ doc = "Values that can be written to the field `PROTBLOCKSIZE`" ]
        pub enum ProtblocksizeW {
            # [ doc = "Erase and write protection block size is 4k." ]
            _4k,
        }
        impl ProtblocksizeW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ProtblocksizeW::_4k => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ProtblocksizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ProtblocksizeW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ProtblocksizeW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Erase and write protection block size is 4k." ]
            # [ inline ( always ) ]
            pub fn _4k(self) -> &'a mut W {
                self.variant(ProtblocksizeW::_4k)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - Erase and write protection block size." ]
            # [ inline ( always ) ]
            pub fn protblocksize(&self) -> ProtblocksizeR {
                ProtblocksizeR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - Erase and write protection block size." ]
            # [ inline ( always ) ]
            pub fn protblocksize(&mut self) -> _ProtblocksizeW {
                _ProtblocksizeW { w: self }
            }
        }
    }
}
# [ doc = "Memory Protection Unit." ]
pub struct Mpu {
    register_block: mpu::RegisterBlock,
}
impl Deref for Mpu {
    type Target = mpu::RegisterBlock;
    fn deref(&self) -> &mpu::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "The radio." ]
pub const RADIO: Peripheral<Radio> = unsafe { Peripheral::new(1073745920) };
# [ doc = "The radio." ]
pub mod radio {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Enable radio in TX mode." ]
        pub tasks_txen: TasksTxen,
        # [ doc = "0x04 - Enable radio in RX mode." ]
        pub tasks_rxen: TasksRxen,
        # [ doc = "0x08 - Start radio." ]
        pub tasks_start: TasksStart,
        # [ doc = "0x0c - Stop radio." ]
        pub tasks_stop: TasksStop,
        # [ doc = "0x10 - Disable radio." ]
        pub tasks_disable: TasksDisable,
        # [ doc = "0x14 - Start the RSSI and take one sample of the receive signal strength." ]
        pub tasks_rssistart: TasksRssistart,
        # [ doc = "0x18 - Stop the RSSI measurement." ]
        pub tasks_rssistop: TasksRssistop,
        # [ doc = "0x1c - Start the bit counter." ]
        pub tasks_bcstart: TasksBcstart,
        # [ doc = "0x20 - Stop the bit counter." ]
        pub tasks_bcstop: TasksBcstop,
        _reserved0: [u8; 220usize],
        # [ doc = "0x100 - Ready event." ]
        pub events_ready: EventsReady,
        # [ doc = "0x104 - Address event." ]
        pub events_address: EventsAddress,
        # [ doc = "0x108 - Payload event." ]
        pub events_payload: EventsPayload,
        # [ doc = "0x10c - End event." ]
        pub events_end: EventsEnd,
        # [ doc = "0x110 - Disable event." ]
        pub events_disabled: EventsDisabled,
        # [ doc = "0x114 - A device address match occurred on the last received packet." ]
        pub events_devmatch: EventsDevmatch,
        # [ doc = "0x118 - No device address match occurred on the last received packet." ]
        pub events_devmiss: EventsDevmiss,
        # [ doc = "0x11c - Sampling of the receive signal strength complete. A new RSSI sample is ready for readout at the RSSISAMPLE register." ]
        pub events_rssiend: EventsRssiend,
        _reserved1: [u8; 8usize],
        # [ doc = "0x128 - Bit counter reached bit count value specified in BCC register." ]
        pub events_bcmatch: EventsBcmatch,
        _reserved2: [u8; 212usize],
        # [ doc = "0x200 - Shortcuts for the radio." ]
        pub shorts: Shorts,
        _reserved3: [u8; 256usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved4: [u8; 244usize],
        # [ doc = "0x400 - CRC status of received packet." ]
        pub crcstatus: Crcstatus,
        _reserved5: [u8; 4usize],
        # [ doc = "0x408 - Received address." ]
        pub rxmatch: Rxmatch,
        # [ doc = "0x40c - Received CRC." ]
        pub rxcrc: Rxcrc,
        # [ doc = "0x410 - Device address match index." ]
        pub dai: Dai,
        _reserved6: [u8; 240usize],
        # [ doc = "0x504 - Packet pointer. Decision point: START task." ]
        pub packetptr: Packetptr,
        # [ doc = "0x508 - Frequency." ]
        pub frequency: Frequency,
        # [ doc = "0x50c - Output power." ]
        pub txpower: Txpower,
        # [ doc = "0x510 - Data rate and modulation." ]
        pub mode: Mode,
        # [ doc = "0x514 - Packet configuration 0." ]
        pub pcnf0: Pcnf0,
        # [ doc = "0x518 - Packet configuration 1." ]
        pub pcnf1: Pcnf1,
        # [ doc = "0x51c - Radio base address 0. Decision point: START task." ]
        pub base0: Base0,
        # [ doc = "0x520 - Radio base address 1. Decision point: START task." ]
        pub base1: Base1,
        # [ doc = "0x524 - Prefixes bytes for logical addresses 0 to 3." ]
        pub prefix0: Prefix0,
        # [ doc = "0x528 - Prefixes bytes for logical addresses 4 to 7." ]
        pub prefix1: Prefix1,
        # [ doc = "0x52c - Transmit address select." ]
        pub txaddress: Txaddress,
        # [ doc = "0x530 - Receive address select." ]
        pub rxaddresses: Rxaddresses,
        # [ doc = "0x534 - CRC configuration." ]
        pub crccnf: Crccnf,
        # [ doc = "0x538 - CRC polynomial." ]
        pub crcpoly: Crcpoly,
        # [ doc = "0x53c - CRC initial value." ]
        pub crcinit: Crcinit,
        # [ doc = "0x540 - Test features enable register." ]
        pub test: Test,
        # [ doc = "0x544 - Inter Frame Spacing in microseconds." ]
        pub tifs: Tifs,
        # [ doc = "0x548 - RSSI sample." ]
        pub rssisample: Rssisample,
        _reserved7: [u8; 4usize],
        # [ doc = "0x550 - Current radio state." ]
        pub state: State,
        # [ doc = "0x554 - Data whitening initial value." ]
        pub datawhiteiv: Datawhiteiv,
        _reserved8: [u8; 8usize],
        # [ doc = "0x560 - Bit counter compare." ]
        pub bcc: Bcc,
        _reserved9: [u8; 156usize],
        # [ doc = "0x600 - Device address base segment." ]
        pub dab0: Dab,
        # [ doc = "0x604 - Device address base segment." ]
        pub dab1: Dab,
        # [ doc = "0x608 - Device address base segment." ]
        pub dab2: Dab,
        # [ doc = "0x60c - Device address base segment." ]
        pub dab3: Dab,
        # [ doc = "0x610 - Device address base segment." ]
        pub dab4: Dab,
        # [ doc = "0x614 - Device address base segment." ]
        pub dab5: Dab,
        # [ doc = "0x618 - Device address base segment." ]
        pub dab6: Dab,
        # [ doc = "0x61c - Device address base segment." ]
        pub dab7: Dab,
        # [ doc = "0x620 - Device address prefix." ]
        pub dap0: Dap,
        # [ doc = "0x624 - Device address prefix." ]
        pub dap1: Dap,
        # [ doc = "0x628 - Device address prefix." ]
        pub dap2: Dap,
        # [ doc = "0x62c - Device address prefix." ]
        pub dap3: Dap,
        # [ doc = "0x630 - Device address prefix." ]
        pub dap4: Dap,
        # [ doc = "0x634 - Device address prefix." ]
        pub dap5: Dap,
        # [ doc = "0x638 - Device address prefix." ]
        pub dap6: Dap,
        # [ doc = "0x63c - Device address prefix." ]
        pub dap7: Dap,
        # [ doc = "0x640 - Device address match configuration." ]
        pub dacnf: Dacnf,
        _reserved10: [u8; 224usize],
        # [ doc = "0x724 - Trim value override register 0." ]
        pub override0: Override0,
        # [ doc = "0x728 - Trim value override register 1." ]
        pub override1: Override1,
        # [ doc = "0x72c - Trim value override register 2." ]
        pub override2: Override2,
        # [ doc = "0x730 - Trim value override register 3." ]
        pub override3: Override3,
        # [ doc = "0x734 - Trim value override register 4." ]
        pub override4: Override4,
        _reserved11: [u8; 2244usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Enable radio in TX mode." ]
    pub struct TasksTxen {
        register: VolatileCell<u32>,
    }
    # [ doc = "Enable radio in TX mode." ]
    pub mod tasks_txen {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksTxen {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Enable radio in RX mode." ]
    pub struct TasksRxen {
        register: VolatileCell<u32>,
    }
    # [ doc = "Enable radio in RX mode." ]
    pub mod tasks_rxen {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksRxen {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Start radio." ]
    pub struct TasksStart {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start radio." ]
    pub mod tasks_start {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStart {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop radio." ]
    pub struct TasksStop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop radio." ]
    pub mod tasks_stop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Disable radio." ]
    pub struct TasksDisable {
        register: VolatileCell<u32>,
    }
    # [ doc = "Disable radio." ]
    pub mod tasks_disable {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksDisable {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Start the RSSI and take one sample of the receive signal strength." ]
    pub struct TasksRssistart {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start the RSSI and take one sample of the receive signal strength." ]
    pub mod tasks_rssistart {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksRssistart {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop the RSSI measurement." ]
    pub struct TasksRssistop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop the RSSI measurement." ]
    pub mod tasks_rssistop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksRssistop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Start the bit counter." ]
    pub struct TasksBcstart {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start the bit counter." ]
    pub mod tasks_bcstart {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksBcstart {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop the bit counter." ]
    pub struct TasksBcstop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop the bit counter." ]
    pub mod tasks_bcstop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksBcstop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Ready event." ]
    pub struct EventsReady {
        register: VolatileCell<u32>,
    }
    # [ doc = "Ready event." ]
    pub mod events_ready {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsReady {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Address event." ]
    pub struct EventsAddress {
        register: VolatileCell<u32>,
    }
    # [ doc = "Address event." ]
    pub mod events_address {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsAddress {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Payload event." ]
    pub struct EventsPayload {
        register: VolatileCell<u32>,
    }
    # [ doc = "Payload event." ]
    pub mod events_payload {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsPayload {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "End event." ]
    pub struct EventsEnd {
        register: VolatileCell<u32>,
    }
    # [ doc = "End event." ]
    pub mod events_end {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsEnd {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Disable event." ]
    pub struct EventsDisabled {
        register: VolatileCell<u32>,
    }
    # [ doc = "Disable event." ]
    pub mod events_disabled {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsDisabled {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "A device address match occurred on the last received packet." ]
    pub struct EventsDevmatch {
        register: VolatileCell<u32>,
    }
    # [ doc = "A device address match occurred on the last received packet." ]
    pub mod events_devmatch {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsDevmatch {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "No device address match occurred on the last received packet." ]
    pub struct EventsDevmiss {
        register: VolatileCell<u32>,
    }
    # [ doc = "No device address match occurred on the last received packet." ]
    pub mod events_devmiss {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsDevmiss {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Sampling of the receive signal strength complete. A new RSSI sample is ready for readout at the RSSISAMPLE register." ]
    pub struct EventsRssiend {
        register: VolatileCell<u32>,
    }
    # [ doc = "Sampling of the receive signal strength complete. A new RSSI sample is ready for readout at the RSSISAMPLE register." ]
    pub mod events_rssiend {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsRssiend {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Bit counter reached bit count value specified in BCC register." ]
    pub struct EventsBcmatch {
        register: VolatileCell<u32>,
    }
    # [ doc = "Bit counter reached bit count value specified in BCC register." ]
    pub mod events_bcmatch {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsBcmatch {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Shortcuts for the radio." ]
    pub struct Shorts {
        register: VolatileCell<u32>,
    }
    # [ doc = "Shortcuts for the radio." ]
    pub mod shorts {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Shorts {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `READY_START`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ReadyStartR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl ReadyStartR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ReadyStartR::Disabled => 0,
                    ReadyStartR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ReadyStartR {
                match bits {
                    0 => ReadyStartR::Disabled,
                    1 => ReadyStartR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ReadyStartR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ReadyStartR::Enabled
            }
        }
        # [ doc = "Possible values of the field `END_DISABLE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndDisableR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl EndDisableR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndDisableR::Disabled => 0,
                    EndDisableR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndDisableR {
                match bits {
                    0 => EndDisableR::Disabled,
                    1 => EndDisableR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndDisableR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndDisableR::Enabled
            }
        }
        # [ doc = "Possible values of the field `DISABLED_TXEN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DisabledTxenR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl DisabledTxenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DisabledTxenR::Disabled => 0,
                    DisabledTxenR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DisabledTxenR {
                match bits {
                    0 => DisabledTxenR::Disabled,
                    1 => DisabledTxenR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DisabledTxenR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DisabledTxenR::Enabled
            }
        }
        # [ doc = "Possible values of the field `DISABLED_RXEN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DisabledRxenR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl DisabledRxenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DisabledRxenR::Disabled => 0,
                    DisabledRxenR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DisabledRxenR {
                match bits {
                    0 => DisabledRxenR::Disabled,
                    1 => DisabledRxenR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DisabledRxenR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DisabledRxenR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ADDRESS_RSSISTART`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum AddressRssistartR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl AddressRssistartR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    AddressRssistartR::Disabled => 0,
                    AddressRssistartR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> AddressRssistartR {
                match bits {
                    0 => AddressRssistartR::Disabled,
                    1 => AddressRssistartR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == AddressRssistartR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == AddressRssistartR::Enabled
            }
        }
        # [ doc = "Possible values of the field `END_START`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndStartR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl EndStartR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndStartR::Disabled => 0,
                    EndStartR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndStartR {
                match bits {
                    0 => EndStartR::Disabled,
                    1 => EndStartR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndStartR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndStartR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ADDRESS_BCSTART`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum AddressBcstartR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl AddressBcstartR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    AddressBcstartR::Disabled => 0,
                    AddressBcstartR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> AddressBcstartR {
                match bits {
                    0 => AddressBcstartR::Disabled,
                    1 => AddressBcstartR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == AddressBcstartR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == AddressBcstartR::Enabled
            }
        }
        # [ doc = "Possible values of the field `DISABLED_RSSISTOP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DisabledRssistopR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl DisabledRssistopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DisabledRssistopR::Disabled => 0,
                    DisabledRssistopR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DisabledRssistopR {
                match bits {
                    0 => DisabledRssistopR::Disabled,
                    1 => DisabledRssistopR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DisabledRssistopR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DisabledRssistopR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `READY_START`" ]
        pub enum ReadyStartW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl ReadyStartW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ReadyStartW::Disabled => 0,
                    ReadyStartW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReadyStartW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReadyStartW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ReadyStartW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ReadyStartW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ReadyStartW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `END_DISABLE`" ]
        pub enum EndDisableW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl EndDisableW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndDisableW::Disabled => 0,
                    EndDisableW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndDisableW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndDisableW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndDisableW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EndDisableW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EndDisableW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DISABLED_TXEN`" ]
        pub enum DisabledTxenW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl DisabledTxenW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DisabledTxenW::Disabled => 0,
                    DisabledTxenW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DisabledTxenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DisabledTxenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DisabledTxenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DisabledTxenW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DisabledTxenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DISABLED_RXEN`" ]
        pub enum DisabledRxenW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl DisabledRxenW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DisabledRxenW::Disabled => 0,
                    DisabledRxenW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DisabledRxenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DisabledRxenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DisabledRxenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DisabledRxenW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DisabledRxenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADDRESS_RSSISTART`" ]
        pub enum AddressRssistartW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl AddressRssistartW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AddressRssistartW::Disabled => 0,
                    AddressRssistartW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddressRssistartW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddressRssistartW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: AddressRssistartW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AddressRssistartW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AddressRssistartW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `END_START`" ]
        pub enum EndStartW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl EndStartW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndStartW::Disabled => 0,
                    EndStartW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndStartW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndStartW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndStartW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EndStartW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EndStartW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADDRESS_BCSTART`" ]
        pub enum AddressBcstartW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl AddressBcstartW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AddressBcstartW::Disabled => 0,
                    AddressBcstartW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddressBcstartW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddressBcstartW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: AddressBcstartW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AddressBcstartW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AddressBcstartW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DISABLED_RSSISTOP`" ]
        pub enum DisabledRssistopW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl DisabledRssistopW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DisabledRssistopW::Disabled => 0,
                    DisabledRssistopW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DisabledRssistopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DisabledRssistopW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DisabledRssistopW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DisabledRssistopW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DisabledRssistopW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Shortcut between READY event and START task." ]
            # [ inline ( always ) ]
            pub fn ready_start(&self) -> ReadyStartR {
                ReadyStartR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Shortcut between END event and DISABLE task." ]
            # [ inline ( always ) ]
            pub fn end_disable(&self) -> EndDisableR {
                EndDisableR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Shortcut between DISABLED event and TXEN task." ]
            # [ inline ( always ) ]
            pub fn disabled_txen(&self) -> DisabledTxenR {
                DisabledTxenR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Shortcut between DISABLED event and RXEN task." ]
            # [ inline ( always ) ]
            pub fn disabled_rxen(&self) -> DisabledRxenR {
                DisabledRxenR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Shortcut between ADDRESS event and RSSISTART task." ]
            # [ inline ( always ) ]
            pub fn address_rssistart(&self) -> AddressRssistartR {
                AddressRssistartR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Shortcut between END event and START task." ]
            # [ inline ( always ) ]
            pub fn end_start(&self) -> EndStartR {
                EndStartR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Shortcut between ADDRESS event and BCSTART task." ]
            # [ inline ( always ) ]
            pub fn address_bcstart(&self) -> AddressBcstartR {
                AddressBcstartR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Shortcut between DISABLED event and RSSISTOP task." ]
            # [ inline ( always ) ]
            pub fn disabled_rssistop(&self) -> DisabledRssistopR {
                DisabledRssistopR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Shortcut between READY event and START task." ]
            # [ inline ( always ) ]
            pub fn ready_start(&mut self) -> _ReadyStartW {
                _ReadyStartW { w: self }
            }
            # [ doc = "Bit 1 - Shortcut between END event and DISABLE task." ]
            # [ inline ( always ) ]
            pub fn end_disable(&mut self) -> _EndDisableW {
                _EndDisableW { w: self }
            }
            # [ doc = "Bit 2 - Shortcut between DISABLED event and TXEN task." ]
            # [ inline ( always ) ]
            pub fn disabled_txen(&mut self) -> _DisabledTxenW {
                _DisabledTxenW { w: self }
            }
            # [ doc = "Bit 3 - Shortcut between DISABLED event and RXEN task." ]
            # [ inline ( always ) ]
            pub fn disabled_rxen(&mut self) -> _DisabledRxenW {
                _DisabledRxenW { w: self }
            }
            # [ doc = "Bit 4 - Shortcut between ADDRESS event and RSSISTART task." ]
            # [ inline ( always ) ]
            pub fn address_rssistart(&mut self) -> _AddressRssistartW {
                _AddressRssistartW { w: self }
            }
            # [ doc = "Bit 5 - Shortcut between END event and START task." ]
            # [ inline ( always ) ]
            pub fn end_start(&mut self) -> _EndStartW {
                _EndStartW { w: self }
            }
            # [ doc = "Bit 6 - Shortcut between ADDRESS event and BCSTART task." ]
            # [ inline ( always ) ]
            pub fn address_bcstart(&mut self) -> _AddressBcstartW {
                _AddressBcstartW { w: self }
            }
            # [ doc = "Bit 8 - Shortcut between DISABLED event and RSSISTOP task." ]
            # [ inline ( always ) ]
            pub fn disabled_rssistop(&mut self) -> _DisabledRssistopW {
                _DisabledRssistopW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `READY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ReadyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ReadyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ReadyR::Disabled => 0,
                    ReadyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ReadyR {
                match bits {
                    0 => ReadyR::Disabled,
                    1 => ReadyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ReadyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ReadyR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ADDRESS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum AddressR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl AddressR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    AddressR::Disabled => 0,
                    AddressR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> AddressR {
                match bits {
                    0 => AddressR::Disabled,
                    1 => AddressR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == AddressR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == AddressR::Enabled
            }
        }
        # [ doc = "Possible values of the field `PAYLOAD`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PayloadR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl PayloadR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PayloadR::Disabled => 0,
                    PayloadR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PayloadR {
                match bits {
                    0 => PayloadR::Disabled,
                    1 => PayloadR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PayloadR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PayloadR::Enabled
            }
        }
        # [ doc = "Possible values of the field `END`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndR::Disabled => 0,
                    EndR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndR {
                match bits {
                    0 => EndR::Disabled,
                    1 => EndR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndR::Enabled
            }
        }
        # [ doc = "Possible values of the field `DISABLED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DisabledR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl DisabledR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DisabledR::Disabled => 0,
                    DisabledR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DisabledR {
                match bits {
                    0 => DisabledR::Disabled,
                    1 => DisabledR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DisabledR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DisabledR::Enabled
            }
        }
        # [ doc = "Possible values of the field `DEVMATCH`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DevmatchR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl DevmatchR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DevmatchR::Disabled => 0,
                    DevmatchR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DevmatchR {
                match bits {
                    0 => DevmatchR::Disabled,
                    1 => DevmatchR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DevmatchR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DevmatchR::Enabled
            }
        }
        # [ doc = "Possible values of the field `DEVMISS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DevmissR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl DevmissR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DevmissR::Disabled => 0,
                    DevmissR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DevmissR {
                match bits {
                    0 => DevmissR::Disabled,
                    1 => DevmissR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DevmissR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DevmissR::Enabled
            }
        }
        # [ doc = "Possible values of the field `RSSIEND`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RssiendR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl RssiendR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RssiendR::Disabled => 0,
                    RssiendR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RssiendR {
                match bits {
                    0 => RssiendR::Disabled,
                    1 => RssiendR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == RssiendR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == RssiendR::Enabled
            }
        }
        # [ doc = "Possible values of the field `BCMATCH`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum BcmatchR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl BcmatchR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    BcmatchR::Disabled => 0,
                    BcmatchR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> BcmatchR {
                match bits {
                    0 => BcmatchR::Disabled,
                    1 => BcmatchR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == BcmatchR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == BcmatchR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `READY`" ]
        pub enum ReadyW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl ReadyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ReadyW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReadyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReadyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ReadyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(ReadyW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADDRESS`" ]
        pub enum AddressW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl AddressW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AddressW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddressW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddressW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: AddressW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(AddressW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PAYLOAD`" ]
        pub enum PayloadW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl PayloadW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PayloadW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PayloadW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PayloadW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PayloadW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(PayloadW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `END`" ]
        pub enum EndW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl EndW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(EndW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DISABLED`" ]
        pub enum DisabledW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl DisabledW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DisabledW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DisabledW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DisabledW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DisabledW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(DisabledW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DEVMATCH`" ]
        pub enum DevmatchW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl DevmatchW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DevmatchW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DevmatchW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DevmatchW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DevmatchW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(DevmatchW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DEVMISS`" ]
        pub enum DevmissW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl DevmissW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DevmissW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DevmissW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DevmissW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DevmissW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(DevmissW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RSSIEND`" ]
        pub enum RssiendW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl RssiendW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RssiendW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RssiendW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RssiendW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RssiendW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(RssiendW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BCMATCH`" ]
        pub enum BcmatchW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl BcmatchW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BcmatchW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BcmatchW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BcmatchW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: BcmatchW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(BcmatchW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable interrupt on READY event." ]
            # [ inline ( always ) ]
            pub fn ready(&self) -> ReadyR {
                ReadyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Enable interrupt on ADDRESS event." ]
            # [ inline ( always ) ]
            pub fn address(&self) -> AddressR {
                AddressR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Enable interrupt on PAYLOAD event." ]
            # [ inline ( always ) ]
            pub fn payload(&self) -> PayloadR {
                PayloadR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Enable interrupt on END event." ]
            # [ inline ( always ) ]
            pub fn end(&self) -> EndR {
                EndR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Enable interrupt on DISABLED event." ]
            # [ inline ( always ) ]
            pub fn disabled(&self) -> DisabledR {
                DisabledR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Enable interrupt on DEVMATCH event." ]
            # [ inline ( always ) ]
            pub fn devmatch(&self) -> DevmatchR {
                DevmatchR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Enable interrupt on DEVMISS event." ]
            # [ inline ( always ) ]
            pub fn devmiss(&self) -> DevmissR {
                DevmissR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Enable interrupt on RSSIEND event." ]
            # [ inline ( always ) ]
            pub fn rssiend(&self) -> RssiendR {
                RssiendR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Enable interrupt on BCMATCH event." ]
            # [ inline ( always ) ]
            pub fn bcmatch(&self) -> BcmatchR {
                BcmatchR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable interrupt on READY event." ]
            # [ inline ( always ) ]
            pub fn ready(&mut self) -> _ReadyW {
                _ReadyW { w: self }
            }
            # [ doc = "Bit 1 - Enable interrupt on ADDRESS event." ]
            # [ inline ( always ) ]
            pub fn address(&mut self) -> _AddressW {
                _AddressW { w: self }
            }
            # [ doc = "Bit 2 - Enable interrupt on PAYLOAD event." ]
            # [ inline ( always ) ]
            pub fn payload(&mut self) -> _PayloadW {
                _PayloadW { w: self }
            }
            # [ doc = "Bit 3 - Enable interrupt on END event." ]
            # [ inline ( always ) ]
            pub fn end(&mut self) -> _EndW {
                _EndW { w: self }
            }
            # [ doc = "Bit 4 - Enable interrupt on DISABLED event." ]
            # [ inline ( always ) ]
            pub fn disabled(&mut self) -> _DisabledW {
                _DisabledW { w: self }
            }
            # [ doc = "Bit 5 - Enable interrupt on DEVMATCH event." ]
            # [ inline ( always ) ]
            pub fn devmatch(&mut self) -> _DevmatchW {
                _DevmatchW { w: self }
            }
            # [ doc = "Bit 6 - Enable interrupt on DEVMISS event." ]
            # [ inline ( always ) ]
            pub fn devmiss(&mut self) -> _DevmissW {
                _DevmissW { w: self }
            }
            # [ doc = "Bit 7 - Enable interrupt on RSSIEND event." ]
            # [ inline ( always ) ]
            pub fn rssiend(&mut self) -> _RssiendW {
                _RssiendW { w: self }
            }
            # [ doc = "Bit 10 - Enable interrupt on BCMATCH event." ]
            # [ inline ( always ) ]
            pub fn bcmatch(&mut self) -> _BcmatchW {
                _BcmatchW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `READY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ReadyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ReadyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ReadyR::Disabled => 0,
                    ReadyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ReadyR {
                match bits {
                    0 => ReadyR::Disabled,
                    1 => ReadyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ReadyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ReadyR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ADDRESS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum AddressR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl AddressR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    AddressR::Disabled => 0,
                    AddressR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> AddressR {
                match bits {
                    0 => AddressR::Disabled,
                    1 => AddressR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == AddressR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == AddressR::Enabled
            }
        }
        # [ doc = "Possible values of the field `PAYLOAD`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PayloadR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl PayloadR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PayloadR::Disabled => 0,
                    PayloadR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PayloadR {
                match bits {
                    0 => PayloadR::Disabled,
                    1 => PayloadR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PayloadR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PayloadR::Enabled
            }
        }
        # [ doc = "Possible values of the field `END`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndR::Disabled => 0,
                    EndR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndR {
                match bits {
                    0 => EndR::Disabled,
                    1 => EndR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndR::Enabled
            }
        }
        # [ doc = "Possible values of the field `DISABLED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DisabledR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl DisabledR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DisabledR::Disabled => 0,
                    DisabledR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DisabledR {
                match bits {
                    0 => DisabledR::Disabled,
                    1 => DisabledR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DisabledR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DisabledR::Enabled
            }
        }
        # [ doc = "Possible values of the field `DEVMATCH`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DevmatchR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl DevmatchR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DevmatchR::Disabled => 0,
                    DevmatchR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DevmatchR {
                match bits {
                    0 => DevmatchR::Disabled,
                    1 => DevmatchR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DevmatchR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DevmatchR::Enabled
            }
        }
        # [ doc = "Possible values of the field `DEVMISS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DevmissR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl DevmissR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DevmissR::Disabled => 0,
                    DevmissR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DevmissR {
                match bits {
                    0 => DevmissR::Disabled,
                    1 => DevmissR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DevmissR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DevmissR::Enabled
            }
        }
        # [ doc = "Possible values of the field `RSSIEND`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RssiendR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl RssiendR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RssiendR::Disabled => 0,
                    RssiendR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RssiendR {
                match bits {
                    0 => RssiendR::Disabled,
                    1 => RssiendR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == RssiendR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == RssiendR::Enabled
            }
        }
        # [ doc = "Possible values of the field `BCMATCH`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum BcmatchR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl BcmatchR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    BcmatchR::Disabled => 0,
                    BcmatchR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> BcmatchR {
                match bits {
                    0 => BcmatchR::Disabled,
                    1 => BcmatchR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == BcmatchR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == BcmatchR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `READY`" ]
        pub enum ReadyW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl ReadyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ReadyW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReadyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReadyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ReadyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(ReadyW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADDRESS`" ]
        pub enum AddressW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl AddressW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AddressW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddressW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddressW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: AddressW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(AddressW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PAYLOAD`" ]
        pub enum PayloadW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl PayloadW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PayloadW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PayloadW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PayloadW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PayloadW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(PayloadW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `END`" ]
        pub enum EndW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl EndW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(EndW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DISABLED`" ]
        pub enum DisabledW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl DisabledW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DisabledW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DisabledW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DisabledW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DisabledW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(DisabledW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DEVMATCH`" ]
        pub enum DevmatchW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl DevmatchW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DevmatchW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DevmatchW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DevmatchW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DevmatchW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(DevmatchW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DEVMISS`" ]
        pub enum DevmissW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl DevmissW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DevmissW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DevmissW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DevmissW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DevmissW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(DevmissW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RSSIEND`" ]
        pub enum RssiendW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl RssiendW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RssiendW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RssiendW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RssiendW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RssiendW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(RssiendW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BCMATCH`" ]
        pub enum BcmatchW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl BcmatchW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BcmatchW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BcmatchW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BcmatchW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: BcmatchW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(BcmatchW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable interrupt on READY event." ]
            # [ inline ( always ) ]
            pub fn ready(&self) -> ReadyR {
                ReadyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Disable interrupt on ADDRESS event." ]
            # [ inline ( always ) ]
            pub fn address(&self) -> AddressR {
                AddressR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Disable interrupt on PAYLOAD event." ]
            # [ inline ( always ) ]
            pub fn payload(&self) -> PayloadR {
                PayloadR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Disable interrupt on END event." ]
            # [ inline ( always ) ]
            pub fn end(&self) -> EndR {
                EndR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Disable interrupt on DISABLED event." ]
            # [ inline ( always ) ]
            pub fn disabled(&self) -> DisabledR {
                DisabledR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Disable interrupt on DEVMATCH event." ]
            # [ inline ( always ) ]
            pub fn devmatch(&self) -> DevmatchR {
                DevmatchR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Disable interrupt on DEVMISS event." ]
            # [ inline ( always ) ]
            pub fn devmiss(&self) -> DevmissR {
                DevmissR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Disable interrupt on RSSIEND event." ]
            # [ inline ( always ) ]
            pub fn rssiend(&self) -> RssiendR {
                RssiendR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Disable interrupt on BCMATCH event." ]
            # [ inline ( always ) ]
            pub fn bcmatch(&self) -> BcmatchR {
                BcmatchR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable interrupt on READY event." ]
            # [ inline ( always ) ]
            pub fn ready(&mut self) -> _ReadyW {
                _ReadyW { w: self }
            }
            # [ doc = "Bit 1 - Disable interrupt on ADDRESS event." ]
            # [ inline ( always ) ]
            pub fn address(&mut self) -> _AddressW {
                _AddressW { w: self }
            }
            # [ doc = "Bit 2 - Disable interrupt on PAYLOAD event." ]
            # [ inline ( always ) ]
            pub fn payload(&mut self) -> _PayloadW {
                _PayloadW { w: self }
            }
            # [ doc = "Bit 3 - Disable interrupt on END event." ]
            # [ inline ( always ) ]
            pub fn end(&mut self) -> _EndW {
                _EndW { w: self }
            }
            # [ doc = "Bit 4 - Disable interrupt on DISABLED event." ]
            # [ inline ( always ) ]
            pub fn disabled(&mut self) -> _DisabledW {
                _DisabledW { w: self }
            }
            # [ doc = "Bit 5 - Disable interrupt on DEVMATCH event." ]
            # [ inline ( always ) ]
            pub fn devmatch(&mut self) -> _DevmatchW {
                _DevmatchW { w: self }
            }
            # [ doc = "Bit 6 - Disable interrupt on DEVMISS event." ]
            # [ inline ( always ) ]
            pub fn devmiss(&mut self) -> _DevmissW {
                _DevmissW { w: self }
            }
            # [ doc = "Bit 7 - Disable interrupt on RSSIEND event." ]
            # [ inline ( always ) ]
            pub fn rssiend(&mut self) -> _RssiendW {
                _RssiendW { w: self }
            }
            # [ doc = "Bit 10 - Disable interrupt on BCMATCH event." ]
            # [ inline ( always ) ]
            pub fn bcmatch(&mut self) -> _BcmatchW {
                _BcmatchW { w: self }
            }
        }
    }
    # [ doc = "CRC status of received packet." ]
    pub struct Crcstatus {
        register: VolatileCell<u32>,
    }
    # [ doc = "CRC status of received packet." ]
    pub mod crcstatus {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Crcstatus {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = "Possible values of the field `CRCSTATUS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CrcstatusR {
            # [ doc = "Packet received with CRC error." ]
            Crcerror,
            # [ doc = "Packet received with CRC ok." ]
            Crcok,
        }
        impl CrcstatusR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CrcstatusR::Crcerror => 0,
                    CrcstatusR::Crcok => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CrcstatusR {
                match bits {
                    0 => CrcstatusR::Crcerror,
                    1 => CrcstatusR::Crcok,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Crcerror`" ]
            # [ inline ( always ) ]
            pub fn is_crcerror(&self) -> bool {
                *self == CrcstatusR::Crcerror
            }
            # [ doc = "Checks if the value of the field is `Crcok`" ]
            # [ inline ( always ) ]
            pub fn is_crcok(&self) -> bool {
                *self == CrcstatusR::Crcok
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - CRC status of received packet." ]
            # [ inline ( always ) ]
            pub fn crcstatus(&self) -> CrcstatusR {
                CrcstatusR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
    }
    # [ doc = "Received address." ]
    pub struct Rxmatch {
        register: VolatileCell<u32>,
    }
    # [ doc = "Received address." ]
    pub mod rxmatch {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Rxmatch {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxmatchR {
            bits: u8,
        }
        impl RxmatchR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:2 - Logical address in which previous packet was received." ]
            # [ inline ( always ) ]
            pub fn rxmatch(&self) -> RxmatchR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxmatchR { bits }
            }
        }
    }
    # [ doc = "Received CRC." ]
    pub struct Rxcrc {
        register: VolatileCell<u32>,
    }
    # [ doc = "Received CRC." ]
    pub mod rxcrc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Rxcrc {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxcrcR {
            bits: u32,
        }
        impl RxcrcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:23 - CRC field of previously received packet." ]
            # [ inline ( always ) ]
            pub fn rxcrc(&self) -> RxcrcR {
                let bits = {
                    const MASK: u32 = 16777215;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                RxcrcR { bits }
            }
        }
    }
    # [ doc = "Device address match index." ]
    pub struct Dai {
        register: VolatileCell<u32>,
    }
    # [ doc = "Device address match index." ]
    pub mod dai {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Dai {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DaiR {
            bits: u8,
        }
        impl DaiR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:2 - Index (n) of device address (see DAB[n] and DAP[n]) that obtained an address match." ]
            # [ inline ( always ) ]
            pub fn dai(&self) -> DaiR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DaiR { bits }
            }
        }
    }
    # [ doc = "Packet pointer. Decision point: START task." ]
    pub struct Packetptr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Packet pointer. Decision point: START task." ]
    pub mod packetptr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Packetptr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Frequency." ]
    pub struct Frequency {
        register: VolatileCell<u32>,
    }
    # [ doc = "Frequency." ]
    pub mod frequency {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Frequency {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct FrequencyR {
            bits: u8,
        }
        impl FrequencyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FrequencyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FrequencyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:6 - Radio channel frequency offset in MHz: RF Frequency = 2400 + FREQUENCY (MHz). Decision point: TXEN or RXEN task." ]
            # [ inline ( always ) ]
            pub fn frequency(&self) -> FrequencyR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FrequencyR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 2 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:6 - Radio channel frequency offset in MHz: RF Frequency = 2400 + FREQUENCY (MHz). Decision point: TXEN or RXEN task." ]
            # [ inline ( always ) ]
            pub fn frequency(&mut self) -> _FrequencyW {
                _FrequencyW { w: self }
            }
        }
    }
    # [ doc = "Output power." ]
    pub struct Txpower {
        register: VolatileCell<u32>,
    }
    # [ doc = "Output power." ]
    pub mod txpower {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Txpower {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `TXPOWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TxpowerR {
            # [ doc = "+4dBm." ]
            Pos4dBm,
            # [ doc = "0dBm." ]
            _0dBm,
            # [ doc = "-4dBm." ]
            Neg4dBm,
            # [ doc = "-8dBm." ]
            Neg8dBm,
            # [ doc = "-12dBm." ]
            Neg12dBm,
            # [ doc = "-16dBm." ]
            Neg16dBm,
            # [ doc = "-20dBm." ]
            Neg20dBm,
            # [ doc = "-30dBm." ]
            Neg30dBm,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl TxpowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TxpowerR::Pos4dBm => 4,
                    TxpowerR::_0dBm => 0,
                    TxpowerR::Neg4dBm => 252,
                    TxpowerR::Neg8dBm => 248,
                    TxpowerR::Neg12dBm => 244,
                    TxpowerR::Neg16dBm => 240,
                    TxpowerR::Neg20dBm => 236,
                    TxpowerR::Neg30dBm => 216,
                    TxpowerR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TxpowerR {
                match bits {
                    4 => TxpowerR::Pos4dBm,
                    0 => TxpowerR::_0dBm,
                    252 => TxpowerR::Neg4dBm,
                    248 => TxpowerR::Neg8dBm,
                    244 => TxpowerR::Neg12dBm,
                    240 => TxpowerR::Neg16dBm,
                    236 => TxpowerR::Neg20dBm,
                    216 => TxpowerR::Neg30dBm,
                    i => TxpowerR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Pos4dBm`" ]
            # [ inline ( always ) ]
            pub fn is_pos4d_bm(&self) -> bool {
                *self == TxpowerR::Pos4dBm
            }
            # [ doc = "Checks if the value of the field is `_0dBm`" ]
            # [ inline ( always ) ]
            pub fn is_0d_bm(&self) -> bool {
                *self == TxpowerR::_0dBm
            }
            # [ doc = "Checks if the value of the field is `Neg4dBm`" ]
            # [ inline ( always ) ]
            pub fn is_neg4d_bm(&self) -> bool {
                *self == TxpowerR::Neg4dBm
            }
            # [ doc = "Checks if the value of the field is `Neg8dBm`" ]
            # [ inline ( always ) ]
            pub fn is_neg8d_bm(&self) -> bool {
                *self == TxpowerR::Neg8dBm
            }
            # [ doc = "Checks if the value of the field is `Neg12dBm`" ]
            # [ inline ( always ) ]
            pub fn is_neg12d_bm(&self) -> bool {
                *self == TxpowerR::Neg12dBm
            }
            # [ doc = "Checks if the value of the field is `Neg16dBm`" ]
            # [ inline ( always ) ]
            pub fn is_neg16d_bm(&self) -> bool {
                *self == TxpowerR::Neg16dBm
            }
            # [ doc = "Checks if the value of the field is `Neg20dBm`" ]
            # [ inline ( always ) ]
            pub fn is_neg20d_bm(&self) -> bool {
                *self == TxpowerR::Neg20dBm
            }
            # [ doc = "Checks if the value of the field is `Neg30dBm`" ]
            # [ inline ( always ) ]
            pub fn is_neg30d_bm(&self) -> bool {
                *self == TxpowerR::Neg30dBm
            }
        }
        # [ doc = "Values that can be written to the field `TXPOWER`" ]
        pub enum TxpowerW {
            # [ doc = "+4dBm." ]
            Pos4dBm,
            # [ doc = "0dBm." ]
            _0dBm,
            # [ doc = "-4dBm." ]
            Neg4dBm,
            # [ doc = "-8dBm." ]
            Neg8dBm,
            # [ doc = "-12dBm." ]
            Neg12dBm,
            # [ doc = "-16dBm." ]
            Neg16dBm,
            # [ doc = "-20dBm." ]
            Neg20dBm,
            # [ doc = "-30dBm." ]
            Neg30dBm,
        }
        impl TxpowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TxpowerW::Pos4dBm => 4,
                    TxpowerW::_0dBm => 0,
                    TxpowerW::Neg4dBm => 252,
                    TxpowerW::Neg8dBm => 248,
                    TxpowerW::Neg12dBm => 244,
                    TxpowerW::Neg16dBm => 240,
                    TxpowerW::Neg20dBm => 236,
                    TxpowerW::Neg30dBm => 216,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TxpowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxpowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TxpowerW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "+4dBm." ]
            # [ inline ( always ) ]
            pub fn pos4d_bm(self) -> &'a mut W {
                self.variant(TxpowerW::Pos4dBm)
            }
            # [ doc = "0dBm." ]
            # [ inline ( always ) ]
            pub fn _0d_bm(self) -> &'a mut W {
                self.variant(TxpowerW::_0dBm)
            }
            # [ doc = "-4dBm." ]
            # [ inline ( always ) ]
            pub fn neg4d_bm(self) -> &'a mut W {
                self.variant(TxpowerW::Neg4dBm)
            }
            # [ doc = "-8dBm." ]
            # [ inline ( always ) ]
            pub fn neg8d_bm(self) -> &'a mut W {
                self.variant(TxpowerW::Neg8dBm)
            }
            # [ doc = "-12dBm." ]
            # [ inline ( always ) ]
            pub fn neg12d_bm(self) -> &'a mut W {
                self.variant(TxpowerW::Neg12dBm)
            }
            # [ doc = "-16dBm." ]
            # [ inline ( always ) ]
            pub fn neg16d_bm(self) -> &'a mut W {
                self.variant(TxpowerW::Neg16dBm)
            }
            # [ doc = "-20dBm." ]
            # [ inline ( always ) ]
            pub fn neg20d_bm(self) -> &'a mut W {
                self.variant(TxpowerW::Neg20dBm)
            }
            # [ doc = "-30dBm." ]
            # [ inline ( always ) ]
            pub fn neg30d_bm(self) -> &'a mut W {
                self.variant(TxpowerW::Neg30dBm)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Radio output power. Decision point: TXEN task." ]
            # [ inline ( always ) ]
            pub fn txpower(&self) -> TxpowerR {
                TxpowerR::_from(
                    {
                        const MASK: u8 = 255;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Radio output power. Decision point: TXEN task." ]
            # [ inline ( always ) ]
            pub fn txpower(&mut self) -> _TxpowerW {
                _TxpowerW { w: self }
            }
        }
    }
    # [ doc = "Data rate and modulation." ]
    pub struct Mode {
        register: VolatileCell<u32>,
    }
    # [ doc = "Data rate and modulation." ]
    pub mod mode {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Mode {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `MODE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ModeR {
            # [ doc = "1Mbit/s Nordic propietary radio mode." ]
            Nrf1mbit,
            # [ doc = "2Mbit/s Nordic propietary radio mode." ]
            Nrf2mbit,
            # [ doc = "250kbit/s Nordic propietary radio mode." ]
            Nrf250kbit,
            # [ doc = "1Mbit/s Bluetooth Low Energy" ]
            Ble1mbit,
        }
        impl ModeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ModeR::Nrf1mbit => 0,
                    ModeR::Nrf2mbit => 1,
                    ModeR::Nrf250kbit => 2,
                    ModeR::Ble1mbit => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ModeR {
                match bits {
                    0 => ModeR::Nrf1mbit,
                    1 => ModeR::Nrf2mbit,
                    2 => ModeR::Nrf250kbit,
                    3 => ModeR::Ble1mbit,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Nrf1mbit`" ]
            # [ inline ( always ) ]
            pub fn is_nrf_1mbit(&self) -> bool {
                *self == ModeR::Nrf1mbit
            }
            # [ doc = "Checks if the value of the field is `Nrf2mbit`" ]
            # [ inline ( always ) ]
            pub fn is_nrf_2mbit(&self) -> bool {
                *self == ModeR::Nrf2mbit
            }
            # [ doc = "Checks if the value of the field is `Nrf250kbit`" ]
            # [ inline ( always ) ]
            pub fn is_nrf_250kbit(&self) -> bool {
                *self == ModeR::Nrf250kbit
            }
            # [ doc = "Checks if the value of the field is `Ble1mbit`" ]
            # [ inline ( always ) ]
            pub fn is_ble_1mbit(&self) -> bool {
                *self == ModeR::Ble1mbit
            }
        }
        # [ doc = "Values that can be written to the field `MODE`" ]
        pub enum ModeW {
            # [ doc = "1Mbit/s Nordic propietary radio mode." ]
            Nrf1mbit,
            # [ doc = "2Mbit/s Nordic propietary radio mode." ]
            Nrf2mbit,
            # [ doc = "250kbit/s Nordic propietary radio mode." ]
            Nrf250kbit,
            # [ doc = "1Mbit/s Bluetooth Low Energy" ]
            Ble1mbit,
        }
        impl ModeW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ModeW::Nrf1mbit => 0,
                    ModeW::Nrf2mbit => 1,
                    ModeW::Nrf250kbit => 2,
                    ModeW::Ble1mbit => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ModeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ModeW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ModeW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "1Mbit/s Nordic propietary radio mode." ]
            # [ inline ( always ) ]
            pub fn nrf_1mbit(self) -> &'a mut W {
                self.variant(ModeW::Nrf1mbit)
            }
            # [ doc = "2Mbit/s Nordic propietary radio mode." ]
            # [ inline ( always ) ]
            pub fn nrf_2mbit(self) -> &'a mut W {
                self.variant(ModeW::Nrf2mbit)
            }
            # [ doc = "250kbit/s Nordic propietary radio mode." ]
            # [ inline ( always ) ]
            pub fn nrf_250kbit(self) -> &'a mut W {
                self.variant(ModeW::Nrf250kbit)
            }
            # [ doc = "1Mbit/s Bluetooth Low Energy" ]
            # [ inline ( always ) ]
            pub fn ble_1mbit(self) -> &'a mut W {
                self.variant(ModeW::Ble1mbit)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - Radio data rate and modulation setting. Decision point: TXEN or RXEN task." ]
            # [ inline ( always ) ]
            pub fn mode(&self) -> ModeR {
                ModeR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - Radio data rate and modulation setting. Decision point: TXEN or RXEN task." ]
            # [ inline ( always ) ]
            pub fn mode(&mut self) -> _ModeW {
                _ModeW { w: self }
            }
        }
    }
    # [ doc = "Packet configuration 0." ]
    pub struct Pcnf0 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Packet configuration 0." ]
    pub mod pcnf0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pcnf0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LflenR {
            bits: u8,
        }
        impl LflenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct S0lenR {
            bits: u8,
        }
        impl S0lenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct S1lenR {
            bits: u8,
        }
        impl S1lenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LflenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LflenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _S0lenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S0lenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _S1lenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S1lenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - Length of length field in number of bits. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn lflen(&self) -> LflenR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LflenR { bits }
            }
            # [ doc = "Bit 8 - Length of S0 field in number of bytes. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn s0len(&self) -> S0lenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                S0lenR { bits }
            }
            # [ doc = "Bits 16:19 - Length of S1 field in number of bits. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn s1len(&self) -> S1lenR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                S1lenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:3 - Length of length field in number of bits. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn lflen(&mut self) -> _LflenW {
                _LflenW { w: self }
            }
            # [ doc = "Bit 8 - Length of S0 field in number of bytes. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn s0len(&mut self) -> _S0lenW {
                _S0lenW { w: self }
            }
            # [ doc = "Bits 16:19 - Length of S1 field in number of bits. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn s1len(&mut self) -> _S1lenW {
                _S1lenW { w: self }
            }
        }
    }
    # [ doc = "Packet configuration 1." ]
    pub struct Pcnf1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Packet configuration 1." ]
    pub mod pcnf1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pcnf1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MaxlenR {
            bits: u8,
        }
        impl MaxlenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct StatlenR {
            bits: u8,
        }
        impl StatlenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BalenR {
            bits: u8,
        }
        impl BalenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `ENDIAN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndianR {
            # [ doc = "Least significant bit on air first" ]
            Little,
            # [ doc = "Most significant bit on air first" ]
            Big,
        }
        impl EndianR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndianR::Little => 0,
                    EndianR::Big => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndianR {
                match bits {
                    0 => EndianR::Little,
                    1 => EndianR::Big,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Little`" ]
            # [ inline ( always ) ]
            pub fn is_little(&self) -> bool {
                *self == EndianR::Little
            }
            # [ doc = "Checks if the value of the field is `Big`" ]
            # [ inline ( always ) ]
            pub fn is_big(&self) -> bool {
                *self == EndianR::Big
            }
        }
        # [ doc = "Possible values of the field `WHITEEN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum WhiteenR {
            # [ doc = "Whitening disabled." ]
            Disabled,
            # [ doc = "Whitening enabled." ]
            Enabled,
        }
        impl WhiteenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    WhiteenR::Disabled => 0,
                    WhiteenR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> WhiteenR {
                match bits {
                    0 => WhiteenR::Disabled,
                    1 => WhiteenR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == WhiteenR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == WhiteenR::Enabled
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MaxlenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaxlenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _StatlenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StatlenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BalenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BalenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ENDIAN`" ]
        pub enum EndianW {
            # [ doc = "Least significant bit on air first" ]
            Little,
            # [ doc = "Most significant bit on air first" ]
            Big,
        }
        impl EndianW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndianW::Little => 0,
                    EndianW::Big => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndianW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndianW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndianW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Least significant bit on air first" ]
            # [ inline ( always ) ]
            pub fn little(self) -> &'a mut W {
                self.variant(EndianW::Little)
            }
            # [ doc = "Most significant bit on air first" ]
            # [ inline ( always ) ]
            pub fn big(self) -> &'a mut W {
                self.variant(EndianW::Big)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `WHITEEN`" ]
        pub enum WhiteenW {
            # [ doc = "Whitening disabled." ]
            Disabled,
            # [ doc = "Whitening enabled." ]
            Enabled,
        }
        impl WhiteenW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WhiteenW::Disabled => 0,
                    WhiteenW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WhiteenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WhiteenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: WhiteenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Whitening disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WhiteenW::Disabled)
            }
            # [ doc = "Whitening enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WhiteenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Maximum length of packet payload in number of bytes." ]
            # [ inline ( always ) ]
            pub fn maxlen(&self) -> MaxlenR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MaxlenR { bits }
            }
            # [ doc = "Bits 8:15 - Static length in number of bytes. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn statlen(&self) -> StatlenR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StatlenR { bits }
            }
            # [ doc = "Bits 16:18 - Base address length in number of bytes. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn balen(&self) -> BalenR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BalenR { bits }
            }
            # [ doc = "Bit 24 - On air endianness of packet length field. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn endian(&self) -> EndianR {
                EndianR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 24;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 25 - Packet whitening enable." ]
            # [ inline ( always ) ]
            pub fn whiteen(&self) -> WhiteenR {
                WhiteenR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 25;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Maximum length of packet payload in number of bytes." ]
            # [ inline ( always ) ]
            pub fn maxlen(&mut self) -> _MaxlenW {
                _MaxlenW { w: self }
            }
            # [ doc = "Bits 8:15 - Static length in number of bytes. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn statlen(&mut self) -> _StatlenW {
                _StatlenW { w: self }
            }
            # [ doc = "Bits 16:18 - Base address length in number of bytes. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn balen(&mut self) -> _BalenW {
                _BalenW { w: self }
            }
            # [ doc = "Bit 24 - On air endianness of packet length field. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn endian(&mut self) -> _EndianW {
                _EndianW { w: self }
            }
            # [ doc = "Bit 25 - Packet whitening enable." ]
            # [ inline ( always ) ]
            pub fn whiteen(&mut self) -> _WhiteenW {
                _WhiteenW { w: self }
            }
        }
    }
    # [ doc = "Radio base address 0. Decision point: START task." ]
    pub struct Base0 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Radio base address 0. Decision point: START task." ]
    pub mod base0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Base0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio base address 1. Decision point: START task." ]
    pub struct Base1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Radio base address 1. Decision point: START task." ]
    pub mod base1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Base1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Prefixes bytes for logical addresses 0 to 3." ]
    pub struct Prefix0 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Prefixes bytes for logical addresses 0 to 3." ]
    pub mod prefix0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Prefix0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ap0R {
            bits: u8,
        }
        impl Ap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ap1R {
            bits: u8,
        }
        impl Ap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ap2R {
            bits: u8,
        }
        impl Ap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ap3R {
            bits: u8,
        }
        impl Ap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Address prefix 0. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn ap0(&self) -> Ap0R {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ap0R { bits }
            }
            # [ doc = "Bits 8:15 - Address prefix 1. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn ap1(&self) -> Ap1R {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ap1R { bits }
            }
            # [ doc = "Bits 16:23 - Address prefix 2. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn ap2(&self) -> Ap2R {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ap2R { bits }
            }
            # [ doc = "Bits 24:31 - Address prefix 3. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn ap3(&self) -> Ap3R {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ap3R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Address prefix 0. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn ap0(&mut self) -> _Ap0W {
                _Ap0W { w: self }
            }
            # [ doc = "Bits 8:15 - Address prefix 1. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn ap1(&mut self) -> _Ap1W {
                _Ap1W { w: self }
            }
            # [ doc = "Bits 16:23 - Address prefix 2. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn ap2(&mut self) -> _Ap2W {
                _Ap2W { w: self }
            }
            # [ doc = "Bits 24:31 - Address prefix 3. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn ap3(&mut self) -> _Ap3W {
                _Ap3W { w: self }
            }
        }
    }
    # [ doc = "Prefixes bytes for logical addresses 4 to 7." ]
    pub struct Prefix1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Prefixes bytes for logical addresses 4 to 7." ]
    pub mod prefix1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Prefix1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ap4R {
            bits: u8,
        }
        impl Ap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ap5R {
            bits: u8,
        }
        impl Ap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ap6R {
            bits: u8,
        }
        impl Ap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ap7R {
            bits: u8,
        }
        impl Ap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Address prefix 4. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn ap4(&self) -> Ap4R {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ap4R { bits }
            }
            # [ doc = "Bits 8:15 - Address prefix 5. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn ap5(&self) -> Ap5R {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ap5R { bits }
            }
            # [ doc = "Bits 16:23 - Address prefix 6. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn ap6(&self) -> Ap6R {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ap6R { bits }
            }
            # [ doc = "Bits 24:31 - Address prefix 7. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn ap7(&self) -> Ap7R {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Address prefix 4. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn ap4(&mut self) -> _Ap4W {
                _Ap4W { w: self }
            }
            # [ doc = "Bits 8:15 - Address prefix 5. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn ap5(&mut self) -> _Ap5W {
                _Ap5W { w: self }
            }
            # [ doc = "Bits 16:23 - Address prefix 6. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn ap6(&mut self) -> _Ap6W {
                _Ap6W { w: self }
            }
            # [ doc = "Bits 24:31 - Address prefix 7. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn ap7(&mut self) -> _Ap7W {
                _Ap7W { w: self }
            }
        }
    }
    # [ doc = "Transmit address select." ]
    pub struct Txaddress {
        register: VolatileCell<u32>,
    }
    # [ doc = "Transmit address select." ]
    pub mod txaddress {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Txaddress {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TxaddressR {
            bits: u8,
        }
        impl TxaddressR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TxaddressW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxaddressW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:2 - Logical address to be used when transmitting a packet. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn txaddress(&self) -> TxaddressR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxaddressR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:2 - Logical address to be used when transmitting a packet. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn txaddress(&mut self) -> _TxaddressW {
                _TxaddressW { w: self }
            }
        }
    }
    # [ doc = "Receive address select." ]
    pub struct Rxaddresses {
        register: VolatileCell<u32>,
    }
    # [ doc = "Receive address select." ]
    pub mod rxaddresses {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Rxaddresses {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ADDR0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Addr0R {
            # [ doc = "Reception disabled." ]
            Disabled,
            # [ doc = "Reception enabled." ]
            Enabled,
        }
        impl Addr0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Addr0R::Disabled => 0,
                    Addr0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Addr0R {
                match bits {
                    0 => Addr0R::Disabled,
                    1 => Addr0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Addr0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Addr0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `ADDR1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Addr1R {
            # [ doc = "Reception disabled." ]
            Disabled,
            # [ doc = "Reception enabled." ]
            Enabled,
        }
        impl Addr1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Addr1R::Disabled => 0,
                    Addr1R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Addr1R {
                match bits {
                    0 => Addr1R::Disabled,
                    1 => Addr1R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Addr1R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Addr1R::Enabled
            }
        }
        # [ doc = "Possible values of the field `ADDR2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Addr2R {
            # [ doc = "Reception disabled." ]
            Disabled,
            # [ doc = "Reception enabled." ]
            Enabled,
        }
        impl Addr2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Addr2R::Disabled => 0,
                    Addr2R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Addr2R {
                match bits {
                    0 => Addr2R::Disabled,
                    1 => Addr2R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Addr2R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Addr2R::Enabled
            }
        }
        # [ doc = "Possible values of the field `ADDR3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Addr3R {
            # [ doc = "Reception disabled." ]
            Disabled,
            # [ doc = "Reception enabled." ]
            Enabled,
        }
        impl Addr3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Addr3R::Disabled => 0,
                    Addr3R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Addr3R {
                match bits {
                    0 => Addr3R::Disabled,
                    1 => Addr3R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Addr3R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Addr3R::Enabled
            }
        }
        # [ doc = "Possible values of the field `ADDR4`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Addr4R {
            # [ doc = "Reception disabled." ]
            Disabled,
            # [ doc = "Reception enabled." ]
            Enabled,
        }
        impl Addr4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Addr4R::Disabled => 0,
                    Addr4R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Addr4R {
                match bits {
                    0 => Addr4R::Disabled,
                    1 => Addr4R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Addr4R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Addr4R::Enabled
            }
        }
        # [ doc = "Possible values of the field `ADDR5`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Addr5R {
            # [ doc = "Reception disabled." ]
            Disabled,
            # [ doc = "Reception enabled." ]
            Enabled,
        }
        impl Addr5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Addr5R::Disabled => 0,
                    Addr5R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Addr5R {
                match bits {
                    0 => Addr5R::Disabled,
                    1 => Addr5R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Addr5R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Addr5R::Enabled
            }
        }
        # [ doc = "Possible values of the field `ADDR6`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Addr6R {
            # [ doc = "Reception disabled." ]
            Disabled,
            # [ doc = "Reception enabled." ]
            Enabled,
        }
        impl Addr6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Addr6R::Disabled => 0,
                    Addr6R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Addr6R {
                match bits {
                    0 => Addr6R::Disabled,
                    1 => Addr6R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Addr6R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Addr6R::Enabled
            }
        }
        # [ doc = "Possible values of the field `ADDR7`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Addr7R {
            # [ doc = "Reception disabled." ]
            Disabled,
            # [ doc = "Reception enabled." ]
            Enabled,
        }
        impl Addr7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Addr7R::Disabled => 0,
                    Addr7R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Addr7R {
                match bits {
                    0 => Addr7R::Disabled,
                    1 => Addr7R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Addr7R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Addr7R::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `ADDR0`" ]
        pub enum Addr0W {
            # [ doc = "Reception disabled." ]
            Disabled,
            # [ doc = "Reception enabled." ]
            Enabled,
        }
        impl Addr0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Addr0W::Disabled => 0,
                    Addr0W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Addr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Addr0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Addr0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Reception disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Addr0W::Disabled)
            }
            # [ doc = "Reception enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Addr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADDR1`" ]
        pub enum Addr1W {
            # [ doc = "Reception disabled." ]
            Disabled,
            # [ doc = "Reception enabled." ]
            Enabled,
        }
        impl Addr1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Addr1W::Disabled => 0,
                    Addr1W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Addr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Addr1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Addr1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Reception disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Addr1W::Disabled)
            }
            # [ doc = "Reception enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Addr1W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADDR2`" ]
        pub enum Addr2W {
            # [ doc = "Reception disabled." ]
            Disabled,
            # [ doc = "Reception enabled." ]
            Enabled,
        }
        impl Addr2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Addr2W::Disabled => 0,
                    Addr2W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Addr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Addr2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Addr2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Reception disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Addr2W::Disabled)
            }
            # [ doc = "Reception enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Addr2W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADDR3`" ]
        pub enum Addr3W {
            # [ doc = "Reception disabled." ]
            Disabled,
            # [ doc = "Reception enabled." ]
            Enabled,
        }
        impl Addr3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Addr3W::Disabled => 0,
                    Addr3W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Addr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Addr3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Addr3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Reception disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Addr3W::Disabled)
            }
            # [ doc = "Reception enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Addr3W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADDR4`" ]
        pub enum Addr4W {
            # [ doc = "Reception disabled." ]
            Disabled,
            # [ doc = "Reception enabled." ]
            Enabled,
        }
        impl Addr4W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Addr4W::Disabled => 0,
                    Addr4W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Addr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Addr4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Addr4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Reception disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Addr4W::Disabled)
            }
            # [ doc = "Reception enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Addr4W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADDR5`" ]
        pub enum Addr5W {
            # [ doc = "Reception disabled." ]
            Disabled,
            # [ doc = "Reception enabled." ]
            Enabled,
        }
        impl Addr5W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Addr5W::Disabled => 0,
                    Addr5W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Addr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Addr5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Addr5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Reception disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Addr5W::Disabled)
            }
            # [ doc = "Reception enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Addr5W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADDR6`" ]
        pub enum Addr6W {
            # [ doc = "Reception disabled." ]
            Disabled,
            # [ doc = "Reception enabled." ]
            Enabled,
        }
        impl Addr6W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Addr6W::Disabled => 0,
                    Addr6W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Addr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Addr6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Addr6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Reception disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Addr6W::Disabled)
            }
            # [ doc = "Reception enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Addr6W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADDR7`" ]
        pub enum Addr7W {
            # [ doc = "Reception disabled." ]
            Disabled,
            # [ doc = "Reception enabled." ]
            Enabled,
        }
        impl Addr7W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Addr7W::Disabled => 0,
                    Addr7W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Addr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Addr7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Addr7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Reception disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Addr7W::Disabled)
            }
            # [ doc = "Reception enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Addr7W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable reception on logical address 0. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn addr0(&self) -> Addr0R {
                Addr0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Enable reception on logical address 1. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn addr1(&self) -> Addr1R {
                Addr1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Enable reception on logical address 2. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn addr2(&self) -> Addr2R {
                Addr2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Enable reception on logical address 3. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn addr3(&self) -> Addr3R {
                Addr3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Enable reception on logical address 4. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn addr4(&self) -> Addr4R {
                Addr4R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Enable reception on logical address 5. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn addr5(&self) -> Addr5R {
                Addr5R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Enable reception on logical address 6. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn addr6(&self) -> Addr6R {
                Addr6R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Enable reception on logical address 7. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn addr7(&self) -> Addr7R {
                Addr7R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable reception on logical address 0. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn addr0(&mut self) -> _Addr0W {
                _Addr0W { w: self }
            }
            # [ doc = "Bit 1 - Enable reception on logical address 1. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn addr1(&mut self) -> _Addr1W {
                _Addr1W { w: self }
            }
            # [ doc = "Bit 2 - Enable reception on logical address 2. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn addr2(&mut self) -> _Addr2W {
                _Addr2W { w: self }
            }
            # [ doc = "Bit 3 - Enable reception on logical address 3. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn addr3(&mut self) -> _Addr3W {
                _Addr3W { w: self }
            }
            # [ doc = "Bit 4 - Enable reception on logical address 4. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn addr4(&mut self) -> _Addr4W {
                _Addr4W { w: self }
            }
            # [ doc = "Bit 5 - Enable reception on logical address 5. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn addr5(&mut self) -> _Addr5W {
                _Addr5W { w: self }
            }
            # [ doc = "Bit 6 - Enable reception on logical address 6. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn addr6(&mut self) -> _Addr6W {
                _Addr6W { w: self }
            }
            # [ doc = "Bit 7 - Enable reception on logical address 7. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn addr7(&mut self) -> _Addr7W {
                _Addr7W { w: self }
            }
        }
    }
    # [ doc = "CRC configuration." ]
    pub struct Crccnf {
        register: VolatileCell<u32>,
    }
    # [ doc = "CRC configuration." ]
    pub mod crccnf {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Crccnf {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `LEN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum LenR {
            # [ doc = "CRC calculation disabled." ]
            Disabled,
            # [ doc = "One byte long CRC." ]
            One,
            # [ doc = "Two bytes long CRC." ]
            Two,
            # [ doc = "Three bytes long CRC." ]
            Three,
        }
        impl LenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    LenR::Disabled => 0,
                    LenR::One => 1,
                    LenR::Two => 2,
                    LenR::Three => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> LenR {
                match bits {
                    0 => LenR::Disabled,
                    1 => LenR::One,
                    2 => LenR::Two,
                    3 => LenR::Three,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == LenR::Disabled
            }
            # [ doc = "Checks if the value of the field is `One`" ]
            # [ inline ( always ) ]
            pub fn is_one(&self) -> bool {
                *self == LenR::One
            }
            # [ doc = "Checks if the value of the field is `Two`" ]
            # [ inline ( always ) ]
            pub fn is_two(&self) -> bool {
                *self == LenR::Two
            }
            # [ doc = "Checks if the value of the field is `Three`" ]
            # [ inline ( always ) ]
            pub fn is_three(&self) -> bool {
                *self == LenR::Three
            }
        }
        # [ doc = "Possible values of the field `SKIPADDR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SkipaddrR {
            # [ doc = "Include packet address in CRC calculation." ]
            Include,
            # [ doc = "Packet address is skipped in CRC calculation. The CRC calculation will start at the first byte after the address." ]
            Skip,
        }
        impl SkipaddrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SkipaddrR::Include => 0,
                    SkipaddrR::Skip => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SkipaddrR {
                match bits {
                    0 => SkipaddrR::Include,
                    1 => SkipaddrR::Skip,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Include`" ]
            # [ inline ( always ) ]
            pub fn is_include(&self) -> bool {
                *self == SkipaddrR::Include
            }
            # [ doc = "Checks if the value of the field is `Skip`" ]
            # [ inline ( always ) ]
            pub fn is_skip(&self) -> bool {
                *self == SkipaddrR::Skip
            }
        }
        # [ doc = "Values that can be written to the field `LEN`" ]
        pub enum LenW {
            # [ doc = "CRC calculation disabled." ]
            Disabled,
            # [ doc = "One byte long CRC." ]
            One,
            # [ doc = "Two bytes long CRC." ]
            Two,
            # [ doc = "Three bytes long CRC." ]
            Three,
        }
        impl LenW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    LenW::Disabled => 0,
                    LenW::One => 1,
                    LenW::Two => 2,
                    LenW::Three => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: LenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "CRC calculation disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LenW::Disabled)
            }
            # [ doc = "One byte long CRC." ]
            # [ inline ( always ) ]
            pub fn one(self) -> &'a mut W {
                self.variant(LenW::One)
            }
            # [ doc = "Two bytes long CRC." ]
            # [ inline ( always ) ]
            pub fn two(self) -> &'a mut W {
                self.variant(LenW::Two)
            }
            # [ doc = "Three bytes long CRC." ]
            # [ inline ( always ) ]
            pub fn three(self) -> &'a mut W {
                self.variant(LenW::Three)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `SKIPADDR`" ]
        pub enum SkipaddrW {
            # [ doc = "Include packet address in CRC calculation." ]
            Include,
            # [ doc = "Packet address is skipped in CRC calculation. The CRC calculation will start at the first byte after the address." ]
            Skip,
        }
        impl SkipaddrW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SkipaddrW::Include => 0,
                    SkipaddrW::Skip => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SkipaddrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SkipaddrW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SkipaddrW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Include packet address in CRC calculation." ]
            # [ inline ( always ) ]
            pub fn include(self) -> &'a mut W {
                self.variant(SkipaddrW::Include)
            }
            # [ doc = "Packet address is skipped in CRC calculation. The CRC calculation will start at the first byte after the address." ]
            # [ inline ( always ) ]
            pub fn skip(self) -> &'a mut W {
                self.variant(SkipaddrW::Skip)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - CRC length. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn len(&self) -> LenR {
                LenR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Leave packet address field out of the CRC calculation. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn skipaddr(&self) -> SkipaddrR {
                SkipaddrR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - CRC length. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn len(&mut self) -> _LenW {
                _LenW { w: self }
            }
            # [ doc = "Bit 8 - Leave packet address field out of the CRC calculation. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn skipaddr(&mut self) -> _SkipaddrW {
                _SkipaddrW { w: self }
            }
        }
    }
    # [ doc = "CRC polynomial." ]
    pub struct Crcpoly {
        register: VolatileCell<u32>,
    }
    # [ doc = "CRC polynomial." ]
    pub mod crcpoly {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Crcpoly {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CrcpolyR {
            bits: u32,
        }
        impl CrcpolyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CrcpolyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CrcpolyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 16777215;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:23 - CRC polynomial. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn crcpoly(&self) -> CrcpolyR {
                let bits = {
                    const MASK: u32 = 16777215;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CrcpolyR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:23 - CRC polynomial. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn crcpoly(&mut self) -> _CrcpolyW {
                _CrcpolyW { w: self }
            }
        }
    }
    # [ doc = "CRC initial value." ]
    pub struct Crcinit {
        register: VolatileCell<u32>,
    }
    # [ doc = "CRC initial value." ]
    pub mod crcinit {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Crcinit {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CrcinitR {
            bits: u32,
        }
        impl CrcinitR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CrcinitW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CrcinitW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 16777215;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:23 - Initial value for CRC calculation. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn crcinit(&self) -> CrcinitR {
                let bits = {
                    const MASK: u32 = 16777215;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CrcinitR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:23 - Initial value for CRC calculation. Decision point: START task." ]
            # [ inline ( always ) ]
            pub fn crcinit(&mut self) -> _CrcinitW {
                _CrcinitW { w: self }
            }
        }
    }
    # [ doc = "Test features enable register." ]
    pub struct Test {
        register: VolatileCell<u32>,
    }
    # [ doc = "Test features enable register." ]
    pub mod test {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Test {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `CONSTCARRIER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ConstcarrierR {
            # [ doc = "Constant carrier disabled." ]
            Disabled,
            # [ doc = "Constant carrier enabled." ]
            Enabled,
        }
        impl ConstcarrierR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ConstcarrierR::Disabled => 0,
                    ConstcarrierR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ConstcarrierR {
                match bits {
                    0 => ConstcarrierR::Disabled,
                    1 => ConstcarrierR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ConstcarrierR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ConstcarrierR::Enabled
            }
        }
        # [ doc = "Possible values of the field `PLLLOCK`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PlllockR {
            # [ doc = "PLL lock disabled." ]
            Disabled,
            # [ doc = "PLL lock enabled." ]
            Enabled,
        }
        impl PlllockR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PlllockR::Disabled => 0,
                    PlllockR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PlllockR {
                match bits {
                    0 => PlllockR::Disabled,
                    1 => PlllockR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PlllockR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PlllockR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `CONSTCARRIER`" ]
        pub enum ConstcarrierW {
            # [ doc = "Constant carrier disabled." ]
            Disabled,
            # [ doc = "Constant carrier enabled." ]
            Enabled,
        }
        impl ConstcarrierW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ConstcarrierW::Disabled => 0,
                    ConstcarrierW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ConstcarrierW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ConstcarrierW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ConstcarrierW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Constant carrier disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ConstcarrierW::Disabled)
            }
            # [ doc = "Constant carrier enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ConstcarrierW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PLLLOCK`" ]
        pub enum PlllockW {
            # [ doc = "PLL lock disabled." ]
            Disabled,
            # [ doc = "PLL lock enabled." ]
            Enabled,
        }
        impl PlllockW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PlllockW::Disabled => 0,
                    PlllockW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PlllockW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlllockW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PlllockW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "PLL lock disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PlllockW::Disabled)
            }
            # [ doc = "PLL lock enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PlllockW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Constant carrier. Decision point: TXEN task." ]
            # [ inline ( always ) ]
            pub fn constcarrier(&self) -> ConstcarrierR {
                ConstcarrierR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - PLL lock. Decision point: TXEN or RXEN task." ]
            # [ inline ( always ) ]
            pub fn plllock(&self) -> PlllockR {
                PlllockR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Constant carrier. Decision point: TXEN task." ]
            # [ inline ( always ) ]
            pub fn constcarrier(&mut self) -> _ConstcarrierW {
                _ConstcarrierW { w: self }
            }
            # [ doc = "Bit 1 - PLL lock. Decision point: TXEN or RXEN task." ]
            # [ inline ( always ) ]
            pub fn plllock(&mut self) -> _PlllockW {
                _PlllockW { w: self }
            }
        }
    }
    # [ doc = "Inter Frame Spacing in microseconds." ]
    pub struct Tifs {
        register: VolatileCell<u32>,
    }
    # [ doc = "Inter Frame Spacing in microseconds." ]
    pub mod tifs {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Tifs {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TifsR {
            bits: u8,
        }
        impl TifsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TifsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TifsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Inter frame spacing in microseconds. Decision point: START rask" ]
            # [ inline ( always ) ]
            pub fn tifs(&self) -> TifsR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TifsR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Inter frame spacing in microseconds. Decision point: START rask" ]
            # [ inline ( always ) ]
            pub fn tifs(&mut self) -> _TifsW {
                _TifsW { w: self }
            }
        }
    }
    # [ doc = "RSSI sample." ]
    pub struct Rssisample {
        register: VolatileCell<u32>,
    }
    # [ doc = "RSSI sample." ]
    pub mod rssisample {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Rssisample {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RssisampleR {
            bits: u8,
        }
        impl RssisampleR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:6 - RSSI sample result. The result is read as a positive value so that ReceivedSignalStrength = -RSSISAMPLE dBm" ]
            # [ inline ( always ) ]
            pub fn rssisample(&self) -> RssisampleR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RssisampleR { bits }
            }
        }
    }
    # [ doc = "Current radio state." ]
    pub struct State {
        register: VolatileCell<u32>,
    }
    # [ doc = "Current radio state." ]
    pub mod state {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::State {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = "Possible values of the field `STATE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum StateR {
            # [ doc = "Radio is in the Disabled state." ]
            Disabled,
            # [ doc = "Radio is in the Rx Ramp Up state." ]
            RxRu,
            # [ doc = "Radio is in the Rx Idle state." ]
            RxIdle,
            # [ doc = "Radio is in the Rx state." ]
            Rx,
            # [ doc = "Radio is in the Rx Disable state." ]
            RxDisable,
            # [ doc = "Radio is in the Tx Ramp Up state." ]
            TxRu,
            # [ doc = "Radio is in the Tx Idle state." ]
            TxIdle,
            # [ doc = "Radio is in the Tx state." ]
            Tx,
            # [ doc = "Radio is in the Tx Disable state." ]
            TxDisable,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl StateR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    StateR::Disabled => 0,
                    StateR::RxRu => 1,
                    StateR::RxIdle => 2,
                    StateR::Rx => 3,
                    StateR::RxDisable => 4,
                    StateR::TxRu => 9,
                    StateR::TxIdle => 10,
                    StateR::Tx => 11,
                    StateR::TxDisable => 12,
                    StateR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> StateR {
                match bits {
                    0 => StateR::Disabled,
                    1 => StateR::RxRu,
                    2 => StateR::RxIdle,
                    3 => StateR::Rx,
                    4 => StateR::RxDisable,
                    9 => StateR::TxRu,
                    10 => StateR::TxIdle,
                    11 => StateR::Tx,
                    12 => StateR::TxDisable,
                    i => StateR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == StateR::Disabled
            }
            # [ doc = "Checks if the value of the field is `RxRu`" ]
            # [ inline ( always ) ]
            pub fn is_rx_ru(&self) -> bool {
                *self == StateR::RxRu
            }
            # [ doc = "Checks if the value of the field is `RxIdle`" ]
            # [ inline ( always ) ]
            pub fn is_rx_idle(&self) -> bool {
                *self == StateR::RxIdle
            }
            # [ doc = "Checks if the value of the field is `Rx`" ]
            # [ inline ( always ) ]
            pub fn is_rx(&self) -> bool {
                *self == StateR::Rx
            }
            # [ doc = "Checks if the value of the field is `RxDisable`" ]
            # [ inline ( always ) ]
            pub fn is_rx_disable(&self) -> bool {
                *self == StateR::RxDisable
            }
            # [ doc = "Checks if the value of the field is `TxRu`" ]
            # [ inline ( always ) ]
            pub fn is_tx_ru(&self) -> bool {
                *self == StateR::TxRu
            }
            # [ doc = "Checks if the value of the field is `TxIdle`" ]
            # [ inline ( always ) ]
            pub fn is_tx_idle(&self) -> bool {
                *self == StateR::TxIdle
            }
            # [ doc = "Checks if the value of the field is `Tx`" ]
            # [ inline ( always ) ]
            pub fn is_tx(&self) -> bool {
                *self == StateR::Tx
            }
            # [ doc = "Checks if the value of the field is `TxDisable`" ]
            # [ inline ( always ) ]
            pub fn is_tx_disable(&self) -> bool {
                *self == StateR::TxDisable
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - Current radio state." ]
            # [ inline ( always ) ]
            pub fn state(&self) -> StateR {
                StateR::_from(
                    {
                        const MASK: u8 = 15;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
    }
    # [ doc = "Data whitening initial value." ]
    pub struct Datawhiteiv {
        register: VolatileCell<u32>,
    }
    # [ doc = "Data whitening initial value." ]
    pub mod datawhiteiv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Datawhiteiv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatawhiteivR {
            bits: u8,
        }
        impl DatawhiteivR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatawhiteivW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatawhiteivW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:6 - Data whitening initial value. Bit 0 corresponds to Position 0 of the LSFR, Bit 1 to position 5... Decision point: TXEN or RXEN task." ]
            # [ inline ( always ) ]
            pub fn datawhiteiv(&self) -> DatawhiteivR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatawhiteivR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 64 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:6 - Data whitening initial value. Bit 0 corresponds to Position 0 of the LSFR, Bit 1 to position 5... Decision point: TXEN or RXEN task." ]
            # [ inline ( always ) ]
            pub fn datawhiteiv(&mut self) -> _DatawhiteivW {
                _DatawhiteivW { w: self }
            }
        }
    }
    # [ doc = "Bit counter compare." ]
    pub struct Bcc {
        register: VolatileCell<u32>,
    }
    # [ doc = "Bit counter compare." ]
    pub mod bcc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Bcc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Device address base segment." ]
    pub struct Dab {
        register: VolatileCell<u32>,
    }
    # [ doc = "Device address base segment." ]
    pub mod dab {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dab {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Device address prefix." ]
    pub struct Dap {
        register: VolatileCell<u32>,
    }
    # [ doc = "Device address prefix." ]
    pub mod dap {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dap {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DapR {
            bits: u16,
        }
        impl DapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Device address prefix." ]
            # [ inline ( always ) ]
            pub fn dap(&self) -> DapR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DapR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Device address prefix." ]
            # [ inline ( always ) ]
            pub fn dap(&mut self) -> _DapW {
                _DapW { w: self }
            }
        }
    }
    # [ doc = "Device address match configuration." ]
    pub struct Dacnf {
        register: VolatileCell<u32>,
    }
    # [ doc = "Device address match configuration." ]
    pub mod dacnf {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dacnf {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ENA0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ena0R {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Ena0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ena0R::Disabled => 0,
                    Ena0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ena0R {
                match bits {
                    0 => Ena0R::Disabled,
                    1 => Ena0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ena0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ena0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `ENA1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ena1R {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Ena1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ena1R::Disabled => 0,
                    Ena1R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ena1R {
                match bits {
                    0 => Ena1R::Disabled,
                    1 => Ena1R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ena1R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ena1R::Enabled
            }
        }
        # [ doc = "Possible values of the field `ENA2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ena2R {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Ena2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ena2R::Disabled => 0,
                    Ena2R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ena2R {
                match bits {
                    0 => Ena2R::Disabled,
                    1 => Ena2R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ena2R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ena2R::Enabled
            }
        }
        # [ doc = "Possible values of the field `ENA3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ena3R {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Ena3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ena3R::Disabled => 0,
                    Ena3R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ena3R {
                match bits {
                    0 => Ena3R::Disabled,
                    1 => Ena3R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ena3R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ena3R::Enabled
            }
        }
        # [ doc = "Possible values of the field `ENA4`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ena4R {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Ena4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ena4R::Disabled => 0,
                    Ena4R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ena4R {
                match bits {
                    0 => Ena4R::Disabled,
                    1 => Ena4R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ena4R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ena4R::Enabled
            }
        }
        # [ doc = "Possible values of the field `ENA5`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ena5R {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Ena5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ena5R::Disabled => 0,
                    Ena5R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ena5R {
                match bits {
                    0 => Ena5R::Disabled,
                    1 => Ena5R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ena5R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ena5R::Enabled
            }
        }
        # [ doc = "Possible values of the field `ENA6`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ena6R {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Ena6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ena6R::Disabled => 0,
                    Ena6R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ena6R {
                match bits {
                    0 => Ena6R::Disabled,
                    1 => Ena6R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ena6R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ena6R::Enabled
            }
        }
        # [ doc = "Possible values of the field `ENA7`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ena7R {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Ena7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ena7R::Disabled => 0,
                    Ena7R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ena7R {
                match bits {
                    0 => Ena7R::Disabled,
                    1 => Ena7R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ena7R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ena7R::Enabled
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Txadd0R {
            bits: u8,
        }
        impl Txadd0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Txadd1R {
            bits: u8,
        }
        impl Txadd1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Txadd2R {
            bits: u8,
        }
        impl Txadd2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Txadd3R {
            bits: u8,
        }
        impl Txadd3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Txadd4R {
            bits: u8,
        }
        impl Txadd4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Txadd5R {
            bits: u8,
        }
        impl Txadd5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Txadd6R {
            bits: u8,
        }
        impl Txadd6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Txadd7R {
            bits: u8,
        }
        impl Txadd7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Values that can be written to the field `ENA0`" ]
        pub enum Ena0W {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Ena0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ena0W::Disabled => 0,
                    Ena0W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ena0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ena0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ena0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ena0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ena0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ENA1`" ]
        pub enum Ena1W {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Ena1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ena1W::Disabled => 0,
                    Ena1W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ena1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ena1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ena1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ena1W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ena1W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ENA2`" ]
        pub enum Ena2W {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Ena2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ena2W::Disabled => 0,
                    Ena2W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ena2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ena2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ena2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ena2W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ena2W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ENA3`" ]
        pub enum Ena3W {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Ena3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ena3W::Disabled => 0,
                    Ena3W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ena3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ena3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ena3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ena3W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ena3W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ENA4`" ]
        pub enum Ena4W {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Ena4W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ena4W::Disabled => 0,
                    Ena4W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ena4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ena4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ena4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ena4W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ena4W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ENA5`" ]
        pub enum Ena5W {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Ena5W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ena5W::Disabled => 0,
                    Ena5W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ena5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ena5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ena5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ena5W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ena5W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ENA6`" ]
        pub enum Ena6W {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Ena6W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ena6W::Disabled => 0,
                    Ena6W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ena6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ena6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ena6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ena6W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ena6W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ENA7`" ]
        pub enum Ena7W {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Ena7W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ena7W::Disabled => 0,
                    Ena7W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ena7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ena7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ena7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ena7W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ena7W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Txadd0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Txadd0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Txadd1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Txadd1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Txadd2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Txadd2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Txadd3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Txadd3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Txadd4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Txadd4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Txadd5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Txadd5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Txadd6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Txadd6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Txadd7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Txadd7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable or disable device address matching using device address 0." ]
            # [ inline ( always ) ]
            pub fn ena0(&self) -> Ena0R {
                Ena0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Enable or disable device address matching using device address 1." ]
            # [ inline ( always ) ]
            pub fn ena1(&self) -> Ena1R {
                Ena1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Enable or disable device address matching using device address 2." ]
            # [ inline ( always ) ]
            pub fn ena2(&self) -> Ena2R {
                Ena2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Enable or disable device address matching using device address 3." ]
            # [ inline ( always ) ]
            pub fn ena3(&self) -> Ena3R {
                Ena3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Enable or disable device address matching using device address 4." ]
            # [ inline ( always ) ]
            pub fn ena4(&self) -> Ena4R {
                Ena4R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Enable or disable device address matching using device address 5." ]
            # [ inline ( always ) ]
            pub fn ena5(&self) -> Ena5R {
                Ena5R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Enable or disable device address matching using device address 6." ]
            # [ inline ( always ) ]
            pub fn ena6(&self) -> Ena6R {
                Ena6R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Enable or disable device address matching using device address 7." ]
            # [ inline ( always ) ]
            pub fn ena7(&self) -> Ena7R {
                Ena7R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - TxAdd for device address 0." ]
            # [ inline ( always ) ]
            pub fn txadd0(&self) -> Txadd0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Txadd0R { bits }
            }
            # [ doc = "Bit 9 - TxAdd for device address 1." ]
            # [ inline ( always ) ]
            pub fn txadd1(&self) -> Txadd1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Txadd1R { bits }
            }
            # [ doc = "Bit 10 - TxAdd for device address 2." ]
            # [ inline ( always ) ]
            pub fn txadd2(&self) -> Txadd2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Txadd2R { bits }
            }
            # [ doc = "Bit 11 - TxAdd for device address 3." ]
            # [ inline ( always ) ]
            pub fn txadd3(&self) -> Txadd3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Txadd3R { bits }
            }
            # [ doc = "Bit 12 - TxAdd for device address 4." ]
            # [ inline ( always ) ]
            pub fn txadd4(&self) -> Txadd4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Txadd4R { bits }
            }
            # [ doc = "Bit 13 - TxAdd for device address 5." ]
            # [ inline ( always ) ]
            pub fn txadd5(&self) -> Txadd5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Txadd5R { bits }
            }
            # [ doc = "Bit 14 - TxAdd for device address 6." ]
            # [ inline ( always ) ]
            pub fn txadd6(&self) -> Txadd6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Txadd6R { bits }
            }
            # [ doc = "Bit 15 - TxAdd for device address 7." ]
            # [ inline ( always ) ]
            pub fn txadd7(&self) -> Txadd7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Txadd7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable or disable device address matching using device address 0." ]
            # [ inline ( always ) ]
            pub fn ena0(&mut self) -> _Ena0W {
                _Ena0W { w: self }
            }
            # [ doc = "Bit 1 - Enable or disable device address matching using device address 1." ]
            # [ inline ( always ) ]
            pub fn ena1(&mut self) -> _Ena1W {
                _Ena1W { w: self }
            }
            # [ doc = "Bit 2 - Enable or disable device address matching using device address 2." ]
            # [ inline ( always ) ]
            pub fn ena2(&mut self) -> _Ena2W {
                _Ena2W { w: self }
            }
            # [ doc = "Bit 3 - Enable or disable device address matching using device address 3." ]
            # [ inline ( always ) ]
            pub fn ena3(&mut self) -> _Ena3W {
                _Ena3W { w: self }
            }
            # [ doc = "Bit 4 - Enable or disable device address matching using device address 4." ]
            # [ inline ( always ) ]
            pub fn ena4(&mut self) -> _Ena4W {
                _Ena4W { w: self }
            }
            # [ doc = "Bit 5 - Enable or disable device address matching using device address 5." ]
            # [ inline ( always ) ]
            pub fn ena5(&mut self) -> _Ena5W {
                _Ena5W { w: self }
            }
            # [ doc = "Bit 6 - Enable or disable device address matching using device address 6." ]
            # [ inline ( always ) ]
            pub fn ena6(&mut self) -> _Ena6W {
                _Ena6W { w: self }
            }
            # [ doc = "Bit 7 - Enable or disable device address matching using device address 7." ]
            # [ inline ( always ) ]
            pub fn ena7(&mut self) -> _Ena7W {
                _Ena7W { w: self }
            }
            # [ doc = "Bit 8 - TxAdd for device address 0." ]
            # [ inline ( always ) ]
            pub fn txadd0(&mut self) -> _Txadd0W {
                _Txadd0W { w: self }
            }
            # [ doc = "Bit 9 - TxAdd for device address 1." ]
            # [ inline ( always ) ]
            pub fn txadd1(&mut self) -> _Txadd1W {
                _Txadd1W { w: self }
            }
            # [ doc = "Bit 10 - TxAdd for device address 2." ]
            # [ inline ( always ) ]
            pub fn txadd2(&mut self) -> _Txadd2W {
                _Txadd2W { w: self }
            }
            # [ doc = "Bit 11 - TxAdd for device address 3." ]
            # [ inline ( always ) ]
            pub fn txadd3(&mut self) -> _Txadd3W {
                _Txadd3W { w: self }
            }
            # [ doc = "Bit 12 - TxAdd for device address 4." ]
            # [ inline ( always ) ]
            pub fn txadd4(&mut self) -> _Txadd4W {
                _Txadd4W { w: self }
            }
            # [ doc = "Bit 13 - TxAdd for device address 5." ]
            # [ inline ( always ) ]
            pub fn txadd5(&mut self) -> _Txadd5W {
                _Txadd5W { w: self }
            }
            # [ doc = "Bit 14 - TxAdd for device address 6." ]
            # [ inline ( always ) ]
            pub fn txadd6(&mut self) -> _Txadd6W {
                _Txadd6W { w: self }
            }
            # [ doc = "Bit 15 - TxAdd for device address 7." ]
            # [ inline ( always ) ]
            pub fn txadd7(&mut self) -> _Txadd7W {
                _Txadd7W { w: self }
            }
        }
    }
    # [ doc = "Trim value override register 0." ]
    pub struct Override0 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Trim value override register 0." ]
    pub mod override0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Override0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Override0R {
            bits: u32,
        }
        impl Override0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Override0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Override0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Trim value override 0." ]
            # [ inline ( always ) ]
            pub fn override0(&self) -> Override0R {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                Override0R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Trim value override 0." ]
            # [ inline ( always ) ]
            pub fn override0(&mut self) -> _Override0W {
                _Override0W { w: self }
            }
        }
    }
    # [ doc = "Trim value override register 1." ]
    pub struct Override1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Trim value override register 1." ]
    pub mod override1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Override1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Override1R {
            bits: u32,
        }
        impl Override1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Override1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Override1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Trim value override 1." ]
            # [ inline ( always ) ]
            pub fn override1(&self) -> Override1R {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                Override1R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Trim value override 1." ]
            # [ inline ( always ) ]
            pub fn override1(&mut self) -> _Override1W {
                _Override1W { w: self }
            }
        }
    }
    # [ doc = "Trim value override register 2." ]
    pub struct Override2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Trim value override register 2." ]
    pub mod override2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Override2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Override2R {
            bits: u32,
        }
        impl Override2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Override2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Override2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Trim value override 2." ]
            # [ inline ( always ) ]
            pub fn override2(&self) -> Override2R {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                Override2R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Trim value override 2." ]
            # [ inline ( always ) ]
            pub fn override2(&mut self) -> _Override2W {
                _Override2W { w: self }
            }
        }
    }
    # [ doc = "Trim value override register 3." ]
    pub struct Override3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Trim value override register 3." ]
    pub mod override3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Override3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Override3R {
            bits: u32,
        }
        impl Override3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Override3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Override3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Trim value override 3." ]
            # [ inline ( always ) ]
            pub fn override3(&self) -> Override3R {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                Override3R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Trim value override 3." ]
            # [ inline ( always ) ]
            pub fn override3(&mut self) -> _Override3W {
                _Override3W { w: self }
            }
        }
    }
    # [ doc = "Trim value override register 4." ]
    pub struct Override4 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Trim value override register 4." ]
    pub mod override4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Override4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Override4R {
            bits: u32,
        }
        impl Override4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `ENABLE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EnableR {
            # [ doc = "Override trim values disabled." ]
            Disabled,
            # [ doc = "Override trim values enabled." ]
            Enabled,
        }
        impl EnableR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EnableR::Disabled => 0,
                    EnableR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EnableR {
                match bits {
                    0 => EnableR::Disabled,
                    1 => EnableR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EnableR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EnableR::Enabled
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Override4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Override4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 268435455;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ENABLE`" ]
        pub enum EnableW {
            # [ doc = "Override trim values disabled." ]
            Disabled,
            # [ doc = "Override trim values enabled." ]
            Enabled,
        }
        impl EnableW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EnableW::Disabled => 0,
                    EnableW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnableW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnableW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EnableW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Override trim values disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EnableW::Disabled)
            }
            # [ doc = "Override trim values enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EnableW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:27 - Trim value override 4." ]
            # [ inline ( always ) ]
            pub fn override4(&self) -> Override4R {
                let bits = {
                    const MASK: u32 = 268435455;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                Override4R { bits }
            }
            # [ doc = "Bit 31 - Enable or disable override of default trim values." ]
            # [ inline ( always ) ]
            pub fn enable(&self) -> EnableR {
                EnableR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:27 - Trim value override 4." ]
            # [ inline ( always ) ]
            pub fn override4(&mut self) -> _Override4W {
                _Override4W { w: self }
            }
            # [ doc = "Bit 31 - Enable or disable override of default trim values." ]
            # [ inline ( always ) ]
            pub fn enable(&mut self) -> _EnableW {
                _EnableW { w: self }
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "The radio." ]
pub struct Radio {
    register_block: radio::RegisterBlock,
}
impl Deref for Radio {
    type Target = radio::RegisterBlock;
    fn deref(&self) -> &radio::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Universal Asynchronous Receiver/Transmitter." ]
pub const UART0: Peripheral<Uart0> = unsafe { Peripheral::new(1073750016) };
# [ doc = "Universal Asynchronous Receiver/Transmitter." ]
pub mod uart0 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Start UART receiver." ]
        pub tasks_startrx: TasksStartrx,
        # [ doc = "0x04 - Stop UART receiver." ]
        pub tasks_stoprx: TasksStoprx,
        # [ doc = "0x08 - Start UART transmitter." ]
        pub tasks_starttx: TasksStarttx,
        # [ doc = "0x0c - Stop UART transmitter." ]
        pub tasks_stoptx: TasksStoptx,
        _reserved0: [u8; 12usize],
        # [ doc = "0x1c - Suspend UART." ]
        pub tasks_suspend: TasksSuspend,
        _reserved1: [u8; 224usize],
        # [ doc = "0x100 - CTS activated." ]
        pub events_cts: EventsCts,
        # [ doc = "0x104 - CTS deactivated." ]
        pub events_ncts: EventsNcts,
        # [ doc = "0x108 - Data received in RXD." ]
        pub events_rxdrdy: EventsRxdrdy,
        _reserved2: [u8; 16usize],
        # [ doc = "0x11c - Data sent from TXD." ]
        pub events_txdrdy: EventsTxdrdy,
        _reserved3: [u8; 4usize],
        # [ doc = "0x124 - Error detected." ]
        pub events_error: EventsError,
        _reserved4: [u8; 28usize],
        # [ doc = "0x144 - Receiver timeout." ]
        pub events_rxto: EventsRxto,
        _reserved5: [u8; 184usize],
        # [ doc = "0x200 - Shortcuts for UART." ]
        pub shorts: Shorts,
        _reserved6: [u8; 256usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved7: [u8; 372usize],
        # [ doc = "0x480 - Error source. Write error field to 1 to clear error." ]
        pub errorsrc: Errorsrc,
        _reserved8: [u8; 124usize],
        # [ doc = "0x500 - Enable UART and acquire IOs." ]
        pub enable: Enable,
        _reserved9: [u8; 4usize],
        # [ doc = "0x508 - Pin select for RTS." ]
        pub pselrts: Pselrts,
        # [ doc = "0x50c - Pin select for TXD." ]
        pub pseltxd: Pseltxd,
        # [ doc = "0x510 - Pin select for CTS." ]
        pub pselcts: Pselcts,
        # [ doc = "0x514 - Pin select for RXD." ]
        pub pselrxd: Pselrxd,
        # [ doc = "0x518 - RXD register. On read action the buffer pointer is displaced. Once read the character is consumed. If read when no character available, the UART will stop working." ]
        pub rxd: Rxd,
        # [ doc = "0x51c - TXD register." ]
        pub txd: Txd,
        _reserved10: [u8; 4usize],
        # [ doc = "0x524 - UART Baudrate." ]
        pub baudrate: Baudrate,
        _reserved11: [u8; 68usize],
        # [ doc = "0x56c - Configuration of parity and hardware flow control register." ]
        pub config: Config,
        _reserved12: [u8; 2700usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Start UART receiver." ]
    pub struct TasksStartrx {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start UART receiver." ]
    pub mod tasks_startrx {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStartrx {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop UART receiver." ]
    pub struct TasksStoprx {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop UART receiver." ]
    pub mod tasks_stoprx {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStoprx {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Start UART transmitter." ]
    pub struct TasksStarttx {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start UART transmitter." ]
    pub mod tasks_starttx {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStarttx {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop UART transmitter." ]
    pub struct TasksStoptx {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop UART transmitter." ]
    pub mod tasks_stoptx {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStoptx {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Suspend UART." ]
    pub struct TasksSuspend {
        register: VolatileCell<u32>,
    }
    # [ doc = "Suspend UART." ]
    pub mod tasks_suspend {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksSuspend {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "CTS activated." ]
    pub struct EventsCts {
        register: VolatileCell<u32>,
    }
    # [ doc = "CTS activated." ]
    pub mod events_cts {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsCts {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "CTS deactivated." ]
    pub struct EventsNcts {
        register: VolatileCell<u32>,
    }
    # [ doc = "CTS deactivated." ]
    pub mod events_ncts {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsNcts {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Data received in RXD." ]
    pub struct EventsRxdrdy {
        register: VolatileCell<u32>,
    }
    # [ doc = "Data received in RXD." ]
    pub mod events_rxdrdy {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsRxdrdy {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Data sent from TXD." ]
    pub struct EventsTxdrdy {
        register: VolatileCell<u32>,
    }
    # [ doc = "Data sent from TXD." ]
    pub mod events_txdrdy {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsTxdrdy {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Error detected." ]
    pub struct EventsError {
        register: VolatileCell<u32>,
    }
    # [ doc = "Error detected." ]
    pub mod events_error {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsError {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Receiver timeout." ]
    pub struct EventsRxto {
        register: VolatileCell<u32>,
    }
    # [ doc = "Receiver timeout." ]
    pub mod events_rxto {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsRxto {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Shortcuts for UART." ]
    pub struct Shorts {
        register: VolatileCell<u32>,
    }
    # [ doc = "Shortcuts for UART." ]
    pub mod shorts {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Shorts {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `CTS_STARTRX`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CtsStartrxR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl CtsStartrxR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CtsStartrxR::Disabled => 0,
                    CtsStartrxR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CtsStartrxR {
                match bits {
                    0 => CtsStartrxR::Disabled,
                    1 => CtsStartrxR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == CtsStartrxR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == CtsStartrxR::Enabled
            }
        }
        # [ doc = "Possible values of the field `NCTS_STOPRX`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum NctsStoprxR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl NctsStoprxR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    NctsStoprxR::Disabled => 0,
                    NctsStoprxR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> NctsStoprxR {
                match bits {
                    0 => NctsStoprxR::Disabled,
                    1 => NctsStoprxR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == NctsStoprxR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == NctsStoprxR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `CTS_STARTRX`" ]
        pub enum CtsStartrxW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl CtsStartrxW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CtsStartrxW::Disabled => 0,
                    CtsStartrxW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CtsStartrxW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CtsStartrxW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CtsStartrxW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CtsStartrxW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CtsStartrxW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `NCTS_STOPRX`" ]
        pub enum NctsStoprxW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl NctsStoprxW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    NctsStoprxW::Disabled => 0,
                    NctsStoprxW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NctsStoprxW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NctsStoprxW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: NctsStoprxW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(NctsStoprxW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(NctsStoprxW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 3 - Shortcut between CTS event and STARTRX task." ]
            # [ inline ( always ) ]
            pub fn cts_startrx(&self) -> CtsStartrxR {
                CtsStartrxR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Shortcut between NCTS event and STOPRX task." ]
            # [ inline ( always ) ]
            pub fn ncts_stoprx(&self) -> NctsStoprxR {
                NctsStoprxR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 3 - Shortcut between CTS event and STARTRX task." ]
            # [ inline ( always ) ]
            pub fn cts_startrx(&mut self) -> _CtsStartrxW {
                _CtsStartrxW { w: self }
            }
            # [ doc = "Bit 4 - Shortcut between NCTS event and STOPRX task." ]
            # [ inline ( always ) ]
            pub fn ncts_stoprx(&mut self) -> _NctsStoprxW {
                _NctsStoprxW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `CTS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CtsR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl CtsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CtsR::Disabled => 0,
                    CtsR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CtsR {
                match bits {
                    0 => CtsR::Disabled,
                    1 => CtsR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == CtsR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == CtsR::Enabled
            }
        }
        # [ doc = "Possible values of the field `NCTS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum NctsR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl NctsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    NctsR::Disabled => 0,
                    NctsR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> NctsR {
                match bits {
                    0 => NctsR::Disabled,
                    1 => NctsR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == NctsR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == NctsR::Enabled
            }
        }
        # [ doc = "Possible values of the field `RXDRDY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RxdrdyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl RxdrdyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RxdrdyR::Disabled => 0,
                    RxdrdyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RxdrdyR {
                match bits {
                    0 => RxdrdyR::Disabled,
                    1 => RxdrdyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == RxdrdyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == RxdrdyR::Enabled
            }
        }
        # [ doc = "Possible values of the field `TXDRDY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TxdrdyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl TxdrdyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TxdrdyR::Disabled => 0,
                    TxdrdyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TxdrdyR {
                match bits {
                    0 => TxdrdyR::Disabled,
                    1 => TxdrdyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == TxdrdyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == TxdrdyR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ERROR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ErrorR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ErrorR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ErrorR::Disabled => 0,
                    ErrorR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ErrorR {
                match bits {
                    0 => ErrorR::Disabled,
                    1 => ErrorR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ErrorR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ErrorR::Enabled
            }
        }
        # [ doc = "Possible values of the field `RXTO`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RxtoR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl RxtoR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RxtoR::Disabled => 0,
                    RxtoR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RxtoR {
                match bits {
                    0 => RxtoR::Disabled,
                    1 => RxtoR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == RxtoR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == RxtoR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `CTS`" ]
        pub enum CtsW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl CtsW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CtsW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CtsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CtsW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CtsW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(CtsW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `NCTS`" ]
        pub enum NctsW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl NctsW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    NctsW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NctsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NctsW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: NctsW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(NctsW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RXDRDY`" ]
        pub enum RxdrdyW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl RxdrdyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RxdrdyW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RxdrdyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxdrdyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RxdrdyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(RxdrdyW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TXDRDY`" ]
        pub enum TxdrdyW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl TxdrdyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TxdrdyW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TxdrdyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxdrdyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TxdrdyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(TxdrdyW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ERROR`" ]
        pub enum ErrorW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl ErrorW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ErrorW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ErrorW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ErrorW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ErrorW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(ErrorW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RXTO`" ]
        pub enum RxtoW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl RxtoW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RxtoW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RxtoW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxtoW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RxtoW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(RxtoW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable interrupt on CTS event." ]
            # [ inline ( always ) ]
            pub fn cts(&self) -> CtsR {
                CtsR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Enable interrupt on NCTS event." ]
            # [ inline ( always ) ]
            pub fn ncts(&self) -> NctsR {
                NctsR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Enable interrupt on RXRDY event." ]
            # [ inline ( always ) ]
            pub fn rxdrdy(&self) -> RxdrdyR {
                RxdrdyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Enable interrupt on TXRDY event." ]
            # [ inline ( always ) ]
            pub fn txdrdy(&self) -> TxdrdyR {
                TxdrdyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Enable interrupt on ERROR event." ]
            # [ inline ( always ) ]
            pub fn error(&self) -> ErrorR {
                ErrorR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Enable interrupt on RXTO event." ]
            # [ inline ( always ) ]
            pub fn rxto(&self) -> RxtoR {
                RxtoR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable interrupt on CTS event." ]
            # [ inline ( always ) ]
            pub fn cts(&mut self) -> _CtsW {
                _CtsW { w: self }
            }
            # [ doc = "Bit 1 - Enable interrupt on NCTS event." ]
            # [ inline ( always ) ]
            pub fn ncts(&mut self) -> _NctsW {
                _NctsW { w: self }
            }
            # [ doc = "Bit 2 - Enable interrupt on RXRDY event." ]
            # [ inline ( always ) ]
            pub fn rxdrdy(&mut self) -> _RxdrdyW {
                _RxdrdyW { w: self }
            }
            # [ doc = "Bit 7 - Enable interrupt on TXRDY event." ]
            # [ inline ( always ) ]
            pub fn txdrdy(&mut self) -> _TxdrdyW {
                _TxdrdyW { w: self }
            }
            # [ doc = "Bit 9 - Enable interrupt on ERROR event." ]
            # [ inline ( always ) ]
            pub fn error(&mut self) -> _ErrorW {
                _ErrorW { w: self }
            }
            # [ doc = "Bit 17 - Enable interrupt on RXTO event." ]
            # [ inline ( always ) ]
            pub fn rxto(&mut self) -> _RxtoW {
                _RxtoW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `CTS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CtsR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl CtsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CtsR::Disabled => 0,
                    CtsR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CtsR {
                match bits {
                    0 => CtsR::Disabled,
                    1 => CtsR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == CtsR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == CtsR::Enabled
            }
        }
        # [ doc = "Possible values of the field `NCTS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum NctsR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl NctsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    NctsR::Disabled => 0,
                    NctsR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> NctsR {
                match bits {
                    0 => NctsR::Disabled,
                    1 => NctsR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == NctsR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == NctsR::Enabled
            }
        }
        # [ doc = "Possible values of the field `RXDRDY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RxdrdyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl RxdrdyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RxdrdyR::Disabled => 0,
                    RxdrdyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RxdrdyR {
                match bits {
                    0 => RxdrdyR::Disabled,
                    1 => RxdrdyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == RxdrdyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == RxdrdyR::Enabled
            }
        }
        # [ doc = "Possible values of the field `TXDRDY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TxdrdyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl TxdrdyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TxdrdyR::Disabled => 0,
                    TxdrdyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TxdrdyR {
                match bits {
                    0 => TxdrdyR::Disabled,
                    1 => TxdrdyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == TxdrdyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == TxdrdyR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ERROR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ErrorR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ErrorR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ErrorR::Disabled => 0,
                    ErrorR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ErrorR {
                match bits {
                    0 => ErrorR::Disabled,
                    1 => ErrorR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ErrorR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ErrorR::Enabled
            }
        }
        # [ doc = "Possible values of the field `RXTO`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RxtoR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl RxtoR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RxtoR::Disabled => 0,
                    RxtoR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RxtoR {
                match bits {
                    0 => RxtoR::Disabled,
                    1 => RxtoR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == RxtoR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == RxtoR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `CTS`" ]
        pub enum CtsW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl CtsW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CtsW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CtsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CtsW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CtsW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(CtsW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `NCTS`" ]
        pub enum NctsW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl NctsW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    NctsW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NctsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NctsW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: NctsW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(NctsW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RXDRDY`" ]
        pub enum RxdrdyW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl RxdrdyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RxdrdyW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RxdrdyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxdrdyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RxdrdyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(RxdrdyW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TXDRDY`" ]
        pub enum TxdrdyW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl TxdrdyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TxdrdyW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TxdrdyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxdrdyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TxdrdyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(TxdrdyW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ERROR`" ]
        pub enum ErrorW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl ErrorW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ErrorW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ErrorW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ErrorW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ErrorW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(ErrorW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RXTO`" ]
        pub enum RxtoW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl RxtoW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RxtoW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RxtoW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxtoW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RxtoW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(RxtoW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable interrupt on CTS event." ]
            # [ inline ( always ) ]
            pub fn cts(&self) -> CtsR {
                CtsR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Disable interrupt on NCTS event." ]
            # [ inline ( always ) ]
            pub fn ncts(&self) -> NctsR {
                NctsR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Disable interrupt on RXRDY event." ]
            # [ inline ( always ) ]
            pub fn rxdrdy(&self) -> RxdrdyR {
                RxdrdyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Disable interrupt on TXRDY event." ]
            # [ inline ( always ) ]
            pub fn txdrdy(&self) -> TxdrdyR {
                TxdrdyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Disable interrupt on ERROR event." ]
            # [ inline ( always ) ]
            pub fn error(&self) -> ErrorR {
                ErrorR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Disable interrupt on RXTO event." ]
            # [ inline ( always ) ]
            pub fn rxto(&self) -> RxtoR {
                RxtoR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable interrupt on CTS event." ]
            # [ inline ( always ) ]
            pub fn cts(&mut self) -> _CtsW {
                _CtsW { w: self }
            }
            # [ doc = "Bit 1 - Disable interrupt on NCTS event." ]
            # [ inline ( always ) ]
            pub fn ncts(&mut self) -> _NctsW {
                _NctsW { w: self }
            }
            # [ doc = "Bit 2 - Disable interrupt on RXRDY event." ]
            # [ inline ( always ) ]
            pub fn rxdrdy(&mut self) -> _RxdrdyW {
                _RxdrdyW { w: self }
            }
            # [ doc = "Bit 7 - Disable interrupt on TXRDY event." ]
            # [ inline ( always ) ]
            pub fn txdrdy(&mut self) -> _TxdrdyW {
                _TxdrdyW { w: self }
            }
            # [ doc = "Bit 9 - Disable interrupt on ERROR event." ]
            # [ inline ( always ) ]
            pub fn error(&mut self) -> _ErrorW {
                _ErrorW { w: self }
            }
            # [ doc = "Bit 17 - Disable interrupt on RXTO event." ]
            # [ inline ( always ) ]
            pub fn rxto(&mut self) -> _RxtoW {
                _RxtoW { w: self }
            }
        }
    }
    # [ doc = "Error source. Write error field to 1 to clear error." ]
    pub struct Errorsrc {
        register: VolatileCell<u32>,
    }
    # [ doc = "Error source. Write error field to 1 to clear error." ]
    pub mod errorsrc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Errorsrc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `OVERRUN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OverrunR {
            # [ doc = "Error not present." ]
            NotPresent,
            # [ doc = "Error present." ]
            Present,
        }
        impl OverrunR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OverrunR::NotPresent => 0,
                    OverrunR::Present => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OverrunR {
                match bits {
                    0 => OverrunR::NotPresent,
                    1 => OverrunR::Present,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotPresent`" ]
            # [ inline ( always ) ]
            pub fn is_not_present(&self) -> bool {
                *self == OverrunR::NotPresent
            }
            # [ doc = "Checks if the value of the field is `Present`" ]
            # [ inline ( always ) ]
            pub fn is_present(&self) -> bool {
                *self == OverrunR::Present
            }
        }
        # [ doc = "Possible values of the field `PARITY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ParityR {
            # [ doc = "Error not present." ]
            NotPresent,
            # [ doc = "Error present." ]
            Present,
        }
        impl ParityR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ParityR::NotPresent => 0,
                    ParityR::Present => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ParityR {
                match bits {
                    0 => ParityR::NotPresent,
                    1 => ParityR::Present,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotPresent`" ]
            # [ inline ( always ) ]
            pub fn is_not_present(&self) -> bool {
                *self == ParityR::NotPresent
            }
            # [ doc = "Checks if the value of the field is `Present`" ]
            # [ inline ( always ) ]
            pub fn is_present(&self) -> bool {
                *self == ParityR::Present
            }
        }
        # [ doc = "Possible values of the field `FRAMING`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum FramingR {
            # [ doc = "Error not present." ]
            NotPresent,
            # [ doc = "Error present." ]
            Present,
        }
        impl FramingR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    FramingR::NotPresent => 0,
                    FramingR::Present => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> FramingR {
                match bits {
                    0 => FramingR::NotPresent,
                    1 => FramingR::Present,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotPresent`" ]
            # [ inline ( always ) ]
            pub fn is_not_present(&self) -> bool {
                *self == FramingR::NotPresent
            }
            # [ doc = "Checks if the value of the field is `Present`" ]
            # [ inline ( always ) ]
            pub fn is_present(&self) -> bool {
                *self == FramingR::Present
            }
        }
        # [ doc = "Possible values of the field `BREAK`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum BreakR {
            # [ doc = "Error not present." ]
            NotPresent,
            # [ doc = "Error present." ]
            Present,
        }
        impl BreakR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    BreakR::NotPresent => 0,
                    BreakR::Present => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> BreakR {
                match bits {
                    0 => BreakR::NotPresent,
                    1 => BreakR::Present,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotPresent`" ]
            # [ inline ( always ) ]
            pub fn is_not_present(&self) -> bool {
                *self == BreakR::NotPresent
            }
            # [ doc = "Checks if the value of the field is `Present`" ]
            # [ inline ( always ) ]
            pub fn is_present(&self) -> bool {
                *self == BreakR::Present
            }
        }
        # [ doc = "Values that can be written to the field `OVERRUN`" ]
        pub enum OverrunW {
            # [ doc = "Clear error on write." ]
            Clear,
        }
        impl OverrunW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OverrunW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OverrunW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OverrunW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OverrunW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Clear error on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(OverrunW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PARITY`" ]
        pub enum ParityW {
            # [ doc = "Clear error on write." ]
            Clear,
        }
        impl ParityW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ParityW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ParityW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ParityW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ParityW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Clear error on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(ParityW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `FRAMING`" ]
        pub enum FramingW {
            # [ doc = "Clear error on write." ]
            Clear,
        }
        impl FramingW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FramingW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FramingW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FramingW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: FramingW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Clear error on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(FramingW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BREAK`" ]
        pub enum BreakW {
            # [ doc = "Clear error on write." ]
            Clear,
        }
        impl BreakW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BreakW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BreakW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BreakW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: BreakW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Clear error on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(BreakW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - A start bit is received while the previous data still lies in RXD. (Data loss)." ]
            # [ inline ( always ) ]
            pub fn overrun(&self) -> OverrunR {
                OverrunR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - A character with bad parity is received. Only checked if HW parity control is enabled." ]
            # [ inline ( always ) ]
            pub fn parity(&self) -> ParityR {
                ParityR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - A valid stop bit is not detected on the serial data input after all bits in a character have been received." ]
            # [ inline ( always ) ]
            pub fn framing(&self) -> FramingR {
                FramingR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - The serial data input is '0' for longer than the length of a data frame." ]
            # [ inline ( always ) ]
            pub fn break_(&self) -> BreakR {
                BreakR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - A start bit is received while the previous data still lies in RXD. (Data loss)." ]
            # [ inline ( always ) ]
            pub fn overrun(&mut self) -> _OverrunW {
                _OverrunW { w: self }
            }
            # [ doc = "Bit 1 - A character with bad parity is received. Only checked if HW parity control is enabled." ]
            # [ inline ( always ) ]
            pub fn parity(&mut self) -> _ParityW {
                _ParityW { w: self }
            }
            # [ doc = "Bit 2 - A valid stop bit is not detected on the serial data input after all bits in a character have been received." ]
            # [ inline ( always ) ]
            pub fn framing(&mut self) -> _FramingW {
                _FramingW { w: self }
            }
            # [ doc = "Bit 3 - The serial data input is '0' for longer than the length of a data frame." ]
            # [ inline ( always ) ]
            pub fn break_(&mut self) -> _BreakW {
                _BreakW { w: self }
            }
        }
    }
    # [ doc = "Enable UART and acquire IOs." ]
    pub struct Enable {
        register: VolatileCell<u32>,
    }
    # [ doc = "Enable UART and acquire IOs." ]
    pub mod enable {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Enable {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ENABLE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EnableR {
            # [ doc = "UART disabled." ]
            Disabled,
            # [ doc = "UART enabled." ]
            Enabled,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl EnableR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EnableR::Disabled => 0,
                    EnableR::Enabled => 4,
                    EnableR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EnableR {
                match bits {
                    0 => EnableR::Disabled,
                    4 => EnableR::Enabled,
                    i => EnableR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EnableR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EnableR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `ENABLE`" ]
        pub enum EnableW {
            # [ doc = "UART disabled." ]
            Disabled,
            # [ doc = "UART enabled." ]
            Enabled,
        }
        impl EnableW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EnableW::Disabled => 0,
                    EnableW::Enabled => 4,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnableW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnableW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EnableW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "UART disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EnableW::Disabled)
            }
            # [ doc = "UART enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EnableW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:2 - Enable or disable UART and acquire IOs." ]
            # [ inline ( always ) ]
            pub fn enable(&self) -> EnableR {
                EnableR::_from(
                    {
                        const MASK: u8 = 7;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:2 - Enable or disable UART and acquire IOs." ]
            # [ inline ( always ) ]
            pub fn enable(&mut self) -> _EnableW {
                _EnableW { w: self }
            }
        }
    }
    # [ doc = "Pin select for RTS." ]
    pub struct Pselrts {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin select for RTS." ]
    pub mod pselrts {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pselrts {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pin select for TXD." ]
    pub struct Pseltxd {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin select for TXD." ]
    pub mod pseltxd {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pseltxd {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pin select for CTS." ]
    pub struct Pselcts {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin select for CTS." ]
    pub mod pselcts {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pselcts {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pin select for RXD." ]
    pub struct Pselrxd {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin select for RXD." ]
    pub mod pselrxd {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pselrxd {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "RXD register. On read action the buffer pointer is displaced. Once read the character is consumed. If read when no character available, the UART will stop working." ]
    pub struct Rxd {
        register: VolatileCell<u32>,
    }
    # [ doc = "RXD register. On read action the buffer pointer is displaced. Once read the character is consumed. If read when no character available, the UART will stop working." ]
    pub mod rxd {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Rxd {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxdR {
            bits: u8,
        }
        impl RxdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - RX data from previous transfer. Double buffered." ]
            # [ inline ( always ) ]
            pub fn rxd(&self) -> RxdR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxdR { bits }
            }
        }
    }
    # [ doc = "TXD register." ]
    pub struct Txd {
        register: VolatileCell<u32>,
    }
    # [ doc = "TXD register." ]
    pub mod txd {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Txd {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TxdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - TX data for transfer." ]
            # [ inline ( always ) ]
            pub fn txd(&mut self) -> _TxdW {
                _TxdW { w: self }
            }
        }
    }
    # [ doc = "UART Baudrate." ]
    pub struct Baudrate {
        register: VolatileCell<u32>,
    }
    # [ doc = "UART Baudrate." ]
    pub mod baudrate {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Baudrate {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `BAUDRATE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum BaudrateR {
            # [ doc = "1200 baud." ]
            Baud1200,
            # [ doc = "2400 baud." ]
            Baud2400,
            # [ doc = "4800 baud." ]
            Baud4800,
            # [ doc = "9600 baud." ]
            Baud9600,
            # [ doc = "14400 baud." ]
            Baud14400,
            # [ doc = "19200 baud." ]
            Baud19200,
            # [ doc = "28800 baud." ]
            Baud28800,
            # [ doc = "38400 baud." ]
            Baud38400,
            # [ doc = "57600 baud." ]
            Baud57600,
            # [ doc = "76800 baud." ]
            Baud76800,
            # [ doc = "115200 baud." ]
            Baud115200,
            # [ doc = "230400 baud." ]
            Baud230400,
            # [ doc = "250000 baud." ]
            Baud250000,
            # [ doc = "460800 baud." ]
            Baud460800,
            # [ doc = "921600 baud." ]
            Baud921600,
            # [ doc = "1M baud." ]
            Baud1m,
            # [ doc = r" Reserved" ]
            _Reserved(u32),
        }
        impl BaudrateR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                match *self {
                    BaudrateR::Baud1200 => 323584,
                    BaudrateR::Baud2400 => 643072,
                    BaudrateR::Baud4800 => 1290240,
                    BaudrateR::Baud9600 => 2576384,
                    BaudrateR::Baud14400 => 3866624,
                    BaudrateR::Baud19200 => 5152768,
                    BaudrateR::Baud28800 => 7729152,
                    BaudrateR::Baud38400 => 10309632,
                    BaudrateR::Baud57600 => 15462400,
                    BaudrateR::Baud76800 => 20615168,
                    BaudrateR::Baud115200 => 30924800,
                    BaudrateR::Baud230400 => 61845504,
                    BaudrateR::Baud250000 => 67108864,
                    BaudrateR::Baud460800 => 123695104,
                    BaudrateR::Baud921600 => 247386112,
                    BaudrateR::Baud1m => 268435456,
                    BaudrateR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u32) -> BaudrateR {
                match bits {
                    323584 => BaudrateR::Baud1200,
                    643072 => BaudrateR::Baud2400,
                    1290240 => BaudrateR::Baud4800,
                    2576384 => BaudrateR::Baud9600,
                    3866624 => BaudrateR::Baud14400,
                    5152768 => BaudrateR::Baud19200,
                    7729152 => BaudrateR::Baud28800,
                    10309632 => BaudrateR::Baud38400,
                    15462400 => BaudrateR::Baud57600,
                    20615168 => BaudrateR::Baud76800,
                    30924800 => BaudrateR::Baud115200,
                    61845504 => BaudrateR::Baud230400,
                    67108864 => BaudrateR::Baud250000,
                    123695104 => BaudrateR::Baud460800,
                    247386112 => BaudrateR::Baud921600,
                    268435456 => BaudrateR::Baud1m,
                    i => BaudrateR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Baud1200`" ]
            # [ inline ( always ) ]
            pub fn is_baud1200(&self) -> bool {
                *self == BaudrateR::Baud1200
            }
            # [ doc = "Checks if the value of the field is `Baud2400`" ]
            # [ inline ( always ) ]
            pub fn is_baud2400(&self) -> bool {
                *self == BaudrateR::Baud2400
            }
            # [ doc = "Checks if the value of the field is `Baud4800`" ]
            # [ inline ( always ) ]
            pub fn is_baud4800(&self) -> bool {
                *self == BaudrateR::Baud4800
            }
            # [ doc = "Checks if the value of the field is `Baud9600`" ]
            # [ inline ( always ) ]
            pub fn is_baud9600(&self) -> bool {
                *self == BaudrateR::Baud9600
            }
            # [ doc = "Checks if the value of the field is `Baud14400`" ]
            # [ inline ( always ) ]
            pub fn is_baud14400(&self) -> bool {
                *self == BaudrateR::Baud14400
            }
            # [ doc = "Checks if the value of the field is `Baud19200`" ]
            # [ inline ( always ) ]
            pub fn is_baud19200(&self) -> bool {
                *self == BaudrateR::Baud19200
            }
            # [ doc = "Checks if the value of the field is `Baud28800`" ]
            # [ inline ( always ) ]
            pub fn is_baud28800(&self) -> bool {
                *self == BaudrateR::Baud28800
            }
            # [ doc = "Checks if the value of the field is `Baud38400`" ]
            # [ inline ( always ) ]
            pub fn is_baud38400(&self) -> bool {
                *self == BaudrateR::Baud38400
            }
            # [ doc = "Checks if the value of the field is `Baud57600`" ]
            # [ inline ( always ) ]
            pub fn is_baud57600(&self) -> bool {
                *self == BaudrateR::Baud57600
            }
            # [ doc = "Checks if the value of the field is `Baud76800`" ]
            # [ inline ( always ) ]
            pub fn is_baud76800(&self) -> bool {
                *self == BaudrateR::Baud76800
            }
            # [ doc = "Checks if the value of the field is `Baud115200`" ]
            # [ inline ( always ) ]
            pub fn is_baud115200(&self) -> bool {
                *self == BaudrateR::Baud115200
            }
            # [ doc = "Checks if the value of the field is `Baud230400`" ]
            # [ inline ( always ) ]
            pub fn is_baud230400(&self) -> bool {
                *self == BaudrateR::Baud230400
            }
            # [ doc = "Checks if the value of the field is `Baud250000`" ]
            # [ inline ( always ) ]
            pub fn is_baud250000(&self) -> bool {
                *self == BaudrateR::Baud250000
            }
            # [ doc = "Checks if the value of the field is `Baud460800`" ]
            # [ inline ( always ) ]
            pub fn is_baud460800(&self) -> bool {
                *self == BaudrateR::Baud460800
            }
            # [ doc = "Checks if the value of the field is `Baud921600`" ]
            # [ inline ( always ) ]
            pub fn is_baud921600(&self) -> bool {
                *self == BaudrateR::Baud921600
            }
            # [ doc = "Checks if the value of the field is `Baud1m`" ]
            # [ inline ( always ) ]
            pub fn is_baud1m(&self) -> bool {
                *self == BaudrateR::Baud1m
            }
        }
        # [ doc = "Values that can be written to the field `BAUDRATE`" ]
        pub enum BaudrateW {
            # [ doc = "1200 baud." ]
            Baud1200,
            # [ doc = "2400 baud." ]
            Baud2400,
            # [ doc = "4800 baud." ]
            Baud4800,
            # [ doc = "9600 baud." ]
            Baud9600,
            # [ doc = "14400 baud." ]
            Baud14400,
            # [ doc = "19200 baud." ]
            Baud19200,
            # [ doc = "28800 baud." ]
            Baud28800,
            # [ doc = "38400 baud." ]
            Baud38400,
            # [ doc = "57600 baud." ]
            Baud57600,
            # [ doc = "76800 baud." ]
            Baud76800,
            # [ doc = "115200 baud." ]
            Baud115200,
            # [ doc = "230400 baud." ]
            Baud230400,
            # [ doc = "250000 baud." ]
            Baud250000,
            # [ doc = "460800 baud." ]
            Baud460800,
            # [ doc = "921600 baud." ]
            Baud921600,
            # [ doc = "1M baud." ]
            Baud1m,
        }
        impl BaudrateW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u32 {
                match *self {
                    BaudrateW::Baud1200 => 323584,
                    BaudrateW::Baud2400 => 643072,
                    BaudrateW::Baud4800 => 1290240,
                    BaudrateW::Baud9600 => 2576384,
                    BaudrateW::Baud14400 => 3866624,
                    BaudrateW::Baud19200 => 5152768,
                    BaudrateW::Baud28800 => 7729152,
                    BaudrateW::Baud38400 => 10309632,
                    BaudrateW::Baud57600 => 15462400,
                    BaudrateW::Baud76800 => 20615168,
                    BaudrateW::Baud115200 => 30924800,
                    BaudrateW::Baud230400 => 61845504,
                    BaudrateW::Baud250000 => 67108864,
                    BaudrateW::Baud460800 => 123695104,
                    BaudrateW::Baud921600 => 247386112,
                    BaudrateW::Baud1m => 268435456,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BaudrateW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BaudrateW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: BaudrateW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "1200 baud." ]
            # [ inline ( always ) ]
            pub fn baud1200(self) -> &'a mut W {
                self.variant(BaudrateW::Baud1200)
            }
            # [ doc = "2400 baud." ]
            # [ inline ( always ) ]
            pub fn baud2400(self) -> &'a mut W {
                self.variant(BaudrateW::Baud2400)
            }
            # [ doc = "4800 baud." ]
            # [ inline ( always ) ]
            pub fn baud4800(self) -> &'a mut W {
                self.variant(BaudrateW::Baud4800)
            }
            # [ doc = "9600 baud." ]
            # [ inline ( always ) ]
            pub fn baud9600(self) -> &'a mut W {
                self.variant(BaudrateW::Baud9600)
            }
            # [ doc = "14400 baud." ]
            # [ inline ( always ) ]
            pub fn baud14400(self) -> &'a mut W {
                self.variant(BaudrateW::Baud14400)
            }
            # [ doc = "19200 baud." ]
            # [ inline ( always ) ]
            pub fn baud19200(self) -> &'a mut W {
                self.variant(BaudrateW::Baud19200)
            }
            # [ doc = "28800 baud." ]
            # [ inline ( always ) ]
            pub fn baud28800(self) -> &'a mut W {
                self.variant(BaudrateW::Baud28800)
            }
            # [ doc = "38400 baud." ]
            # [ inline ( always ) ]
            pub fn baud38400(self) -> &'a mut W {
                self.variant(BaudrateW::Baud38400)
            }
            # [ doc = "57600 baud." ]
            # [ inline ( always ) ]
            pub fn baud57600(self) -> &'a mut W {
                self.variant(BaudrateW::Baud57600)
            }
            # [ doc = "76800 baud." ]
            # [ inline ( always ) ]
            pub fn baud76800(self) -> &'a mut W {
                self.variant(BaudrateW::Baud76800)
            }
            # [ doc = "115200 baud." ]
            # [ inline ( always ) ]
            pub fn baud115200(self) -> &'a mut W {
                self.variant(BaudrateW::Baud115200)
            }
            # [ doc = "230400 baud." ]
            # [ inline ( always ) ]
            pub fn baud230400(self) -> &'a mut W {
                self.variant(BaudrateW::Baud230400)
            }
            # [ doc = "250000 baud." ]
            # [ inline ( always ) ]
            pub fn baud250000(self) -> &'a mut W {
                self.variant(BaudrateW::Baud250000)
            }
            # [ doc = "460800 baud." ]
            # [ inline ( always ) ]
            pub fn baud460800(self) -> &'a mut W {
                self.variant(BaudrateW::Baud460800)
            }
            # [ doc = "921600 baud." ]
            # [ inline ( always ) ]
            pub fn baud921600(self) -> &'a mut W {
                self.variant(BaudrateW::Baud921600)
            }
            # [ doc = "1M baud." ]
            # [ inline ( always ) ]
            pub fn baud1m(self) -> &'a mut W {
                self.variant(BaudrateW::Baud1m)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - UART baudrate." ]
            # [ inline ( always ) ]
            pub fn baudrate(&self) -> BaudrateR {
                BaudrateR::_from(
                    {
                        const MASK: u32 = 4294967295;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u32
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - UART baudrate." ]
            # [ inline ( always ) ]
            pub fn baudrate(&mut self) -> _BaudrateW {
                _BaudrateW { w: self }
            }
        }
    }
    # [ doc = "Configuration of parity and hardware flow control register." ]
    pub struct Config {
        register: VolatileCell<u32>,
    }
    # [ doc = "Configuration of parity and hardware flow control register." ]
    pub mod config {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Config {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `HWFC`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum HwfcR {
            # [ doc = "Hardware flow control disabled." ]
            Disabled,
            # [ doc = "Hardware flow control enabled." ]
            Enabled,
        }
        impl HwfcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    HwfcR::Disabled => 0,
                    HwfcR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> HwfcR {
                match bits {
                    0 => HwfcR::Disabled,
                    1 => HwfcR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == HwfcR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == HwfcR::Enabled
            }
        }
        # [ doc = "Possible values of the field `PARITY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ParityR {
            # [ doc = "Parity bit excluded." ]
            Excluded,
            # [ doc = "Parity bit included." ]
            Included,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl ParityR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ParityR::Excluded => 0,
                    ParityR::Included => 7,
                    ParityR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ParityR {
                match bits {
                    0 => ParityR::Excluded,
                    7 => ParityR::Included,
                    i => ParityR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == ParityR::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == ParityR::Included
            }
        }
        # [ doc = "Values that can be written to the field `HWFC`" ]
        pub enum HwfcW {
            # [ doc = "Hardware flow control disabled." ]
            Disabled,
            # [ doc = "Hardware flow control enabled." ]
            Enabled,
        }
        impl HwfcW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    HwfcW::Disabled => 0,
                    HwfcW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HwfcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HwfcW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: HwfcW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Hardware flow control disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(HwfcW::Disabled)
            }
            # [ doc = "Hardware flow control enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(HwfcW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PARITY`" ]
        pub enum ParityW {
            # [ doc = "Parity bit excluded." ]
            Excluded,
            # [ doc = "Parity bit included." ]
            Included,
        }
        impl ParityW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ParityW::Excluded => 0,
                    ParityW::Included => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ParityW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ParityW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ParityW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Parity bit excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(ParityW::Excluded)
            }
            # [ doc = "Parity bit included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(ParityW::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Hardware flow control." ]
            # [ inline ( always ) ]
            pub fn hwfc(&self) -> HwfcR {
                HwfcR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bits 1:3 - Include parity bit." ]
            # [ inline ( always ) ]
            pub fn parity(&self) -> ParityR {
                ParityR::_from(
                    {
                        const MASK: u8 = 7;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Hardware flow control." ]
            # [ inline ( always ) ]
            pub fn hwfc(&mut self) -> _HwfcW {
                _HwfcW { w: self }
            }
            # [ doc = "Bits 1:3 - Include parity bit." ]
            # [ inline ( always ) ]
            pub fn parity(&mut self) -> _ParityW {
                _ParityW { w: self }
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "Universal Asynchronous Receiver/Transmitter." ]
pub struct Uart0 {
    register_block: uart0::RegisterBlock,
}
impl Deref for Uart0 {
    type Target = uart0::RegisterBlock;
    fn deref(&self) -> &uart0::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "SPI master 0." ]
pub const SPI0: Peripheral<Spi0> = unsafe { Peripheral::new(1073754112) };
# [ doc = "SPI master 0." ]
pub mod spi0 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 264usize],
        # [ doc = "0x108 - TXD byte sent and RXD byte received." ]
        pub events_ready: EventsReady,
        _reserved1: [u8; 504usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved2: [u8; 500usize],
        # [ doc = "0x500 - Enable SPI." ]
        pub enable: Enable,
        _reserved3: [u8; 4usize],
        # [ doc = "0x508 - Pin select for SCK." ]
        pub pselsck: Pselsck,
        # [ doc = "0x50c - Pin select for MOSI." ]
        pub pselmosi: Pselmosi,
        # [ doc = "0x510 - Pin select for MISO." ]
        pub pselmiso: Pselmiso,
        _reserved4: [u8; 4usize],
        # [ doc = "0x518 - RX data." ]
        pub rxd: Rxd,
        # [ doc = "0x51c - TX data." ]
        pub txd: Txd,
        _reserved5: [u8; 4usize],
        # [ doc = "0x524 - SPI frequency" ]
        pub frequency: Frequency,
        _reserved6: [u8; 44usize],
        # [ doc = "0x554 - Configuration register." ]
        pub config: Config,
        _reserved7: [u8; 2724usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "TXD byte sent and RXD byte received." ]
    pub struct EventsReady {
        register: VolatileCell<u32>,
    }
    # [ doc = "TXD byte sent and RXD byte received." ]
    pub mod events_ready {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsReady {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `READY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ReadyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ReadyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ReadyR::Disabled => 0,
                    ReadyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ReadyR {
                match bits {
                    0 => ReadyR::Disabled,
                    1 => ReadyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ReadyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ReadyR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `READY`" ]
        pub enum ReadyW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl ReadyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ReadyW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReadyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReadyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ReadyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(ReadyW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 2 - Enable interrupt on READY event." ]
            # [ inline ( always ) ]
            pub fn ready(&self) -> ReadyR {
                ReadyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 2 - Enable interrupt on READY event." ]
            # [ inline ( always ) ]
            pub fn ready(&mut self) -> _ReadyW {
                _ReadyW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `READY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ReadyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ReadyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ReadyR::Disabled => 0,
                    ReadyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ReadyR {
                match bits {
                    0 => ReadyR::Disabled,
                    1 => ReadyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ReadyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ReadyR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `READY`" ]
        pub enum ReadyW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl ReadyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ReadyW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReadyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReadyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ReadyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(ReadyW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 2 - Disable interrupt on READY event." ]
            # [ inline ( always ) ]
            pub fn ready(&self) -> ReadyR {
                ReadyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 2 - Disable interrupt on READY event." ]
            # [ inline ( always ) ]
            pub fn ready(&mut self) -> _ReadyW {
                _ReadyW { w: self }
            }
        }
    }
    # [ doc = "Enable SPI." ]
    pub struct Enable {
        register: VolatileCell<u32>,
    }
    # [ doc = "Enable SPI." ]
    pub mod enable {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Enable {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ENABLE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EnableR {
            # [ doc = "Disabled SPI." ]
            Disabled,
            # [ doc = "Enable SPI." ]
            Enabled,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl EnableR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EnableR::Disabled => 0,
                    EnableR::Enabled => 1,
                    EnableR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EnableR {
                match bits {
                    0 => EnableR::Disabled,
                    1 => EnableR::Enabled,
                    i => EnableR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EnableR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EnableR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `ENABLE`" ]
        pub enum EnableW {
            # [ doc = "Disabled SPI." ]
            Disabled,
            # [ doc = "Enable SPI." ]
            Enabled,
        }
        impl EnableW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EnableW::Disabled => 0,
                    EnableW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnableW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnableW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EnableW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disabled SPI." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EnableW::Disabled)
            }
            # [ doc = "Enable SPI." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EnableW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:2 - Enable or disable SPI." ]
            # [ inline ( always ) ]
            pub fn enable(&self) -> EnableR {
                EnableR::_from(
                    {
                        const MASK: u8 = 7;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:2 - Enable or disable SPI." ]
            # [ inline ( always ) ]
            pub fn enable(&mut self) -> _EnableW {
                _EnableW { w: self }
            }
        }
    }
    # [ doc = "Pin select for SCK." ]
    pub struct Pselsck {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin select for SCK." ]
    pub mod pselsck {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pselsck {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pin select for MOSI." ]
    pub struct Pselmosi {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin select for MOSI." ]
    pub mod pselmosi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pselmosi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pin select for MISO." ]
    pub struct Pselmiso {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin select for MISO." ]
    pub mod pselmiso {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pselmiso {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "RX data." ]
    pub struct Rxd {
        register: VolatileCell<u32>,
    }
    # [ doc = "RX data." ]
    pub mod rxd {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Rxd {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxdR {
            bits: u8,
        }
        impl RxdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - RX data from last transfer." ]
            # [ inline ( always ) ]
            pub fn rxd(&self) -> RxdR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxdR { bits }
            }
        }
    }
    # [ doc = "TX data." ]
    pub struct Txd {
        register: VolatileCell<u32>,
    }
    # [ doc = "TX data." ]
    pub mod txd {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Txd {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TxdR {
            bits: u8,
        }
        impl TxdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TxdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - TX data for next transfer." ]
            # [ inline ( always ) ]
            pub fn txd(&self) -> TxdR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxdR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - TX data for next transfer." ]
            # [ inline ( always ) ]
            pub fn txd(&mut self) -> _TxdW {
                _TxdW { w: self }
            }
        }
    }
    # [ doc = "SPI frequency" ]
    pub struct Frequency {
        register: VolatileCell<u32>,
    }
    # [ doc = "SPI frequency" ]
    pub mod frequency {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Frequency {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `FREQUENCY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum FrequencyR {
            # [ doc = "125kbps." ]
            K125,
            # [ doc = "250kbps." ]
            K250,
            # [ doc = "500kbps." ]
            K500,
            # [ doc = "1Mbps." ]
            M1,
            # [ doc = "2Mbps." ]
            M2,
            # [ doc = "4Mbps." ]
            M4,
            # [ doc = "8Mbps." ]
            M8,
            # [ doc = r" Reserved" ]
            _Reserved(u32),
        }
        impl FrequencyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                match *self {
                    FrequencyR::K125 => 33554432,
                    FrequencyR::K250 => 67108864,
                    FrequencyR::K500 => 134217728,
                    FrequencyR::M1 => 268435456,
                    FrequencyR::M2 => 536870912,
                    FrequencyR::M4 => 1073741824,
                    FrequencyR::M8 => 2147483648,
                    FrequencyR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u32) -> FrequencyR {
                match bits {
                    33554432 => FrequencyR::K125,
                    67108864 => FrequencyR::K250,
                    134217728 => FrequencyR::K500,
                    268435456 => FrequencyR::M1,
                    536870912 => FrequencyR::M2,
                    1073741824 => FrequencyR::M4,
                    2147483648 => FrequencyR::M8,
                    i => FrequencyR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `K125`" ]
            # [ inline ( always ) ]
            pub fn is_k125(&self) -> bool {
                *self == FrequencyR::K125
            }
            # [ doc = "Checks if the value of the field is `K250`" ]
            # [ inline ( always ) ]
            pub fn is_k250(&self) -> bool {
                *self == FrequencyR::K250
            }
            # [ doc = "Checks if the value of the field is `K500`" ]
            # [ inline ( always ) ]
            pub fn is_k500(&self) -> bool {
                *self == FrequencyR::K500
            }
            # [ doc = "Checks if the value of the field is `M1`" ]
            # [ inline ( always ) ]
            pub fn is_m1(&self) -> bool {
                *self == FrequencyR::M1
            }
            # [ doc = "Checks if the value of the field is `M2`" ]
            # [ inline ( always ) ]
            pub fn is_m2(&self) -> bool {
                *self == FrequencyR::M2
            }
            # [ doc = "Checks if the value of the field is `M4`" ]
            # [ inline ( always ) ]
            pub fn is_m4(&self) -> bool {
                *self == FrequencyR::M4
            }
            # [ doc = "Checks if the value of the field is `M8`" ]
            # [ inline ( always ) ]
            pub fn is_m8(&self) -> bool {
                *self == FrequencyR::M8
            }
        }
        # [ doc = "Values that can be written to the field `FREQUENCY`" ]
        pub enum FrequencyW {
            # [ doc = "125kbps." ]
            K125,
            # [ doc = "250kbps." ]
            K250,
            # [ doc = "500kbps." ]
            K500,
            # [ doc = "1Mbps." ]
            M1,
            # [ doc = "2Mbps." ]
            M2,
            # [ doc = "4Mbps." ]
            M4,
            # [ doc = "8Mbps." ]
            M8,
        }
        impl FrequencyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u32 {
                match *self {
                    FrequencyW::K125 => 33554432,
                    FrequencyW::K250 => 67108864,
                    FrequencyW::K500 => 134217728,
                    FrequencyW::M1 => 268435456,
                    FrequencyW::M2 => 536870912,
                    FrequencyW::M4 => 1073741824,
                    FrequencyW::M8 => 2147483648,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FrequencyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FrequencyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: FrequencyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "125kbps." ]
            # [ inline ( always ) ]
            pub fn k125(self) -> &'a mut W {
                self.variant(FrequencyW::K125)
            }
            # [ doc = "250kbps." ]
            # [ inline ( always ) ]
            pub fn k250(self) -> &'a mut W {
                self.variant(FrequencyW::K250)
            }
            # [ doc = "500kbps." ]
            # [ inline ( always ) ]
            pub fn k500(self) -> &'a mut W {
                self.variant(FrequencyW::K500)
            }
            # [ doc = "1Mbps." ]
            # [ inline ( always ) ]
            pub fn m1(self) -> &'a mut W {
                self.variant(FrequencyW::M1)
            }
            # [ doc = "2Mbps." ]
            # [ inline ( always ) ]
            pub fn m2(self) -> &'a mut W {
                self.variant(FrequencyW::M2)
            }
            # [ doc = "4Mbps." ]
            # [ inline ( always ) ]
            pub fn m4(self) -> &'a mut W {
                self.variant(FrequencyW::M4)
            }
            # [ doc = "8Mbps." ]
            # [ inline ( always ) ]
            pub fn m8(self) -> &'a mut W {
                self.variant(FrequencyW::M8)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - SPI data rate." ]
            # [ inline ( always ) ]
            pub fn frequency(&self) -> FrequencyR {
                FrequencyR::_from(
                    {
                        const MASK: u32 = 4294967295;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u32
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 67108864 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - SPI data rate." ]
            # [ inline ( always ) ]
            pub fn frequency(&mut self) -> _FrequencyW {
                _FrequencyW { w: self }
            }
        }
    }
    # [ doc = "Configuration register." ]
    pub struct Config {
        register: VolatileCell<u32>,
    }
    # [ doc = "Configuration register." ]
    pub mod config {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Config {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ORDER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OrderR {
            # [ doc = "Most significant bit transmitted out first." ]
            MsbFirst,
            # [ doc = "Least significant bit transmitted out first." ]
            LsbFirst,
        }
        impl OrderR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OrderR::MsbFirst => 0,
                    OrderR::LsbFirst => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OrderR {
                match bits {
                    0 => OrderR::MsbFirst,
                    1 => OrderR::LsbFirst,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `MsbFirst`" ]
            # [ inline ( always ) ]
            pub fn is_msb_first(&self) -> bool {
                *self == OrderR::MsbFirst
            }
            # [ doc = "Checks if the value of the field is `LsbFirst`" ]
            # [ inline ( always ) ]
            pub fn is_lsb_first(&self) -> bool {
                *self == OrderR::LsbFirst
            }
        }
        # [ doc = "Possible values of the field `CPHA`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CphaR {
            # [ doc = "Sample on leading edge of the clock. Shift serial data on trailing edge." ]
            Leading,
            # [ doc = "Sample on trailing edge of the clock. Shift serial data on leading edge." ]
            Trailing,
        }
        impl CphaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CphaR::Leading => 0,
                    CphaR::Trailing => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CphaR {
                match bits {
                    0 => CphaR::Leading,
                    1 => CphaR::Trailing,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Leading`" ]
            # [ inline ( always ) ]
            pub fn is_leading(&self) -> bool {
                *self == CphaR::Leading
            }
            # [ doc = "Checks if the value of the field is `Trailing`" ]
            # [ inline ( always ) ]
            pub fn is_trailing(&self) -> bool {
                *self == CphaR::Trailing
            }
        }
        # [ doc = "Possible values of the field `CPOL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CpolR {
            # [ doc = "Active high." ]
            ActiveHigh,
            # [ doc = "Active low." ]
            ActiveLow,
        }
        impl CpolR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CpolR::ActiveHigh => 0,
                    CpolR::ActiveLow => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CpolR {
                match bits {
                    0 => CpolR::ActiveHigh,
                    1 => CpolR::ActiveLow,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `ActiveHigh`" ]
            # [ inline ( always ) ]
            pub fn is_active_high(&self) -> bool {
                *self == CpolR::ActiveHigh
            }
            # [ doc = "Checks if the value of the field is `ActiveLow`" ]
            # [ inline ( always ) ]
            pub fn is_active_low(&self) -> bool {
                *self == CpolR::ActiveLow
            }
        }
        # [ doc = "Values that can be written to the field `ORDER`" ]
        pub enum OrderW {
            # [ doc = "Most significant bit transmitted out first." ]
            MsbFirst,
            # [ doc = "Least significant bit transmitted out first." ]
            LsbFirst,
        }
        impl OrderW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OrderW::MsbFirst => 0,
                    OrderW::LsbFirst => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OrderW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OrderW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OrderW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Most significant bit transmitted out first." ]
            # [ inline ( always ) ]
            pub fn msb_first(self) -> &'a mut W {
                self.variant(OrderW::MsbFirst)
            }
            # [ doc = "Least significant bit transmitted out first." ]
            # [ inline ( always ) ]
            pub fn lsb_first(self) -> &'a mut W {
                self.variant(OrderW::LsbFirst)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CPHA`" ]
        pub enum CphaW {
            # [ doc = "Sample on leading edge of the clock. Shift serial data on trailing edge." ]
            Leading,
            # [ doc = "Sample on trailing edge of the clock. Shift serial data on leading edge." ]
            Trailing,
        }
        impl CphaW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CphaW::Leading => 0,
                    CphaW::Trailing => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CphaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CphaW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CphaW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Sample on leading edge of the clock. Shift serial data on trailing edge." ]
            # [ inline ( always ) ]
            pub fn leading(self) -> &'a mut W {
                self.variant(CphaW::Leading)
            }
            # [ doc = "Sample on trailing edge of the clock. Shift serial data on leading edge." ]
            # [ inline ( always ) ]
            pub fn trailing(self) -> &'a mut W {
                self.variant(CphaW::Trailing)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CPOL`" ]
        pub enum CpolW {
            # [ doc = "Active high." ]
            ActiveHigh,
            # [ doc = "Active low." ]
            ActiveLow,
        }
        impl CpolW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CpolW::ActiveHigh => 0,
                    CpolW::ActiveLow => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CpolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CpolW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CpolW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Active high." ]
            # [ inline ( always ) ]
            pub fn active_high(self) -> &'a mut W {
                self.variant(CpolW::ActiveHigh)
            }
            # [ doc = "Active low." ]
            # [ inline ( always ) ]
            pub fn active_low(self) -> &'a mut W {
                self.variant(CpolW::ActiveLow)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Bit order." ]
            # [ inline ( always ) ]
            pub fn order(&self) -> OrderR {
                OrderR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Serial clock (SCK) phase." ]
            # [ inline ( always ) ]
            pub fn cpha(&self) -> CphaR {
                CphaR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Serial clock (SCK) polarity." ]
            # [ inline ( always ) ]
            pub fn cpol(&self) -> CpolR {
                CpolR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Bit order." ]
            # [ inline ( always ) ]
            pub fn order(&mut self) -> _OrderW {
                _OrderW { w: self }
            }
            # [ doc = "Bit 1 - Serial clock (SCK) phase." ]
            # [ inline ( always ) ]
            pub fn cpha(&mut self) -> _CphaW {
                _CphaW { w: self }
            }
            # [ doc = "Bit 2 - Serial clock (SCK) polarity." ]
            # [ inline ( always ) ]
            pub fn cpol(&mut self) -> _CpolW {
                _CpolW { w: self }
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "SPI master 0." ]
pub struct Spi0 {
    register_block: spi0::RegisterBlock,
}
impl Deref for Spi0 {
    type Target = spi0::RegisterBlock;
    fn deref(&self) -> &spi0::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Two-wire interface master 0." ]
pub const TWI0: Peripheral<Twi0> = unsafe { Peripheral::new(1073754112) };
# [ doc = "Two-wire interface master 0." ]
pub mod twi0 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Start 2-Wire master receive sequence." ]
        pub tasks_startrx: TasksStartrx,
        _reserved0: [u8; 4usize],
        # [ doc = "0x08 - Start 2-Wire master transmit sequence." ]
        pub tasks_starttx: TasksStarttx,
        _reserved1: [u8; 8usize],
        # [ doc = "0x14 - Stop 2-Wire transaction." ]
        pub tasks_stop: TasksStop,
        _reserved2: [u8; 4usize],
        # [ doc = "0x1c - Suspend 2-Wire transaction." ]
        pub tasks_suspend: TasksSuspend,
        # [ doc = "0x20 - Resume 2-Wire transaction." ]
        pub tasks_resume: TasksResume,
        _reserved3: [u8; 224usize],
        # [ doc = "0x104 - Two-wire stopped." ]
        pub events_stopped: EventsStopped,
        # [ doc = "0x108 - Two-wire ready to deliver new RXD byte received." ]
        pub events_rxdready: EventsRxdready,
        _reserved4: [u8; 16usize],
        # [ doc = "0x11c - Two-wire finished sending last TXD byte." ]
        pub events_txdsent: EventsTxdsent,
        _reserved5: [u8; 4usize],
        # [ doc = "0x124 - Two-wire error detected." ]
        pub events_error: EventsError,
        _reserved6: [u8; 16usize],
        # [ doc = "0x138 - Two-wire byte boundary." ]
        pub events_bb: EventsBb,
        _reserved7: [u8; 12usize],
        # [ doc = "0x148 - Two-wire suspended." ]
        pub events_suspended: EventsSuspended,
        _reserved8: [u8; 180usize],
        # [ doc = "0x200 - Shortcuts for TWI." ]
        pub shorts: Shorts,
        _reserved9: [u8; 256usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved10: [u8; 440usize],
        # [ doc = "0x4c4 - Two-wire error source. Write error field to 1 to clear error." ]
        pub errorsrc: Errorsrc,
        _reserved11: [u8; 56usize],
        # [ doc = "0x500 - Enable two-wire master." ]
        pub enable: Enable,
        _reserved12: [u8; 4usize],
        # [ doc = "0x508 - Pin select for SCL." ]
        pub pselscl: Pselscl,
        # [ doc = "0x50c - Pin select for SDA." ]
        pub pselsda: Pselsda,
        _reserved13: [u8; 8usize],
        # [ doc = "0x518 - RX data register." ]
        pub rxd: Rxd,
        # [ doc = "0x51c - TX data register." ]
        pub txd: Txd,
        _reserved14: [u8; 4usize],
        # [ doc = "0x524 - Two-wire frequency." ]
        pub frequency: Frequency,
        _reserved15: [u8; 96usize],
        # [ doc = "0x588 - Address used in the two-wire transfer." ]
        pub address: Address,
        _reserved16: [u8; 2672usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Start 2-Wire master receive sequence." ]
    pub struct TasksStartrx {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start 2-Wire master receive sequence." ]
    pub mod tasks_startrx {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStartrx {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Start 2-Wire master transmit sequence." ]
    pub struct TasksStarttx {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start 2-Wire master transmit sequence." ]
    pub mod tasks_starttx {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStarttx {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop 2-Wire transaction." ]
    pub struct TasksStop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop 2-Wire transaction." ]
    pub mod tasks_stop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Suspend 2-Wire transaction." ]
    pub struct TasksSuspend {
        register: VolatileCell<u32>,
    }
    # [ doc = "Suspend 2-Wire transaction." ]
    pub mod tasks_suspend {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksSuspend {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Resume 2-Wire transaction." ]
    pub struct TasksResume {
        register: VolatileCell<u32>,
    }
    # [ doc = "Resume 2-Wire transaction." ]
    pub mod tasks_resume {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksResume {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Two-wire stopped." ]
    pub struct EventsStopped {
        register: VolatileCell<u32>,
    }
    # [ doc = "Two-wire stopped." ]
    pub mod events_stopped {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsStopped {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Two-wire ready to deliver new RXD byte received." ]
    pub struct EventsRxdready {
        register: VolatileCell<u32>,
    }
    # [ doc = "Two-wire ready to deliver new RXD byte received." ]
    pub mod events_rxdready {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsRxdready {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Two-wire finished sending last TXD byte." ]
    pub struct EventsTxdsent {
        register: VolatileCell<u32>,
    }
    # [ doc = "Two-wire finished sending last TXD byte." ]
    pub mod events_txdsent {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsTxdsent {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Two-wire error detected." ]
    pub struct EventsError {
        register: VolatileCell<u32>,
    }
    # [ doc = "Two-wire error detected." ]
    pub mod events_error {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsError {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Two-wire byte boundary." ]
    pub struct EventsBb {
        register: VolatileCell<u32>,
    }
    # [ doc = "Two-wire byte boundary." ]
    pub mod events_bb {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsBb {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Two-wire suspended." ]
    pub struct EventsSuspended {
        register: VolatileCell<u32>,
    }
    # [ doc = "Two-wire suspended." ]
    pub mod events_suspended {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsSuspended {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Shortcuts for TWI." ]
    pub struct Shorts {
        register: VolatileCell<u32>,
    }
    # [ doc = "Shortcuts for TWI." ]
    pub mod shorts {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Shorts {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `BB_SUSPEND`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum BbSuspendR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl BbSuspendR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    BbSuspendR::Disabled => 0,
                    BbSuspendR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> BbSuspendR {
                match bits {
                    0 => BbSuspendR::Disabled,
                    1 => BbSuspendR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == BbSuspendR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == BbSuspendR::Enabled
            }
        }
        # [ doc = "Possible values of the field `BB_STOP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum BbStopR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl BbStopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    BbStopR::Disabled => 0,
                    BbStopR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> BbStopR {
                match bits {
                    0 => BbStopR::Disabled,
                    1 => BbStopR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == BbStopR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == BbStopR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `BB_SUSPEND`" ]
        pub enum BbSuspendW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl BbSuspendW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BbSuspendW::Disabled => 0,
                    BbSuspendW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BbSuspendW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BbSuspendW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: BbSuspendW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BbSuspendW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BbSuspendW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BB_STOP`" ]
        pub enum BbStopW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl BbStopW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BbStopW::Disabled => 0,
                    BbStopW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BbStopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BbStopW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: BbStopW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BbStopW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BbStopW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Shortcut between BB event and the SUSPEND task." ]
            # [ inline ( always ) ]
            pub fn bb_suspend(&self) -> BbSuspendR {
                BbSuspendR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Shortcut between BB event and the STOP task." ]
            # [ inline ( always ) ]
            pub fn bb_stop(&self) -> BbStopR {
                BbStopR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Shortcut between BB event and the SUSPEND task." ]
            # [ inline ( always ) ]
            pub fn bb_suspend(&mut self) -> _BbSuspendW {
                _BbSuspendW { w: self }
            }
            # [ doc = "Bit 1 - Shortcut between BB event and the STOP task." ]
            # [ inline ( always ) ]
            pub fn bb_stop(&mut self) -> _BbStopW {
                _BbStopW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `STOPPED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum StoppedR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl StoppedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    StoppedR::Disabled => 0,
                    StoppedR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> StoppedR {
                match bits {
                    0 => StoppedR::Disabled,
                    1 => StoppedR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == StoppedR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == StoppedR::Enabled
            }
        }
        # [ doc = "Possible values of the field `RXDREADY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RxdreadyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl RxdreadyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RxdreadyR::Disabled => 0,
                    RxdreadyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RxdreadyR {
                match bits {
                    0 => RxdreadyR::Disabled,
                    1 => RxdreadyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == RxdreadyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == RxdreadyR::Enabled
            }
        }
        # [ doc = "Possible values of the field `TXDSENT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TxdsentR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl TxdsentR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TxdsentR::Disabled => 0,
                    TxdsentR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TxdsentR {
                match bits {
                    0 => TxdsentR::Disabled,
                    1 => TxdsentR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == TxdsentR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == TxdsentR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ERROR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ErrorR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ErrorR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ErrorR::Disabled => 0,
                    ErrorR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ErrorR {
                match bits {
                    0 => ErrorR::Disabled,
                    1 => ErrorR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ErrorR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ErrorR::Enabled
            }
        }
        # [ doc = "Possible values of the field `BB`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum BbR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl BbR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    BbR::Disabled => 0,
                    BbR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> BbR {
                match bits {
                    0 => BbR::Disabled,
                    1 => BbR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == BbR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == BbR::Enabled
            }
        }
        # [ doc = "Possible values of the field `SUSPENDED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SuspendedR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl SuspendedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SuspendedR::Disabled => 0,
                    SuspendedR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SuspendedR {
                match bits {
                    0 => SuspendedR::Disabled,
                    1 => SuspendedR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == SuspendedR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == SuspendedR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `STOPPED`" ]
        pub enum StoppedW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl StoppedW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    StoppedW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _StoppedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StoppedW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: StoppedW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(StoppedW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RXDREADY`" ]
        pub enum RxdreadyW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl RxdreadyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RxdreadyW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RxdreadyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxdreadyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RxdreadyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(RxdreadyW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TXDSENT`" ]
        pub enum TxdsentW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl TxdsentW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TxdsentW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TxdsentW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxdsentW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TxdsentW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(TxdsentW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ERROR`" ]
        pub enum ErrorW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl ErrorW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ErrorW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ErrorW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ErrorW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ErrorW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(ErrorW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BB`" ]
        pub enum BbW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl BbW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BbW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BbW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BbW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: BbW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(BbW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `SUSPENDED`" ]
        pub enum SuspendedW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl SuspendedW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SuspendedW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SuspendedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SuspendedW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SuspendedW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(SuspendedW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 1 - Enable interrupt on STOPPED event." ]
            # [ inline ( always ) ]
            pub fn stopped(&self) -> StoppedR {
                StoppedR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Enable interrupt on READY event." ]
            # [ inline ( always ) ]
            pub fn rxdready(&self) -> RxdreadyR {
                RxdreadyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Enable interrupt on TXDSENT event." ]
            # [ inline ( always ) ]
            pub fn txdsent(&self) -> TxdsentR {
                TxdsentR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Enable interrupt on ERROR event." ]
            # [ inline ( always ) ]
            pub fn error(&self) -> ErrorR {
                ErrorR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 14 - Enable interrupt on BB event." ]
            # [ inline ( always ) ]
            pub fn bb(&self) -> BbR {
                BbR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Enable interrupt on SUSPENDED event." ]
            # [ inline ( always ) ]
            pub fn suspended(&self) -> SuspendedR {
                SuspendedR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 1 - Enable interrupt on STOPPED event." ]
            # [ inline ( always ) ]
            pub fn stopped(&mut self) -> _StoppedW {
                _StoppedW { w: self }
            }
            # [ doc = "Bit 2 - Enable interrupt on READY event." ]
            # [ inline ( always ) ]
            pub fn rxdready(&mut self) -> _RxdreadyW {
                _RxdreadyW { w: self }
            }
            # [ doc = "Bit 7 - Enable interrupt on TXDSENT event." ]
            # [ inline ( always ) ]
            pub fn txdsent(&mut self) -> _TxdsentW {
                _TxdsentW { w: self }
            }
            # [ doc = "Bit 9 - Enable interrupt on ERROR event." ]
            # [ inline ( always ) ]
            pub fn error(&mut self) -> _ErrorW {
                _ErrorW { w: self }
            }
            # [ doc = "Bit 14 - Enable interrupt on BB event." ]
            # [ inline ( always ) ]
            pub fn bb(&mut self) -> _BbW {
                _BbW { w: self }
            }
            # [ doc = "Bit 18 - Enable interrupt on SUSPENDED event." ]
            # [ inline ( always ) ]
            pub fn suspended(&mut self) -> _SuspendedW {
                _SuspendedW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `STOPPED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum StoppedR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl StoppedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    StoppedR::Disabled => 0,
                    StoppedR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> StoppedR {
                match bits {
                    0 => StoppedR::Disabled,
                    1 => StoppedR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == StoppedR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == StoppedR::Enabled
            }
        }
        # [ doc = "Possible values of the field `RXDREADY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RxdreadyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl RxdreadyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RxdreadyR::Disabled => 0,
                    RxdreadyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RxdreadyR {
                match bits {
                    0 => RxdreadyR::Disabled,
                    1 => RxdreadyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == RxdreadyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == RxdreadyR::Enabled
            }
        }
        # [ doc = "Possible values of the field `TXDSENT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TxdsentR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl TxdsentR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TxdsentR::Disabled => 0,
                    TxdsentR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TxdsentR {
                match bits {
                    0 => TxdsentR::Disabled,
                    1 => TxdsentR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == TxdsentR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == TxdsentR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ERROR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ErrorR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ErrorR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ErrorR::Disabled => 0,
                    ErrorR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ErrorR {
                match bits {
                    0 => ErrorR::Disabled,
                    1 => ErrorR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ErrorR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ErrorR::Enabled
            }
        }
        # [ doc = "Possible values of the field `BB`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum BbR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl BbR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    BbR::Disabled => 0,
                    BbR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> BbR {
                match bits {
                    0 => BbR::Disabled,
                    1 => BbR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == BbR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == BbR::Enabled
            }
        }
        # [ doc = "Possible values of the field `SUSPENDED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SuspendedR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl SuspendedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SuspendedR::Disabled => 0,
                    SuspendedR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SuspendedR {
                match bits {
                    0 => SuspendedR::Disabled,
                    1 => SuspendedR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == SuspendedR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == SuspendedR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `STOPPED`" ]
        pub enum StoppedW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl StoppedW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    StoppedW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _StoppedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StoppedW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: StoppedW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(StoppedW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RXDREADY`" ]
        pub enum RxdreadyW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl RxdreadyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RxdreadyW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RxdreadyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxdreadyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RxdreadyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(RxdreadyW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TXDSENT`" ]
        pub enum TxdsentW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl TxdsentW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TxdsentW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TxdsentW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxdsentW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TxdsentW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(TxdsentW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ERROR`" ]
        pub enum ErrorW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl ErrorW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ErrorW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ErrorW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ErrorW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ErrorW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(ErrorW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BB`" ]
        pub enum BbW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl BbW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BbW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BbW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BbW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: BbW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(BbW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `SUSPENDED`" ]
        pub enum SuspendedW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl SuspendedW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SuspendedW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SuspendedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SuspendedW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SuspendedW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(SuspendedW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 1 - Disable interrupt on STOPPED event." ]
            # [ inline ( always ) ]
            pub fn stopped(&self) -> StoppedR {
                StoppedR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Disable interrupt on RXDREADY event." ]
            # [ inline ( always ) ]
            pub fn rxdready(&self) -> RxdreadyR {
                RxdreadyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Disable interrupt on TXDSENT event." ]
            # [ inline ( always ) ]
            pub fn txdsent(&self) -> TxdsentR {
                TxdsentR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Disable interrupt on ERROR event." ]
            # [ inline ( always ) ]
            pub fn error(&self) -> ErrorR {
                ErrorR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 14 - Disable interrupt on BB event." ]
            # [ inline ( always ) ]
            pub fn bb(&self) -> BbR {
                BbR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Disable interrupt on SUSPENDED event." ]
            # [ inline ( always ) ]
            pub fn suspended(&self) -> SuspendedR {
                SuspendedR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 1 - Disable interrupt on STOPPED event." ]
            # [ inline ( always ) ]
            pub fn stopped(&mut self) -> _StoppedW {
                _StoppedW { w: self }
            }
            # [ doc = "Bit 2 - Disable interrupt on RXDREADY event." ]
            # [ inline ( always ) ]
            pub fn rxdready(&mut self) -> _RxdreadyW {
                _RxdreadyW { w: self }
            }
            # [ doc = "Bit 7 - Disable interrupt on TXDSENT event." ]
            # [ inline ( always ) ]
            pub fn txdsent(&mut self) -> _TxdsentW {
                _TxdsentW { w: self }
            }
            # [ doc = "Bit 9 - Disable interrupt on ERROR event." ]
            # [ inline ( always ) ]
            pub fn error(&mut self) -> _ErrorW {
                _ErrorW { w: self }
            }
            # [ doc = "Bit 14 - Disable interrupt on BB event." ]
            # [ inline ( always ) ]
            pub fn bb(&mut self) -> _BbW {
                _BbW { w: self }
            }
            # [ doc = "Bit 18 - Disable interrupt on SUSPENDED event." ]
            # [ inline ( always ) ]
            pub fn suspended(&mut self) -> _SuspendedW {
                _SuspendedW { w: self }
            }
        }
    }
    # [ doc = "Two-wire error source. Write error field to 1 to clear error." ]
    pub struct Errorsrc {
        register: VolatileCell<u32>,
    }
    # [ doc = "Two-wire error source. Write error field to 1 to clear error." ]
    pub mod errorsrc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Errorsrc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `OVERRUN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OverrunR {
            # [ doc = "Error not present." ]
            NotPresent,
            # [ doc = "Error present." ]
            Present,
        }
        impl OverrunR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OverrunR::NotPresent => 0,
                    OverrunR::Present => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OverrunR {
                match bits {
                    0 => OverrunR::NotPresent,
                    1 => OverrunR::Present,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotPresent`" ]
            # [ inline ( always ) ]
            pub fn is_not_present(&self) -> bool {
                *self == OverrunR::NotPresent
            }
            # [ doc = "Checks if the value of the field is `Present`" ]
            # [ inline ( always ) ]
            pub fn is_present(&self) -> bool {
                *self == OverrunR::Present
            }
        }
        # [ doc = "Possible values of the field `ANACK`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum AnackR {
            # [ doc = "Error not present." ]
            NotPresent,
            # [ doc = "Error present." ]
            Present,
        }
        impl AnackR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    AnackR::NotPresent => 0,
                    AnackR::Present => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> AnackR {
                match bits {
                    0 => AnackR::NotPresent,
                    1 => AnackR::Present,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotPresent`" ]
            # [ inline ( always ) ]
            pub fn is_not_present(&self) -> bool {
                *self == AnackR::NotPresent
            }
            # [ doc = "Checks if the value of the field is `Present`" ]
            # [ inline ( always ) ]
            pub fn is_present(&self) -> bool {
                *self == AnackR::Present
            }
        }
        # [ doc = "Possible values of the field `DNACK`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DnackR {
            # [ doc = "Error not present." ]
            NotPresent,
            # [ doc = "Error present." ]
            Present,
        }
        impl DnackR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DnackR::NotPresent => 0,
                    DnackR::Present => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DnackR {
                match bits {
                    0 => DnackR::NotPresent,
                    1 => DnackR::Present,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotPresent`" ]
            # [ inline ( always ) ]
            pub fn is_not_present(&self) -> bool {
                *self == DnackR::NotPresent
            }
            # [ doc = "Checks if the value of the field is `Present`" ]
            # [ inline ( always ) ]
            pub fn is_present(&self) -> bool {
                *self == DnackR::Present
            }
        }
        # [ doc = "Values that can be written to the field `OVERRUN`" ]
        pub enum OverrunW {
            # [ doc = "Clear error on write." ]
            Clear,
        }
        impl OverrunW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OverrunW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OverrunW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OverrunW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OverrunW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Clear error on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(OverrunW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ANACK`" ]
        pub enum AnackW {
            # [ doc = "Clear error on write." ]
            Clear,
        }
        impl AnackW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AnackW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AnackW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AnackW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: AnackW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Clear error on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(AnackW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DNACK`" ]
        pub enum DnackW {
            # [ doc = "Clear error on write." ]
            Clear,
        }
        impl DnackW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DnackW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DnackW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DnackW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DnackW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Clear error on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(DnackW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Byte received in RXD register before read of the last received byte (data loss)." ]
            # [ inline ( always ) ]
            pub fn overrun(&self) -> OverrunR {
                OverrunR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - NACK received after sending the address." ]
            # [ inline ( always ) ]
            pub fn anack(&self) -> AnackR {
                AnackR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - NACK received after sending a data byte." ]
            # [ inline ( always ) ]
            pub fn dnack(&self) -> DnackR {
                DnackR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Byte received in RXD register before read of the last received byte (data loss)." ]
            # [ inline ( always ) ]
            pub fn overrun(&mut self) -> _OverrunW {
                _OverrunW { w: self }
            }
            # [ doc = "Bit 1 - NACK received after sending the address." ]
            # [ inline ( always ) ]
            pub fn anack(&mut self) -> _AnackW {
                _AnackW { w: self }
            }
            # [ doc = "Bit 2 - NACK received after sending a data byte." ]
            # [ inline ( always ) ]
            pub fn dnack(&mut self) -> _DnackW {
                _DnackW { w: self }
            }
        }
    }
    # [ doc = "Enable two-wire master." ]
    pub struct Enable {
        register: VolatileCell<u32>,
    }
    # [ doc = "Enable two-wire master." ]
    pub mod enable {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Enable {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ENABLE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EnableR {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl EnableR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EnableR::Disabled => 0,
                    EnableR::Enabled => 5,
                    EnableR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EnableR {
                match bits {
                    0 => EnableR::Disabled,
                    5 => EnableR::Enabled,
                    i => EnableR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EnableR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EnableR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `ENABLE`" ]
        pub enum EnableW {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl EnableW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EnableW::Disabled => 0,
                    EnableW::Enabled => 5,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnableW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnableW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EnableW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EnableW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EnableW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:2 - Enable or disable W2M" ]
            # [ inline ( always ) ]
            pub fn enable(&self) -> EnableR {
                EnableR::_from(
                    {
                        const MASK: u8 = 7;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:2 - Enable or disable W2M" ]
            # [ inline ( always ) ]
            pub fn enable(&mut self) -> _EnableW {
                _EnableW { w: self }
            }
        }
    }
    # [ doc = "Pin select for SCL." ]
    pub struct Pselscl {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin select for SCL." ]
    pub mod pselscl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pselscl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pin select for SDA." ]
    pub struct Pselsda {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin select for SDA." ]
    pub mod pselsda {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pselsda {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "RX data register." ]
    pub struct Rxd {
        register: VolatileCell<u32>,
    }
    # [ doc = "RX data register." ]
    pub mod rxd {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Rxd {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxdR {
            bits: u8,
        }
        impl RxdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - RX data from last transfer." ]
            # [ inline ( always ) ]
            pub fn rxd(&self) -> RxdR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxdR { bits }
            }
        }
    }
    # [ doc = "TX data register." ]
    pub struct Txd {
        register: VolatileCell<u32>,
    }
    # [ doc = "TX data register." ]
    pub mod txd {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Txd {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TxdR {
            bits: u8,
        }
        impl TxdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TxdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - TX data for next transfer." ]
            # [ inline ( always ) ]
            pub fn txd(&self) -> TxdR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxdR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - TX data for next transfer." ]
            # [ inline ( always ) ]
            pub fn txd(&mut self) -> _TxdW {
                _TxdW { w: self }
            }
        }
    }
    # [ doc = "Two-wire frequency." ]
    pub struct Frequency {
        register: VolatileCell<u32>,
    }
    # [ doc = "Two-wire frequency." ]
    pub mod frequency {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Frequency {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `FREQUENCY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum FrequencyR {
            # [ doc = "100 kbps." ]
            K100,
            # [ doc = "250 kbps." ]
            K250,
            # [ doc = "400 kbps." ]
            K400,
            # [ doc = r" Reserved" ]
            _Reserved(u32),
        }
        impl FrequencyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                match *self {
                    FrequencyR::K100 => 26738688,
                    FrequencyR::K250 => 67108864,
                    FrequencyR::K400 => 107479040,
                    FrequencyR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u32) -> FrequencyR {
                match bits {
                    26738688 => FrequencyR::K100,
                    67108864 => FrequencyR::K250,
                    107479040 => FrequencyR::K400,
                    i => FrequencyR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `K100`" ]
            # [ inline ( always ) ]
            pub fn is_k100(&self) -> bool {
                *self == FrequencyR::K100
            }
            # [ doc = "Checks if the value of the field is `K250`" ]
            # [ inline ( always ) ]
            pub fn is_k250(&self) -> bool {
                *self == FrequencyR::K250
            }
            # [ doc = "Checks if the value of the field is `K400`" ]
            # [ inline ( always ) ]
            pub fn is_k400(&self) -> bool {
                *self == FrequencyR::K400
            }
        }
        # [ doc = "Values that can be written to the field `FREQUENCY`" ]
        pub enum FrequencyW {
            # [ doc = "100 kbps." ]
            K100,
            # [ doc = "250 kbps." ]
            K250,
            # [ doc = "400 kbps." ]
            K400,
        }
        impl FrequencyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u32 {
                match *self {
                    FrequencyW::K100 => 26738688,
                    FrequencyW::K250 => 67108864,
                    FrequencyW::K400 => 107479040,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FrequencyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FrequencyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: FrequencyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "100 kbps." ]
            # [ inline ( always ) ]
            pub fn k100(self) -> &'a mut W {
                self.variant(FrequencyW::K100)
            }
            # [ doc = "250 kbps." ]
            # [ inline ( always ) ]
            pub fn k250(self) -> &'a mut W {
                self.variant(FrequencyW::K250)
            }
            # [ doc = "400 kbps." ]
            # [ inline ( always ) ]
            pub fn k400(self) -> &'a mut W {
                self.variant(FrequencyW::K400)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Two-wire master clock frequency." ]
            # [ inline ( always ) ]
            pub fn frequency(&self) -> FrequencyR {
                FrequencyR::_from(
                    {
                        const MASK: u32 = 4294967295;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u32
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 67108864 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Two-wire master clock frequency." ]
            # [ inline ( always ) ]
            pub fn frequency(&mut self) -> _FrequencyW {
                _FrequencyW { w: self }
            }
        }
    }
    # [ doc = "Address used in the two-wire transfer." ]
    pub struct Address {
        register: VolatileCell<u32>,
    }
    # [ doc = "Address used in the two-wire transfer." ]
    pub mod address {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Address {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddressR {
            bits: u8,
        }
        impl AddressR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddressW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddressW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:6 - Two-wire address." ]
            # [ inline ( always ) ]
            pub fn address(&self) -> AddressR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddressR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:6 - Two-wire address." ]
            # [ inline ( always ) ]
            pub fn address(&mut self) -> _AddressW {
                _AddressW { w: self }
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "Two-wire interface master 0." ]
pub struct Twi0 {
    register_block: twi0::RegisterBlock,
}
impl Deref for Twi0 {
    type Target = twi0::RegisterBlock;
    fn deref(&self) -> &twi0::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "SPI master 1." ]
pub const SPI1: Peripheral<Spi1> = unsafe { Peripheral::new(1073758208) };
# [ doc = r" Register block" ]
pub struct Spi1 {
    register_block: spi0::RegisterBlock,
}
impl Deref for Spi1 {
    type Target = spi0::RegisterBlock;
    fn deref(&self) -> &spi0::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Two-wire interface master 1." ]
pub const TWI1: Peripheral<Twi1> = unsafe { Peripheral::new(1073758208) };
# [ doc = r" Register block" ]
pub struct Twi1 {
    register_block: twi0::RegisterBlock,
}
impl Deref for Twi1 {
    type Target = twi0::RegisterBlock;
    fn deref(&self) -> &twi0::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "SPI slave 1." ]
pub const SPIS1: Peripheral<Spis1> = unsafe { Peripheral::new(1073758208) };
# [ doc = "SPI slave 1." ]
pub mod spis1 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 36usize],
        # [ doc = "0x24 - Acquire SPI semaphore." ]
        pub tasks_acquire: TasksAcquire,
        # [ doc = "0x28 - Release SPI semaphore." ]
        pub tasks_release: TasksRelease,
        _reserved1: [u8; 216usize],
        # [ doc = "0x104 - Granted transaction completed." ]
        pub events_end: EventsEnd,
        _reserved2: [u8; 32usize],
        # [ doc = "0x128 - Semaphore acquired." ]
        pub events_acquired: EventsAcquired,
        _reserved3: [u8; 212usize],
        # [ doc = "0x200 - Shortcuts for SPIS." ]
        pub shorts: Shorts,
        _reserved4: [u8; 256usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved5: [u8; 244usize],
        # [ doc = "0x400 - Semaphore status." ]
        pub semstat: Semstat,
        _reserved6: [u8; 60usize],
        # [ doc = "0x440 - Status from last transaction." ]
        pub status: Status,
        _reserved7: [u8; 188usize],
        # [ doc = "0x500 - Enable SPIS." ]
        pub enable: Enable,
        _reserved8: [u8; 4usize],
        # [ doc = "0x508 - Pin select for SCK." ]
        pub pselsck: Pselsck,
        # [ doc = "0x50c - Pin select for MISO." ]
        pub pselmiso: Pselmiso,
        # [ doc = "0x510 - Pin select for MOSI." ]
        pub pselmosi: Pselmosi,
        # [ doc = "0x514 - Pin select for CSN." ]
        pub pselcsn: Pselcsn,
        _reserved9: [u8; 28usize],
        # [ doc = "0x534 - RX data pointer." ]
        pub rxdptr: Rxdptr,
        # [ doc = "0x538 - Maximum number of bytes in the receive buffer." ]
        pub maxrx: Maxrx,
        # [ doc = "0x53c - Number of bytes received in last granted transaction." ]
        pub amountrx: Amountrx,
        _reserved10: [u8; 4usize],
        # [ doc = "0x544 - TX data pointer." ]
        pub txdptr: Txdptr,
        # [ doc = "0x548 - Maximum number of bytes in the transmit buffer." ]
        pub maxtx: Maxtx,
        # [ doc = "0x54c - Number of bytes transmitted in last granted transaction." ]
        pub amounttx: Amounttx,
        _reserved11: [u8; 4usize],
        # [ doc = "0x554 - Configuration register." ]
        pub config: Config,
        _reserved12: [u8; 4usize],
        # [ doc = "0x55c - Default character." ]
        pub def: Def,
        _reserved13: [u8; 96usize],
        # [ doc = "0x5c0 - Over-read character." ]
        pub orc: Orc,
        _reserved14: [u8; 2616usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Acquire SPI semaphore." ]
    pub struct TasksAcquire {
        register: VolatileCell<u32>,
    }
    # [ doc = "Acquire SPI semaphore." ]
    pub mod tasks_acquire {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksAcquire {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Release SPI semaphore." ]
    pub struct TasksRelease {
        register: VolatileCell<u32>,
    }
    # [ doc = "Release SPI semaphore." ]
    pub mod tasks_release {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksRelease {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Granted transaction completed." ]
    pub struct EventsEnd {
        register: VolatileCell<u32>,
    }
    # [ doc = "Granted transaction completed." ]
    pub mod events_end {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsEnd {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Semaphore acquired." ]
    pub struct EventsAcquired {
        register: VolatileCell<u32>,
    }
    # [ doc = "Semaphore acquired." ]
    pub mod events_acquired {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsAcquired {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Shortcuts for SPIS." ]
    pub struct Shorts {
        register: VolatileCell<u32>,
    }
    # [ doc = "Shortcuts for SPIS." ]
    pub mod shorts {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Shorts {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `END_ACQUIRE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndAcquireR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl EndAcquireR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndAcquireR::Disabled => 0,
                    EndAcquireR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndAcquireR {
                match bits {
                    0 => EndAcquireR::Disabled,
                    1 => EndAcquireR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndAcquireR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndAcquireR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `END_ACQUIRE`" ]
        pub enum EndAcquireW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl EndAcquireW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndAcquireW::Disabled => 0,
                    EndAcquireW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndAcquireW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndAcquireW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndAcquireW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EndAcquireW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EndAcquireW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 2 - Shortcut between END event and the ACQUIRE task." ]
            # [ inline ( always ) ]
            pub fn end_acquire(&self) -> EndAcquireR {
                EndAcquireR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 2 - Shortcut between END event and the ACQUIRE task." ]
            # [ inline ( always ) ]
            pub fn end_acquire(&mut self) -> _EndAcquireW {
                _EndAcquireW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `END`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndR::Disabled => 0,
                    EndR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndR {
                match bits {
                    0 => EndR::Disabled,
                    1 => EndR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ACQUIRED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum AcquiredR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl AcquiredR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    AcquiredR::Disabled => 0,
                    AcquiredR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> AcquiredR {
                match bits {
                    0 => AcquiredR::Disabled,
                    1 => AcquiredR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == AcquiredR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == AcquiredR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `END`" ]
        pub enum EndW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl EndW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(EndW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ACQUIRED`" ]
        pub enum AcquiredW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl AcquiredW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AcquiredW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AcquiredW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AcquiredW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: AcquiredW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(AcquiredW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 1 - Enable interrupt on END event." ]
            # [ inline ( always ) ]
            pub fn end(&self) -> EndR {
                EndR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Enable interrupt on ACQUIRED event." ]
            # [ inline ( always ) ]
            pub fn acquired(&self) -> AcquiredR {
                AcquiredR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 1 - Enable interrupt on END event." ]
            # [ inline ( always ) ]
            pub fn end(&mut self) -> _EndW {
                _EndW { w: self }
            }
            # [ doc = "Bit 10 - Enable interrupt on ACQUIRED event." ]
            # [ inline ( always ) ]
            pub fn acquired(&mut self) -> _AcquiredW {
                _AcquiredW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `END`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndR::Disabled => 0,
                    EndR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndR {
                match bits {
                    0 => EndR::Disabled,
                    1 => EndR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ACQUIRED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum AcquiredR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl AcquiredR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    AcquiredR::Disabled => 0,
                    AcquiredR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> AcquiredR {
                match bits {
                    0 => AcquiredR::Disabled,
                    1 => AcquiredR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == AcquiredR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == AcquiredR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `END`" ]
        pub enum EndW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl EndW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(EndW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ACQUIRED`" ]
        pub enum AcquiredW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl AcquiredW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AcquiredW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AcquiredW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AcquiredW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: AcquiredW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(AcquiredW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 1 - Disable interrupt on END event." ]
            # [ inline ( always ) ]
            pub fn end(&self) -> EndR {
                EndR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Disable interrupt on ACQUIRED event." ]
            # [ inline ( always ) ]
            pub fn acquired(&self) -> AcquiredR {
                AcquiredR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 1 - Disable interrupt on END event." ]
            # [ inline ( always ) ]
            pub fn end(&mut self) -> _EndW {
                _EndW { w: self }
            }
            # [ doc = "Bit 10 - Disable interrupt on ACQUIRED event." ]
            # [ inline ( always ) ]
            pub fn acquired(&mut self) -> _AcquiredW {
                _AcquiredW { w: self }
            }
        }
    }
    # [ doc = "Semaphore status." ]
    pub struct Semstat {
        register: VolatileCell<u32>,
    }
    # [ doc = "Semaphore status." ]
    pub mod semstat {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Semstat {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = "Possible values of the field `SEMSTAT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SemstatR {
            # [ doc = "Semaphore is free." ]
            Free,
            # [ doc = "Semaphore is assigned to the CPU." ]
            Cpu,
            # [ doc = "Semaphore is assigned to the SPIS." ]
            Spis,
            # [ doc = "Semaphore is assigned to the SPIS, but a handover to the CPU is pending." ]
            Cpupending,
        }
        impl SemstatR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SemstatR::Free => 0,
                    SemstatR::Cpu => 1,
                    SemstatR::Spis => 2,
                    SemstatR::Cpupending => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SemstatR {
                match bits {
                    0 => SemstatR::Free,
                    1 => SemstatR::Cpu,
                    2 => SemstatR::Spis,
                    3 => SemstatR::Cpupending,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Free`" ]
            # [ inline ( always ) ]
            pub fn is_free(&self) -> bool {
                *self == SemstatR::Free
            }
            # [ doc = "Checks if the value of the field is `Cpu`" ]
            # [ inline ( always ) ]
            pub fn is_cpu(&self) -> bool {
                *self == SemstatR::Cpu
            }
            # [ doc = "Checks if the value of the field is `Spis`" ]
            # [ inline ( always ) ]
            pub fn is_spis(&self) -> bool {
                *self == SemstatR::Spis
            }
            # [ doc = "Checks if the value of the field is `Cpupending`" ]
            # [ inline ( always ) ]
            pub fn is_cpupending(&self) -> bool {
                *self == SemstatR::Cpupending
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - Semaphore status." ]
            # [ inline ( always ) ]
            pub fn semstat(&self) -> SemstatR {
                SemstatR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
    }
    # [ doc = "Status from last transaction." ]
    pub struct Status {
        register: VolatileCell<u32>,
    }
    # [ doc = "Status from last transaction." ]
    pub mod status {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Status {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `OVERREAD`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OverreadR {
            # [ doc = "Error not present." ]
            NotPresent,
            # [ doc = "Error present." ]
            Present,
        }
        impl OverreadR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OverreadR::NotPresent => 0,
                    OverreadR::Present => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OverreadR {
                match bits {
                    0 => OverreadR::NotPresent,
                    1 => OverreadR::Present,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotPresent`" ]
            # [ inline ( always ) ]
            pub fn is_not_present(&self) -> bool {
                *self == OverreadR::NotPresent
            }
            # [ doc = "Checks if the value of the field is `Present`" ]
            # [ inline ( always ) ]
            pub fn is_present(&self) -> bool {
                *self == OverreadR::Present
            }
        }
        # [ doc = "Possible values of the field `OVERFLOW`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OverflowR {
            # [ doc = "Error not present." ]
            NotPresent,
            # [ doc = "Error present." ]
            Present,
        }
        impl OverflowR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OverflowR::NotPresent => 0,
                    OverflowR::Present => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OverflowR {
                match bits {
                    0 => OverflowR::NotPresent,
                    1 => OverflowR::Present,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotPresent`" ]
            # [ inline ( always ) ]
            pub fn is_not_present(&self) -> bool {
                *self == OverflowR::NotPresent
            }
            # [ doc = "Checks if the value of the field is `Present`" ]
            # [ inline ( always ) ]
            pub fn is_present(&self) -> bool {
                *self == OverflowR::Present
            }
        }
        # [ doc = "Values that can be written to the field `OVERREAD`" ]
        pub enum OverreadW {
            # [ doc = "Clear on write." ]
            Clear,
        }
        impl OverreadW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OverreadW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OverreadW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OverreadW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OverreadW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Clear on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(OverreadW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OVERFLOW`" ]
        pub enum OverflowW {
            # [ doc = "Clear on write." ]
            Clear,
        }
        impl OverflowW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OverflowW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OverflowW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OverflowW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OverflowW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Clear on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(OverflowW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - TX buffer overread detected, and prevented." ]
            # [ inline ( always ) ]
            pub fn overread(&self) -> OverreadR {
                OverreadR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - RX buffer overflow detected, and prevented." ]
            # [ inline ( always ) ]
            pub fn overflow(&self) -> OverflowR {
                OverflowR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - TX buffer overread detected, and prevented." ]
            # [ inline ( always ) ]
            pub fn overread(&mut self) -> _OverreadW {
                _OverreadW { w: self }
            }
            # [ doc = "Bit 1 - RX buffer overflow detected, and prevented." ]
            # [ inline ( always ) ]
            pub fn overflow(&mut self) -> _OverflowW {
                _OverflowW { w: self }
            }
        }
    }
    # [ doc = "Enable SPIS." ]
    pub struct Enable {
        register: VolatileCell<u32>,
    }
    # [ doc = "Enable SPIS." ]
    pub mod enable {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Enable {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ENABLE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EnableR {
            # [ doc = "Disabled SPIS." ]
            Disabled,
            # [ doc = "Enable SPIS." ]
            Enabled,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl EnableR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EnableR::Disabled => 0,
                    EnableR::Enabled => 2,
                    EnableR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EnableR {
                match bits {
                    0 => EnableR::Disabled,
                    2 => EnableR::Enabled,
                    i => EnableR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EnableR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EnableR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `ENABLE`" ]
        pub enum EnableW {
            # [ doc = "Disabled SPIS." ]
            Disabled,
            # [ doc = "Enable SPIS." ]
            Enabled,
        }
        impl EnableW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EnableW::Disabled => 0,
                    EnableW::Enabled => 2,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnableW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnableW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EnableW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disabled SPIS." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EnableW::Disabled)
            }
            # [ doc = "Enable SPIS." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EnableW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:2 - Enable or disable SPIS." ]
            # [ inline ( always ) ]
            pub fn enable(&self) -> EnableR {
                EnableR::_from(
                    {
                        const MASK: u8 = 7;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:2 - Enable or disable SPIS." ]
            # [ inline ( always ) ]
            pub fn enable(&mut self) -> _EnableW {
                _EnableW { w: self }
            }
        }
    }
    # [ doc = "Pin select for SCK." ]
    pub struct Pselsck {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin select for SCK." ]
    pub mod pselsck {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pselsck {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pin select for MISO." ]
    pub struct Pselmiso {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin select for MISO." ]
    pub mod pselmiso {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pselmiso {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pin select for MOSI." ]
    pub struct Pselmosi {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin select for MOSI." ]
    pub mod pselmosi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pselmosi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pin select for CSN." ]
    pub struct Pselcsn {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin select for CSN." ]
    pub mod pselcsn {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pselcsn {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "RX data pointer." ]
    pub struct Rxdptr {
        register: VolatileCell<u32>,
    }
    # [ doc = "RX data pointer." ]
    pub mod rxdptr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Rxdptr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Maximum number of bytes in the receive buffer." ]
    pub struct Maxrx {
        register: VolatileCell<u32>,
    }
    # [ doc = "Maximum number of bytes in the receive buffer." ]
    pub mod maxrx {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Maxrx {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MaxrxR {
            bits: u8,
        }
        impl MaxrxR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MaxrxW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaxrxW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Maximum number of bytes in the receive buffer." ]
            # [ inline ( always ) ]
            pub fn maxrx(&self) -> MaxrxR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MaxrxR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Maximum number of bytes in the receive buffer." ]
            # [ inline ( always ) ]
            pub fn maxrx(&mut self) -> _MaxrxW {
                _MaxrxW { w: self }
            }
        }
    }
    # [ doc = "Number of bytes received in last granted transaction." ]
    pub struct Amountrx {
        register: VolatileCell<u32>,
    }
    # [ doc = "Number of bytes received in last granted transaction." ]
    pub mod amountrx {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Amountrx {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AmountrxR {
            bits: u8,
        }
        impl AmountrxR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Number of bytes received in last granted transaction." ]
            # [ inline ( always ) ]
            pub fn amountrx(&self) -> AmountrxR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AmountrxR { bits }
            }
        }
    }
    # [ doc = "TX data pointer." ]
    pub struct Txdptr {
        register: VolatileCell<u32>,
    }
    # [ doc = "TX data pointer." ]
    pub mod txdptr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Txdptr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Maximum number of bytes in the transmit buffer." ]
    pub struct Maxtx {
        register: VolatileCell<u32>,
    }
    # [ doc = "Maximum number of bytes in the transmit buffer." ]
    pub mod maxtx {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Maxtx {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MaxtxR {
            bits: u8,
        }
        impl MaxtxR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MaxtxW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaxtxW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Maximum number of bytes in the transmit buffer." ]
            # [ inline ( always ) ]
            pub fn maxtx(&self) -> MaxtxR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MaxtxR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Maximum number of bytes in the transmit buffer." ]
            # [ inline ( always ) ]
            pub fn maxtx(&mut self) -> _MaxtxW {
                _MaxtxW { w: self }
            }
        }
    }
    # [ doc = "Number of bytes transmitted in last granted transaction." ]
    pub struct Amounttx {
        register: VolatileCell<u32>,
    }
    # [ doc = "Number of bytes transmitted in last granted transaction." ]
    pub mod amounttx {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Amounttx {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AmounttxR {
            bits: u8,
        }
        impl AmounttxR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Number of bytes transmitted in last granted transaction." ]
            # [ inline ( always ) ]
            pub fn amounttx(&self) -> AmounttxR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AmounttxR { bits }
            }
        }
    }
    # [ doc = "Configuration register." ]
    pub struct Config {
        register: VolatileCell<u32>,
    }
    # [ doc = "Configuration register." ]
    pub mod config {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Config {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ORDER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OrderR {
            # [ doc = "Most significant bit transmitted out first." ]
            MsbFirst,
            # [ doc = "Least significant bit transmitted out first." ]
            LsbFirst,
        }
        impl OrderR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OrderR::MsbFirst => 0,
                    OrderR::LsbFirst => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OrderR {
                match bits {
                    0 => OrderR::MsbFirst,
                    1 => OrderR::LsbFirst,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `MsbFirst`" ]
            # [ inline ( always ) ]
            pub fn is_msb_first(&self) -> bool {
                *self == OrderR::MsbFirst
            }
            # [ doc = "Checks if the value of the field is `LsbFirst`" ]
            # [ inline ( always ) ]
            pub fn is_lsb_first(&self) -> bool {
                *self == OrderR::LsbFirst
            }
        }
        # [ doc = "Possible values of the field `CPHA`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CphaR {
            # [ doc = "Sample on leading edge of the clock. Shift serial data on trailing edge." ]
            Leading,
            # [ doc = "Sample on trailing edge of the clock. Shift serial data on leading edge." ]
            Trailing,
        }
        impl CphaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CphaR::Leading => 0,
                    CphaR::Trailing => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CphaR {
                match bits {
                    0 => CphaR::Leading,
                    1 => CphaR::Trailing,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Leading`" ]
            # [ inline ( always ) ]
            pub fn is_leading(&self) -> bool {
                *self == CphaR::Leading
            }
            # [ doc = "Checks if the value of the field is `Trailing`" ]
            # [ inline ( always ) ]
            pub fn is_trailing(&self) -> bool {
                *self == CphaR::Trailing
            }
        }
        # [ doc = "Possible values of the field `CPOL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CpolR {
            # [ doc = "Active high." ]
            ActiveHigh,
            # [ doc = "Active low." ]
            ActiveLow,
        }
        impl CpolR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CpolR::ActiveHigh => 0,
                    CpolR::ActiveLow => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CpolR {
                match bits {
                    0 => CpolR::ActiveHigh,
                    1 => CpolR::ActiveLow,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `ActiveHigh`" ]
            # [ inline ( always ) ]
            pub fn is_active_high(&self) -> bool {
                *self == CpolR::ActiveHigh
            }
            # [ doc = "Checks if the value of the field is `ActiveLow`" ]
            # [ inline ( always ) ]
            pub fn is_active_low(&self) -> bool {
                *self == CpolR::ActiveLow
            }
        }
        # [ doc = "Values that can be written to the field `ORDER`" ]
        pub enum OrderW {
            # [ doc = "Most significant bit transmitted out first." ]
            MsbFirst,
            # [ doc = "Least significant bit transmitted out first." ]
            LsbFirst,
        }
        impl OrderW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OrderW::MsbFirst => 0,
                    OrderW::LsbFirst => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OrderW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OrderW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OrderW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Most significant bit transmitted out first." ]
            # [ inline ( always ) ]
            pub fn msb_first(self) -> &'a mut W {
                self.variant(OrderW::MsbFirst)
            }
            # [ doc = "Least significant bit transmitted out first." ]
            # [ inline ( always ) ]
            pub fn lsb_first(self) -> &'a mut W {
                self.variant(OrderW::LsbFirst)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CPHA`" ]
        pub enum CphaW {
            # [ doc = "Sample on leading edge of the clock. Shift serial data on trailing edge." ]
            Leading,
            # [ doc = "Sample on trailing edge of the clock. Shift serial data on leading edge." ]
            Trailing,
        }
        impl CphaW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CphaW::Leading => 0,
                    CphaW::Trailing => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CphaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CphaW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CphaW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Sample on leading edge of the clock. Shift serial data on trailing edge." ]
            # [ inline ( always ) ]
            pub fn leading(self) -> &'a mut W {
                self.variant(CphaW::Leading)
            }
            # [ doc = "Sample on trailing edge of the clock. Shift serial data on leading edge." ]
            # [ inline ( always ) ]
            pub fn trailing(self) -> &'a mut W {
                self.variant(CphaW::Trailing)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CPOL`" ]
        pub enum CpolW {
            # [ doc = "Active high." ]
            ActiveHigh,
            # [ doc = "Active low." ]
            ActiveLow,
        }
        impl CpolW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CpolW::ActiveHigh => 0,
                    CpolW::ActiveLow => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CpolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CpolW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CpolW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Active high." ]
            # [ inline ( always ) ]
            pub fn active_high(self) -> &'a mut W {
                self.variant(CpolW::ActiveHigh)
            }
            # [ doc = "Active low." ]
            # [ inline ( always ) ]
            pub fn active_low(self) -> &'a mut W {
                self.variant(CpolW::ActiveLow)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Bit order." ]
            # [ inline ( always ) ]
            pub fn order(&self) -> OrderR {
                OrderR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Serial clock (SCK) phase." ]
            # [ inline ( always ) ]
            pub fn cpha(&self) -> CphaR {
                CphaR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Serial clock (SCK) polarity." ]
            # [ inline ( always ) ]
            pub fn cpol(&self) -> CpolR {
                CpolR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Bit order." ]
            # [ inline ( always ) ]
            pub fn order(&mut self) -> _OrderW {
                _OrderW { w: self }
            }
            # [ doc = "Bit 1 - Serial clock (SCK) phase." ]
            # [ inline ( always ) ]
            pub fn cpha(&mut self) -> _CphaW {
                _CphaW { w: self }
            }
            # [ doc = "Bit 2 - Serial clock (SCK) polarity." ]
            # [ inline ( always ) ]
            pub fn cpol(&mut self) -> _CpolW {
                _CpolW { w: self }
            }
        }
    }
    # [ doc = "Default character." ]
    pub struct Def {
        register: VolatileCell<u32>,
    }
    # [ doc = "Default character." ]
    pub mod def {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Def {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DefR {
            bits: u8,
        }
        impl DefR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DefW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DefW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Default character." ]
            # [ inline ( always ) ]
            pub fn def(&self) -> DefR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DefR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Default character." ]
            # [ inline ( always ) ]
            pub fn def(&mut self) -> _DefW {
                _DefW { w: self }
            }
        }
    }
    # [ doc = "Over-read character." ]
    pub struct Orc {
        register: VolatileCell<u32>,
    }
    # [ doc = "Over-read character." ]
    pub mod orc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Orc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OrcR {
            bits: u8,
        }
        impl OrcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OrcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OrcW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Over-read character." ]
            # [ inline ( always ) ]
            pub fn orc(&self) -> OrcR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OrcR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Over-read character." ]
            # [ inline ( always ) ]
            pub fn orc(&mut self) -> _OrcW {
                _OrcW { w: self }
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "SPI slave 1." ]
pub struct Spis1 {
    register_block: spis1::RegisterBlock,
}
impl Deref for Spis1 {
    type Target = spis1::RegisterBlock;
    fn deref(&self) -> &spis1::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "SPI master with easyDMA 1." ]
pub const SPIM1: Peripheral<Spim1> = unsafe { Peripheral::new(1073758208) };
# [ doc = "SPI master with easyDMA 1." ]
pub mod spim1 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 16usize],
        # [ doc = "0x10 - Start SPI transaction." ]
        pub tasks_start: TasksStart,
        # [ doc = "0x14 - Stop SPI transaction." ]
        pub tasks_stop: TasksStop,
        _reserved1: [u8; 4usize],
        # [ doc = "0x1c - Suspend SPI transaction." ]
        pub tasks_suspend: TasksSuspend,
        # [ doc = "0x20 - Resume SPI transaction." ]
        pub tasks_resume: TasksResume,
        _reserved2: [u8; 224usize],
        # [ doc = "0x104 - SPI transaction has stopped." ]
        pub events_stopped: EventsStopped,
        _reserved3: [u8; 8usize],
        # [ doc = "0x110 - End of RXD buffer reached." ]
        pub events_endrx: EventsEndrx,
        _reserved4: [u8; 12usize],
        # [ doc = "0x120 - End of TXD buffer reached." ]
        pub events_endtx: EventsEndtx,
        _reserved5: [u8; 40usize],
        # [ doc = "0x14c - Transaction started." ]
        pub events_started: EventsStarted,
        _reserved6: [u8; 436usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved7: [u8; 500usize],
        # [ doc = "0x500 - Enable SPIM." ]
        pub enable: Enable,
        _reserved8: [u8; 32usize],
        # [ doc = "0x524 - SPI frequency." ]
        pub frequency: Frequency,
        _reserved9: [u8; 44usize],
        # [ doc = "0x554 - Configuration register." ]
        pub config: Config,
        _reserved10: [u8; 104usize],
        # [ doc = "0x5c0 - Over-read character." ]
        pub orc: Orc,
        _reserved11: [u8; 2616usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Start SPI transaction." ]
    pub struct TasksStart {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start SPI transaction." ]
    pub mod tasks_start {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStart {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop SPI transaction." ]
    pub struct TasksStop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop SPI transaction." ]
    pub mod tasks_stop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Suspend SPI transaction." ]
    pub struct TasksSuspend {
        register: VolatileCell<u32>,
    }
    # [ doc = "Suspend SPI transaction." ]
    pub mod tasks_suspend {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksSuspend {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Resume SPI transaction." ]
    pub struct TasksResume {
        register: VolatileCell<u32>,
    }
    # [ doc = "Resume SPI transaction." ]
    pub mod tasks_resume {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksResume {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "SPI transaction has stopped." ]
    pub struct EventsStopped {
        register: VolatileCell<u32>,
    }
    # [ doc = "SPI transaction has stopped." ]
    pub mod events_stopped {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsStopped {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "End of RXD buffer reached." ]
    pub struct EventsEndrx {
        register: VolatileCell<u32>,
    }
    # [ doc = "End of RXD buffer reached." ]
    pub mod events_endrx {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsEndrx {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "End of TXD buffer reached." ]
    pub struct EventsEndtx {
        register: VolatileCell<u32>,
    }
    # [ doc = "End of TXD buffer reached." ]
    pub mod events_endtx {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsEndtx {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Transaction started." ]
    pub struct EventsStarted {
        register: VolatileCell<u32>,
    }
    # [ doc = "Transaction started." ]
    pub mod events_started {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsStarted {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `STOPPED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum StoppedR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl StoppedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    StoppedR::Disabled => 0,
                    StoppedR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> StoppedR {
                match bits {
                    0 => StoppedR::Disabled,
                    1 => StoppedR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == StoppedR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == StoppedR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ENDRX`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndrxR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndrxR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndrxR::Disabled => 0,
                    EndrxR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndrxR {
                match bits {
                    0 => EndrxR::Disabled,
                    1 => EndrxR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndrxR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndrxR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ENDTX`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndtxR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndtxR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndtxR::Disabled => 0,
                    EndtxR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndtxR {
                match bits {
                    0 => EndtxR::Disabled,
                    1 => EndtxR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndtxR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndtxR::Enabled
            }
        }
        # [ doc = "Possible values of the field `STARTED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum StartedR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl StartedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    StartedR::Disabled => 0,
                    StartedR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> StartedR {
                match bits {
                    0 => StartedR::Disabled,
                    1 => StartedR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == StartedR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == StartedR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `STOPPED`" ]
        pub enum StoppedW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl StoppedW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    StoppedW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _StoppedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StoppedW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: StoppedW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(StoppedW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ENDRX`" ]
        pub enum EndrxW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl EndrxW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndrxW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndrxW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndrxW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndrxW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(EndrxW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ENDTX`" ]
        pub enum EndtxW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl EndtxW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndtxW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndtxW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndtxW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndtxW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(EndtxW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `STARTED`" ]
        pub enum StartedW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl StartedW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    StartedW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _StartedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StartedW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: StartedW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(StartedW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 1 - Enable interrupt on STOPPED event." ]
            # [ inline ( always ) ]
            pub fn stopped(&self) -> StoppedR {
                StoppedR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Enable interrupt on ENDRX event." ]
            # [ inline ( always ) ]
            pub fn endrx(&self) -> EndrxR {
                EndrxR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Enable interrupt on ENDTX event." ]
            # [ inline ( always ) ]
            pub fn endtx(&self) -> EndtxR {
                EndtxR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Enable interrupt on STARTED event." ]
            # [ inline ( always ) ]
            pub fn started(&self) -> StartedR {
                StartedR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 1 - Enable interrupt on STOPPED event." ]
            # [ inline ( always ) ]
            pub fn stopped(&mut self) -> _StoppedW {
                _StoppedW { w: self }
            }
            # [ doc = "Bit 4 - Enable interrupt on ENDRX event." ]
            # [ inline ( always ) ]
            pub fn endrx(&mut self) -> _EndrxW {
                _EndrxW { w: self }
            }
            # [ doc = "Bit 8 - Enable interrupt on ENDTX event." ]
            # [ inline ( always ) ]
            pub fn endtx(&mut self) -> _EndtxW {
                _EndtxW { w: self }
            }
            # [ doc = "Bit 19 - Enable interrupt on STARTED event." ]
            # [ inline ( always ) ]
            pub fn started(&mut self) -> _StartedW {
                _StartedW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `STOPPED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum StoppedR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl StoppedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    StoppedR::Disabled => 0,
                    StoppedR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> StoppedR {
                match bits {
                    0 => StoppedR::Disabled,
                    1 => StoppedR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == StoppedR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == StoppedR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ENDRX`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndrxR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndrxR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndrxR::Disabled => 0,
                    EndrxR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndrxR {
                match bits {
                    0 => EndrxR::Disabled,
                    1 => EndrxR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndrxR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndrxR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ENDTX`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndtxR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndtxR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndtxR::Disabled => 0,
                    EndtxR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndtxR {
                match bits {
                    0 => EndtxR::Disabled,
                    1 => EndtxR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndtxR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndtxR::Enabled
            }
        }
        # [ doc = "Possible values of the field `STARTED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum StartedR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl StartedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    StartedR::Disabled => 0,
                    StartedR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> StartedR {
                match bits {
                    0 => StartedR::Disabled,
                    1 => StartedR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == StartedR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == StartedR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `STOPPED`" ]
        pub enum StoppedW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl StoppedW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    StoppedW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _StoppedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StoppedW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: StoppedW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(StoppedW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ENDRX`" ]
        pub enum EndrxW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl EndrxW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndrxW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndrxW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndrxW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndrxW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(EndrxW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ENDTX`" ]
        pub enum EndtxW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl EndtxW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndtxW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndtxW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndtxW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndtxW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(EndtxW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `STARTED`" ]
        pub enum StartedW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl StartedW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    StartedW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _StartedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StartedW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: StartedW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(StartedW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 1 - Disable interrupt on STOPPED event." ]
            # [ inline ( always ) ]
            pub fn stopped(&self) -> StoppedR {
                StoppedR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Disable interrupt on ENDRX event." ]
            # [ inline ( always ) ]
            pub fn endrx(&self) -> EndrxR {
                EndrxR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Disable interrupt on ENDTX event." ]
            # [ inline ( always ) ]
            pub fn endtx(&self) -> EndtxR {
                EndtxR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Disable interrupt on STARTED event." ]
            # [ inline ( always ) ]
            pub fn started(&self) -> StartedR {
                StartedR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 1 - Disable interrupt on STOPPED event." ]
            # [ inline ( always ) ]
            pub fn stopped(&mut self) -> _StoppedW {
                _StoppedW { w: self }
            }
            # [ doc = "Bit 4 - Disable interrupt on ENDRX event." ]
            # [ inline ( always ) ]
            pub fn endrx(&mut self) -> _EndrxW {
                _EndrxW { w: self }
            }
            # [ doc = "Bit 8 - Disable interrupt on ENDTX event." ]
            # [ inline ( always ) ]
            pub fn endtx(&mut self) -> _EndtxW {
                _EndtxW { w: self }
            }
            # [ doc = "Bit 19 - Disable interrupt on STARTED event." ]
            # [ inline ( always ) ]
            pub fn started(&mut self) -> _StartedW {
                _StartedW { w: self }
            }
        }
    }
    # [ doc = "Enable SPIM." ]
    pub struct Enable {
        register: VolatileCell<u32>,
    }
    # [ doc = "Enable SPIM." ]
    pub mod enable {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Enable {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ENABLE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EnableR {
            # [ doc = "Disabled SPIM." ]
            Disabled,
            # [ doc = "Enable SPIM." ]
            Enabled,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl EnableR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EnableR::Disabled => 0,
                    EnableR::Enabled => 7,
                    EnableR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EnableR {
                match bits {
                    0 => EnableR::Disabled,
                    7 => EnableR::Enabled,
                    i => EnableR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EnableR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EnableR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `ENABLE`" ]
        pub enum EnableW {
            # [ doc = "Disabled SPIM." ]
            Disabled,
            # [ doc = "Enable SPIM." ]
            Enabled,
        }
        impl EnableW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EnableW::Disabled => 0,
                    EnableW::Enabled => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnableW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnableW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EnableW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disabled SPIM." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EnableW::Disabled)
            }
            # [ doc = "Enable SPIM." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EnableW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - Enable or disable SPIM." ]
            # [ inline ( always ) ]
            pub fn enable(&self) -> EnableR {
                EnableR::_from(
                    {
                        const MASK: u8 = 15;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:3 - Enable or disable SPIM." ]
            # [ inline ( always ) ]
            pub fn enable(&mut self) -> _EnableW {
                _EnableW { w: self }
            }
        }
    }
    # [ doc = "SPI frequency." ]
    pub struct Frequency {
        register: VolatileCell<u32>,
    }
    # [ doc = "SPI frequency." ]
    pub mod frequency {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Frequency {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `FREQUENCY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum FrequencyR {
            # [ doc = "125 kbps." ]
            K125,
            # [ doc = "250 kbps." ]
            K250,
            # [ doc = "500 kbps." ]
            K500,
            # [ doc = "1 Mbps." ]
            M1,
            # [ doc = "2 Mbps." ]
            M2,
            # [ doc = "4 Mbps." ]
            M4,
            # [ doc = "8 Mbps." ]
            M8,
            # [ doc = r" Reserved" ]
            _Reserved(u32),
        }
        impl FrequencyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                match *self {
                    FrequencyR::K125 => 33554432,
                    FrequencyR::K250 => 67108864,
                    FrequencyR::K500 => 134217728,
                    FrequencyR::M1 => 268435456,
                    FrequencyR::M2 => 536870912,
                    FrequencyR::M4 => 1073741824,
                    FrequencyR::M8 => 2147483648,
                    FrequencyR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u32) -> FrequencyR {
                match bits {
                    33554432 => FrequencyR::K125,
                    67108864 => FrequencyR::K250,
                    134217728 => FrequencyR::K500,
                    268435456 => FrequencyR::M1,
                    536870912 => FrequencyR::M2,
                    1073741824 => FrequencyR::M4,
                    2147483648 => FrequencyR::M8,
                    i => FrequencyR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `K125`" ]
            # [ inline ( always ) ]
            pub fn is_k125(&self) -> bool {
                *self == FrequencyR::K125
            }
            # [ doc = "Checks if the value of the field is `K250`" ]
            # [ inline ( always ) ]
            pub fn is_k250(&self) -> bool {
                *self == FrequencyR::K250
            }
            # [ doc = "Checks if the value of the field is `K500`" ]
            # [ inline ( always ) ]
            pub fn is_k500(&self) -> bool {
                *self == FrequencyR::K500
            }
            # [ doc = "Checks if the value of the field is `M1`" ]
            # [ inline ( always ) ]
            pub fn is_m1(&self) -> bool {
                *self == FrequencyR::M1
            }
            # [ doc = "Checks if the value of the field is `M2`" ]
            # [ inline ( always ) ]
            pub fn is_m2(&self) -> bool {
                *self == FrequencyR::M2
            }
            # [ doc = "Checks if the value of the field is `M4`" ]
            # [ inline ( always ) ]
            pub fn is_m4(&self) -> bool {
                *self == FrequencyR::M4
            }
            # [ doc = "Checks if the value of the field is `M8`" ]
            # [ inline ( always ) ]
            pub fn is_m8(&self) -> bool {
                *self == FrequencyR::M8
            }
        }
        # [ doc = "Values that can be written to the field `FREQUENCY`" ]
        pub enum FrequencyW {
            # [ doc = "125 kbps." ]
            K125,
            # [ doc = "250 kbps." ]
            K250,
            # [ doc = "500 kbps." ]
            K500,
            # [ doc = "1 Mbps." ]
            M1,
            # [ doc = "2 Mbps." ]
            M2,
            # [ doc = "4 Mbps." ]
            M4,
            # [ doc = "8 Mbps." ]
            M8,
        }
        impl FrequencyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u32 {
                match *self {
                    FrequencyW::K125 => 33554432,
                    FrequencyW::K250 => 67108864,
                    FrequencyW::K500 => 134217728,
                    FrequencyW::M1 => 268435456,
                    FrequencyW::M2 => 536870912,
                    FrequencyW::M4 => 1073741824,
                    FrequencyW::M8 => 2147483648,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FrequencyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FrequencyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: FrequencyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "125 kbps." ]
            # [ inline ( always ) ]
            pub fn k125(self) -> &'a mut W {
                self.variant(FrequencyW::K125)
            }
            # [ doc = "250 kbps." ]
            # [ inline ( always ) ]
            pub fn k250(self) -> &'a mut W {
                self.variant(FrequencyW::K250)
            }
            # [ doc = "500 kbps." ]
            # [ inline ( always ) ]
            pub fn k500(self) -> &'a mut W {
                self.variant(FrequencyW::K500)
            }
            # [ doc = "1 Mbps." ]
            # [ inline ( always ) ]
            pub fn m1(self) -> &'a mut W {
                self.variant(FrequencyW::M1)
            }
            # [ doc = "2 Mbps." ]
            # [ inline ( always ) ]
            pub fn m2(self) -> &'a mut W {
                self.variant(FrequencyW::M2)
            }
            # [ doc = "4 Mbps." ]
            # [ inline ( always ) ]
            pub fn m4(self) -> &'a mut W {
                self.variant(FrequencyW::M4)
            }
            # [ doc = "8 Mbps." ]
            # [ inline ( always ) ]
            pub fn m8(self) -> &'a mut W {
                self.variant(FrequencyW::M8)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - SPI master data rate." ]
            # [ inline ( always ) ]
            pub fn frequency(&self) -> FrequencyR {
                FrequencyR::_from(
                    {
                        const MASK: u32 = 4294967295;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u32
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 67108864 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - SPI master data rate." ]
            # [ inline ( always ) ]
            pub fn frequency(&mut self) -> _FrequencyW {
                _FrequencyW { w: self }
            }
        }
    }
    # [ doc = "Configuration register." ]
    pub struct Config {
        register: VolatileCell<u32>,
    }
    # [ doc = "Configuration register." ]
    pub mod config {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Config {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ORDER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OrderR {
            # [ doc = "Most significant bit transmitted out first." ]
            MsbFirst,
            # [ doc = "Least significant bit transmitted out first." ]
            LsbFirst,
        }
        impl OrderR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OrderR::MsbFirst => 0,
                    OrderR::LsbFirst => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OrderR {
                match bits {
                    0 => OrderR::MsbFirst,
                    1 => OrderR::LsbFirst,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `MsbFirst`" ]
            # [ inline ( always ) ]
            pub fn is_msb_first(&self) -> bool {
                *self == OrderR::MsbFirst
            }
            # [ doc = "Checks if the value of the field is `LsbFirst`" ]
            # [ inline ( always ) ]
            pub fn is_lsb_first(&self) -> bool {
                *self == OrderR::LsbFirst
            }
        }
        # [ doc = "Possible values of the field `CPHA`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CphaR {
            # [ doc = "Sample on leading edge of the clock. Shift serial data on trailing edge." ]
            Leading,
            # [ doc = "Sample on trailing edge of the clock. Shift serial data on leading edge." ]
            Trailing,
        }
        impl CphaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CphaR::Leading => 0,
                    CphaR::Trailing => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CphaR {
                match bits {
                    0 => CphaR::Leading,
                    1 => CphaR::Trailing,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Leading`" ]
            # [ inline ( always ) ]
            pub fn is_leading(&self) -> bool {
                *self == CphaR::Leading
            }
            # [ doc = "Checks if the value of the field is `Trailing`" ]
            # [ inline ( always ) ]
            pub fn is_trailing(&self) -> bool {
                *self == CphaR::Trailing
            }
        }
        # [ doc = "Possible values of the field `CPOL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CpolR {
            # [ doc = "Active high." ]
            ActiveHigh,
            # [ doc = "Active low." ]
            ActiveLow,
        }
        impl CpolR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CpolR::ActiveHigh => 0,
                    CpolR::ActiveLow => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CpolR {
                match bits {
                    0 => CpolR::ActiveHigh,
                    1 => CpolR::ActiveLow,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `ActiveHigh`" ]
            # [ inline ( always ) ]
            pub fn is_active_high(&self) -> bool {
                *self == CpolR::ActiveHigh
            }
            # [ doc = "Checks if the value of the field is `ActiveLow`" ]
            # [ inline ( always ) ]
            pub fn is_active_low(&self) -> bool {
                *self == CpolR::ActiveLow
            }
        }
        # [ doc = "Values that can be written to the field `ORDER`" ]
        pub enum OrderW {
            # [ doc = "Most significant bit transmitted out first." ]
            MsbFirst,
            # [ doc = "Least significant bit transmitted out first." ]
            LsbFirst,
        }
        impl OrderW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OrderW::MsbFirst => 0,
                    OrderW::LsbFirst => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OrderW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OrderW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OrderW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Most significant bit transmitted out first." ]
            # [ inline ( always ) ]
            pub fn msb_first(self) -> &'a mut W {
                self.variant(OrderW::MsbFirst)
            }
            # [ doc = "Least significant bit transmitted out first." ]
            # [ inline ( always ) ]
            pub fn lsb_first(self) -> &'a mut W {
                self.variant(OrderW::LsbFirst)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CPHA`" ]
        pub enum CphaW {
            # [ doc = "Sample on leading edge of the clock. Shift serial data on trailing edge." ]
            Leading,
            # [ doc = "Sample on trailing edge of the clock. Shift serial data on leading edge." ]
            Trailing,
        }
        impl CphaW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CphaW::Leading => 0,
                    CphaW::Trailing => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CphaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CphaW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CphaW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Sample on leading edge of the clock. Shift serial data on trailing edge." ]
            # [ inline ( always ) ]
            pub fn leading(self) -> &'a mut W {
                self.variant(CphaW::Leading)
            }
            # [ doc = "Sample on trailing edge of the clock. Shift serial data on leading edge." ]
            # [ inline ( always ) ]
            pub fn trailing(self) -> &'a mut W {
                self.variant(CphaW::Trailing)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CPOL`" ]
        pub enum CpolW {
            # [ doc = "Active high." ]
            ActiveHigh,
            # [ doc = "Active low." ]
            ActiveLow,
        }
        impl CpolW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CpolW::ActiveHigh => 0,
                    CpolW::ActiveLow => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CpolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CpolW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CpolW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Active high." ]
            # [ inline ( always ) ]
            pub fn active_high(self) -> &'a mut W {
                self.variant(CpolW::ActiveHigh)
            }
            # [ doc = "Active low." ]
            # [ inline ( always ) ]
            pub fn active_low(self) -> &'a mut W {
                self.variant(CpolW::ActiveLow)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Bit order." ]
            # [ inline ( always ) ]
            pub fn order(&self) -> OrderR {
                OrderR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Serial clock (SCK) phase." ]
            # [ inline ( always ) ]
            pub fn cpha(&self) -> CphaR {
                CphaR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Serial clock (SCK) polarity." ]
            # [ inline ( always ) ]
            pub fn cpol(&self) -> CpolR {
                CpolR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Bit order." ]
            # [ inline ( always ) ]
            pub fn order(&mut self) -> _OrderW {
                _OrderW { w: self }
            }
            # [ doc = "Bit 1 - Serial clock (SCK) phase." ]
            # [ inline ( always ) ]
            pub fn cpha(&mut self) -> _CphaW {
                _CphaW { w: self }
            }
            # [ doc = "Bit 2 - Serial clock (SCK) polarity." ]
            # [ inline ( always ) ]
            pub fn cpol(&mut self) -> _CpolW {
                _CpolW { w: self }
            }
        }
    }
    # [ doc = "Over-read character." ]
    pub struct Orc {
        register: VolatileCell<u32>,
    }
    # [ doc = "Over-read character." ]
    pub mod orc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Orc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OrcR {
            bits: u8,
        }
        impl OrcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OrcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OrcW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Over-read character." ]
            # [ inline ( always ) ]
            pub fn orc(&self) -> OrcR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OrcR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Over-read character." ]
            # [ inline ( always ) ]
            pub fn orc(&mut self) -> _OrcW {
                _OrcW { w: self }
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "SPI master with easyDMA 1." ]
pub struct Spim1 {
    register_block: spim1::RegisterBlock,
}
impl Deref for Spim1 {
    type Target = spim1::RegisterBlock;
    fn deref(&self) -> &spim1::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "GPIO tasks and events." ]
pub const GPIOTE: Peripheral<Gpiote> = unsafe { Peripheral::new(1073766400) };
# [ doc = "GPIO tasks and events." ]
pub mod gpiote {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Tasks asssociated with GPIOTE channels." ]
        pub tasks_out0: TasksOut,
        # [ doc = "0x04 - Tasks asssociated with GPIOTE channels." ]
        pub tasks_out1: TasksOut,
        # [ doc = "0x08 - Tasks asssociated with GPIOTE channels." ]
        pub tasks_out2: TasksOut,
        # [ doc = "0x0c - Tasks asssociated with GPIOTE channels." ]
        pub tasks_out3: TasksOut,
        _reserved0: [u8; 240usize],
        # [ doc = "0x100 - Tasks asssociated with GPIOTE channels." ]
        pub events_in0: EventsIn,
        # [ doc = "0x104 - Tasks asssociated with GPIOTE channels." ]
        pub events_in1: EventsIn,
        # [ doc = "0x108 - Tasks asssociated with GPIOTE channels." ]
        pub events_in2: EventsIn,
        # [ doc = "0x10c - Tasks asssociated with GPIOTE channels." ]
        pub events_in3: EventsIn,
        _reserved1: [u8; 108usize],
        # [ doc = "0x17c - Event generated from multiple pins." ]
        pub events_port: EventsPort,
        _reserved2: [u8; 388usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved3: [u8; 516usize],
        # [ doc = "0x510 - Channel configuration registers." ]
        pub config0: Config,
        # [ doc = "0x514 - Channel configuration registers." ]
        pub config1: Config,
        # [ doc = "0x518 - Channel configuration registers." ]
        pub config2: Config,
        # [ doc = "0x51c - Channel configuration registers." ]
        pub config3: Config,
        _reserved4: [u8; 2780usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Tasks asssociated with GPIOTE channels." ]
    pub struct TasksOut {
        register: VolatileCell<u32>,
    }
    # [ doc = "Tasks asssociated with GPIOTE channels." ]
    pub mod tasks_out {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksOut {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Tasks asssociated with GPIOTE channels." ]
    pub struct EventsIn {
        register: VolatileCell<u32>,
    }
    # [ doc = "Tasks asssociated with GPIOTE channels." ]
    pub mod events_in {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsIn {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Event generated from multiple pins." ]
    pub struct EventsPort {
        register: VolatileCell<u32>,
    }
    # [ doc = "Event generated from multiple pins." ]
    pub mod events_port {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsPort {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `IN0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum In0R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl In0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    In0R::Disabled => 0,
                    In0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> In0R {
                match bits {
                    0 => In0R::Disabled,
                    1 => In0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == In0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == In0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `IN1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum In1R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl In1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    In1R::Disabled => 0,
                    In1R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> In1R {
                match bits {
                    0 => In1R::Disabled,
                    1 => In1R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == In1R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == In1R::Enabled
            }
        }
        # [ doc = "Possible values of the field `IN2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum In2R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl In2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    In2R::Disabled => 0,
                    In2R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> In2R {
                match bits {
                    0 => In2R::Disabled,
                    1 => In2R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == In2R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == In2R::Enabled
            }
        }
        # [ doc = "Possible values of the field `IN3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum In3R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl In3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    In3R::Disabled => 0,
                    In3R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> In3R {
                match bits {
                    0 => In3R::Disabled,
                    1 => In3R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == In3R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == In3R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PORT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PortR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl PortR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PortR::Disabled => 0,
                    PortR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PortR {
                match bits {
                    0 => PortR::Disabled,
                    1 => PortR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PortR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PortR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `IN0`" ]
        pub enum In0W {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl In0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    In0W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _In0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _In0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: In0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(In0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `IN1`" ]
        pub enum In1W {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl In1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    In1W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _In1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _In1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: In1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(In1W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `IN2`" ]
        pub enum In2W {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl In2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    In2W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _In2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _In2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: In2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(In2W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `IN3`" ]
        pub enum In3W {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl In3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    In3W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _In3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _In3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: In3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(In3W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PORT`" ]
        pub enum PortW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl PortW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PortW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PortW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PortW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PortW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(PortW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable interrupt on IN[0] event." ]
            # [ inline ( always ) ]
            pub fn in0(&self) -> In0R {
                In0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Enable interrupt on IN[1] event." ]
            # [ inline ( always ) ]
            pub fn in1(&self) -> In1R {
                In1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Enable interrupt on IN[2] event." ]
            # [ inline ( always ) ]
            pub fn in2(&self) -> In2R {
                In2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Enable interrupt on IN[3] event." ]
            # [ inline ( always ) ]
            pub fn in3(&self) -> In3R {
                In3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 31 - Enable interrupt on PORT event." ]
            # [ inline ( always ) ]
            pub fn port(&self) -> PortR {
                PortR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable interrupt on IN[0] event." ]
            # [ inline ( always ) ]
            pub fn in0(&mut self) -> _In0W {
                _In0W { w: self }
            }
            # [ doc = "Bit 1 - Enable interrupt on IN[1] event." ]
            # [ inline ( always ) ]
            pub fn in1(&mut self) -> _In1W {
                _In1W { w: self }
            }
            # [ doc = "Bit 2 - Enable interrupt on IN[2] event." ]
            # [ inline ( always ) ]
            pub fn in2(&mut self) -> _In2W {
                _In2W { w: self }
            }
            # [ doc = "Bit 3 - Enable interrupt on IN[3] event." ]
            # [ inline ( always ) ]
            pub fn in3(&mut self) -> _In3W {
                _In3W { w: self }
            }
            # [ doc = "Bit 31 - Enable interrupt on PORT event." ]
            # [ inline ( always ) ]
            pub fn port(&mut self) -> _PortW {
                _PortW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `IN0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum In0R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl In0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    In0R::Disabled => 0,
                    In0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> In0R {
                match bits {
                    0 => In0R::Disabled,
                    1 => In0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == In0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == In0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `IN1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum In1R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl In1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    In1R::Disabled => 0,
                    In1R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> In1R {
                match bits {
                    0 => In1R::Disabled,
                    1 => In1R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == In1R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == In1R::Enabled
            }
        }
        # [ doc = "Possible values of the field `IN2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum In2R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl In2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    In2R::Disabled => 0,
                    In2R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> In2R {
                match bits {
                    0 => In2R::Disabled,
                    1 => In2R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == In2R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == In2R::Enabled
            }
        }
        # [ doc = "Possible values of the field `IN3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum In3R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl In3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    In3R::Disabled => 0,
                    In3R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> In3R {
                match bits {
                    0 => In3R::Disabled,
                    1 => In3R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == In3R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == In3R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PORT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PortR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl PortR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PortR::Disabled => 0,
                    PortR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PortR {
                match bits {
                    0 => PortR::Disabled,
                    1 => PortR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PortR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PortR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `IN0`" ]
        pub enum In0W {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl In0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    In0W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _In0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _In0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: In0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(In0W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `IN1`" ]
        pub enum In1W {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl In1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    In1W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _In1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _In1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: In1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(In1W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `IN2`" ]
        pub enum In2W {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl In2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    In2W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _In2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _In2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: In2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(In2W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `IN3`" ]
        pub enum In3W {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl In3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    In3W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _In3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _In3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: In3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(In3W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PORT`" ]
        pub enum PortW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl PortW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PortW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PortW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PortW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PortW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(PortW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable interrupt on IN[0] event." ]
            # [ inline ( always ) ]
            pub fn in0(&self) -> In0R {
                In0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Disable interrupt on IN[1] event." ]
            # [ inline ( always ) ]
            pub fn in1(&self) -> In1R {
                In1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Disable interrupt on IN[2] event." ]
            # [ inline ( always ) ]
            pub fn in2(&self) -> In2R {
                In2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Disable interrupt on IN[3] event." ]
            # [ inline ( always ) ]
            pub fn in3(&self) -> In3R {
                In3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 31 - Disable interrupt on PORT event." ]
            # [ inline ( always ) ]
            pub fn port(&self) -> PortR {
                PortR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable interrupt on IN[0] event." ]
            # [ inline ( always ) ]
            pub fn in0(&mut self) -> _In0W {
                _In0W { w: self }
            }
            # [ doc = "Bit 1 - Disable interrupt on IN[1] event." ]
            # [ inline ( always ) ]
            pub fn in1(&mut self) -> _In1W {
                _In1W { w: self }
            }
            # [ doc = "Bit 2 - Disable interrupt on IN[2] event." ]
            # [ inline ( always ) ]
            pub fn in2(&mut self) -> _In2W {
                _In2W { w: self }
            }
            # [ doc = "Bit 3 - Disable interrupt on IN[3] event." ]
            # [ inline ( always ) ]
            pub fn in3(&mut self) -> _In3W {
                _In3W { w: self }
            }
            # [ doc = "Bit 31 - Disable interrupt on PORT event." ]
            # [ inline ( always ) ]
            pub fn port(&mut self) -> _PortW {
                _PortW { w: self }
            }
        }
    }
    # [ doc = "Channel configuration registers." ]
    pub struct Config {
        register: VolatileCell<u32>,
    }
    # [ doc = "Channel configuration registers." ]
    pub mod config {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Config {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `MODE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ModeR {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Channel configure in event mode." ]
            Event,
            # [ doc = "Channel configure in task mode." ]
            Task,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl ModeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ModeR::Disabled => 0,
                    ModeR::Event => 1,
                    ModeR::Task => 3,
                    ModeR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ModeR {
                match bits {
                    0 => ModeR::Disabled,
                    1 => ModeR::Event,
                    3 => ModeR::Task,
                    i => ModeR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ModeR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Event`" ]
            # [ inline ( always ) ]
            pub fn is_event(&self) -> bool {
                *self == ModeR::Event
            }
            # [ doc = "Checks if the value of the field is `Task`" ]
            # [ inline ( always ) ]
            pub fn is_task(&self) -> bool {
                *self == ModeR::Task
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PselR {
            bits: u8,
        }
        impl PselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `POLARITY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PolarityR {
            # [ doc = "No task or event." ]
            None,
            # [ doc = "Low to high." ]
            LoToHi,
            # [ doc = "High to low." ]
            HiToLo,
            # [ doc = "Toggle." ]
            Toggle,
        }
        impl PolarityR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PolarityR::None => 0,
                    PolarityR::LoToHi => 1,
                    PolarityR::HiToLo => 2,
                    PolarityR::Toggle => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PolarityR {
                match bits {
                    0 => PolarityR::None,
                    1 => PolarityR::LoToHi,
                    2 => PolarityR::HiToLo,
                    3 => PolarityR::Toggle,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `None`" ]
            # [ inline ( always ) ]
            pub fn is_none(&self) -> bool {
                *self == PolarityR::None
            }
            # [ doc = "Checks if the value of the field is `LoToHi`" ]
            # [ inline ( always ) ]
            pub fn is_lo_to_hi(&self) -> bool {
                *self == PolarityR::LoToHi
            }
            # [ doc = "Checks if the value of the field is `HiToLo`" ]
            # [ inline ( always ) ]
            pub fn is_hi_to_lo(&self) -> bool {
                *self == PolarityR::HiToLo
            }
            # [ doc = "Checks if the value of the field is `Toggle`" ]
            # [ inline ( always ) ]
            pub fn is_toggle(&self) -> bool {
                *self == PolarityR::Toggle
            }
        }
        # [ doc = "Possible values of the field `OUTINIT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OutinitR {
            # [ doc = "Initial low output when in task mode." ]
            Low,
            # [ doc = "Initial high output when in task mode." ]
            High,
        }
        impl OutinitR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OutinitR::Low => 0,
                    OutinitR::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OutinitR {
                match bits {
                    0 => OutinitR::Low,
                    1 => OutinitR::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == OutinitR::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == OutinitR::High
            }
        }
        # [ doc = "Values that can be written to the field `MODE`" ]
        pub enum ModeW {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Channel configure in event mode." ]
            Event,
            # [ doc = "Channel configure in task mode." ]
            Task,
        }
        impl ModeW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ModeW::Disabled => 0,
                    ModeW::Event => 1,
                    ModeW::Task => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ModeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ModeW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ModeW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ModeW::Disabled)
            }
            # [ doc = "Channel configure in event mode." ]
            # [ inline ( always ) ]
            pub fn event(self) -> &'a mut W {
                self.variant(ModeW::Event)
            }
            # [ doc = "Channel configure in task mode." ]
            # [ inline ( always ) ]
            pub fn task(self) -> &'a mut W {
                self.variant(ModeW::Task)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PselW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `POLARITY`" ]
        pub enum PolarityW {
            # [ doc = "No task or event." ]
            None,
            # [ doc = "Low to high." ]
            LoToHi,
            # [ doc = "High to low." ]
            HiToLo,
            # [ doc = "Toggle." ]
            Toggle,
        }
        impl PolarityW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PolarityW::None => 0,
                    PolarityW::LoToHi => 1,
                    PolarityW::HiToLo => 2,
                    PolarityW::Toggle => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PolarityW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PolarityW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PolarityW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "No task or event." ]
            # [ inline ( always ) ]
            pub fn none(self) -> &'a mut W {
                self.variant(PolarityW::None)
            }
            # [ doc = "Low to high." ]
            # [ inline ( always ) ]
            pub fn lo_to_hi(self) -> &'a mut W {
                self.variant(PolarityW::LoToHi)
            }
            # [ doc = "High to low." ]
            # [ inline ( always ) ]
            pub fn hi_to_lo(self) -> &'a mut W {
                self.variant(PolarityW::HiToLo)
            }
            # [ doc = "Toggle." ]
            # [ inline ( always ) ]
            pub fn toggle(self) -> &'a mut W {
                self.variant(PolarityW::Toggle)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OUTINIT`" ]
        pub enum OutinitW {
            # [ doc = "Initial low output when in task mode." ]
            Low,
            # [ doc = "Initial high output when in task mode." ]
            High,
        }
        impl OutinitW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OutinitW::Low => 0,
                    OutinitW::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutinitW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutinitW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OutinitW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Initial low output when in task mode." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(OutinitW::Low)
            }
            # [ doc = "Initial high output when in task mode." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(OutinitW::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - Mode" ]
            # [ inline ( always ) ]
            pub fn mode(&self) -> ModeR {
                ModeR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bits 8:12 - Pin select." ]
            # [ inline ( always ) ]
            pub fn psel(&self) -> PselR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PselR { bits }
            }
            # [ doc = "Bits 16:17 - Effects on output when in Task mode, or events on input that generates an event." ]
            # [ inline ( always ) ]
            pub fn polarity(&self) -> PolarityR {
                PolarityR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 20 - Initial value of the output when the GPIOTE channel is configured as a Task." ]
            # [ inline ( always ) ]
            pub fn outinit(&self) -> OutinitR {
                OutinitR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 20;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - Mode" ]
            # [ inline ( always ) ]
            pub fn mode(&mut self) -> _ModeW {
                _ModeW { w: self }
            }
            # [ doc = "Bits 8:12 - Pin select." ]
            # [ inline ( always ) ]
            pub fn psel(&mut self) -> _PselW {
                _PselW { w: self }
            }
            # [ doc = "Bits 16:17 - Effects on output when in Task mode, or events on input that generates an event." ]
            # [ inline ( always ) ]
            pub fn polarity(&mut self) -> _PolarityW {
                _PolarityW { w: self }
            }
            # [ doc = "Bit 20 - Initial value of the output when the GPIOTE channel is configured as a Task." ]
            # [ inline ( always ) ]
            pub fn outinit(&mut self) -> _OutinitW {
                _OutinitW { w: self }
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "GPIO tasks and events." ]
pub struct Gpiote {
    register_block: gpiote::RegisterBlock,
}
impl Deref for Gpiote {
    type Target = gpiote::RegisterBlock;
    fn deref(&self) -> &gpiote::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Analog to digital converter." ]
pub const ADC: Peripheral<Adc> = unsafe { Peripheral::new(1073770496) };
# [ doc = "Analog to digital converter." ]
pub mod adc {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Start an ADC conversion." ]
        pub tasks_start: TasksStart,
        # [ doc = "0x04 - Stop ADC." ]
        pub tasks_stop: TasksStop,
        _reserved0: [u8; 248usize],
        # [ doc = "0x100 - ADC conversion complete." ]
        pub events_end: EventsEnd,
        _reserved1: [u8; 512usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved2: [u8; 244usize],
        # [ doc = "0x400 - ADC busy register." ]
        pub busy: Busy,
        _reserved3: [u8; 252usize],
        # [ doc = "0x500 - ADC enable." ]
        pub enable: Enable,
        # [ doc = "0x504 - ADC configuration register." ]
        pub config: Config,
        # [ doc = "0x508 - Result of ADC conversion." ]
        pub result: Result,
        _reserved4: [u8; 2800usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Start an ADC conversion." ]
    pub struct TasksStart {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start an ADC conversion." ]
    pub mod tasks_start {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStart {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop ADC." ]
    pub struct TasksStop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop ADC." ]
    pub mod tasks_stop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "ADC conversion complete." ]
    pub struct EventsEnd {
        register: VolatileCell<u32>,
    }
    # [ doc = "ADC conversion complete." ]
    pub mod events_end {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsEnd {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `END`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndR::Disabled => 0,
                    EndR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndR {
                match bits {
                    0 => EndR::Disabled,
                    1 => EndR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `END`" ]
        pub enum EndW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl EndW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(EndW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable interrupt on END event." ]
            # [ inline ( always ) ]
            pub fn end(&self) -> EndR {
                EndR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable interrupt on END event." ]
            # [ inline ( always ) ]
            pub fn end(&mut self) -> _EndW {
                _EndW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `END`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndR::Disabled => 0,
                    EndR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndR {
                match bits {
                    0 => EndR::Disabled,
                    1 => EndR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `END`" ]
        pub enum EndW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl EndW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(EndW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable interrupt on END event." ]
            # [ inline ( always ) ]
            pub fn end(&self) -> EndR {
                EndR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable interrupt on END event." ]
            # [ inline ( always ) ]
            pub fn end(&mut self) -> _EndW {
                _EndW { w: self }
            }
        }
    }
    # [ doc = "ADC busy register." ]
    pub struct Busy {
        register: VolatileCell<u32>,
    }
    # [ doc = "ADC busy register." ]
    pub mod busy {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Busy {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = "Possible values of the field `BUSY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum BusyR {
            # [ doc = "No ongoing ADC conversion is taking place. ADC is ready." ]
            Ready,
            # [ doc = "An ADC conversion is taking place. ADC is busy." ]
            Busy,
        }
        impl BusyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    BusyR::Ready => 0,
                    BusyR::Busy => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> BusyR {
                match bits {
                    0 => BusyR::Ready,
                    1 => BusyR::Busy,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ready`" ]
            # [ inline ( always ) ]
            pub fn is_ready(&self) -> bool {
                *self == BusyR::Ready
            }
            # [ doc = "Checks if the value of the field is `Busy`" ]
            # [ inline ( always ) ]
            pub fn is_busy(&self) -> bool {
                *self == BusyR::Busy
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - ADC busy register." ]
            # [ inline ( always ) ]
            pub fn busy(&self) -> BusyR {
                BusyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
    }
    # [ doc = "ADC enable." ]
    pub struct Enable {
        register: VolatileCell<u32>,
    }
    # [ doc = "ADC enable." ]
    pub mod enable {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Enable {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ENABLE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EnableR {
            # [ doc = "ADC is disabled." ]
            Disabled,
            # [ doc = "ADC is enabled. If an analog input pin is selected as source of the conversion, the selected pin is configured as an analog input." ]
            Enabled,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl EnableR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EnableR::Disabled => 0,
                    EnableR::Enabled => 1,
                    EnableR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EnableR {
                match bits {
                    0 => EnableR::Disabled,
                    1 => EnableR::Enabled,
                    i => EnableR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EnableR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EnableR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `ENABLE`" ]
        pub enum EnableW {
            # [ doc = "ADC is disabled." ]
            Disabled,
            # [ doc = "ADC is enabled. If an analog input pin is selected as source of the conversion, the selected pin is configured as an analog input." ]
            Enabled,
        }
        impl EnableW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EnableW::Disabled => 0,
                    EnableW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnableW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnableW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EnableW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "ADC is disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EnableW::Disabled)
            }
            # [ doc = "ADC is enabled. If an analog input pin is selected as source of the conversion, the selected pin is configured as an analog input." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EnableW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - ADC enable." ]
            # [ inline ( always ) ]
            pub fn enable(&self) -> EnableR {
                EnableR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - ADC enable." ]
            # [ inline ( always ) ]
            pub fn enable(&mut self) -> _EnableW {
                _EnableW { w: self }
            }
        }
    }
    # [ doc = "ADC configuration register." ]
    pub struct Config {
        register: VolatileCell<u32>,
    }
    # [ doc = "ADC configuration register." ]
    pub mod config {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Config {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `RES`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ResR {
            # [ doc = "8bit ADC resolution." ]
            _8bit,
            # [ doc = "9bit ADC resolution." ]
            _9bit,
            # [ doc = "10bit ADC resolution." ]
            _10bit,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl ResR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ResR::_8bit => 0,
                    ResR::_9bit => 1,
                    ResR::_10bit => 2,
                    ResR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ResR {
                match bits {
                    0 => ResR::_8bit,
                    1 => ResR::_9bit,
                    2 => ResR::_10bit,
                    i => ResR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `_8bit`" ]
            # [ inline ( always ) ]
            pub fn is_8bit(&self) -> bool {
                *self == ResR::_8bit
            }
            # [ doc = "Checks if the value of the field is `_9bit`" ]
            # [ inline ( always ) ]
            pub fn is_9bit(&self) -> bool {
                *self == ResR::_9bit
            }
            # [ doc = "Checks if the value of the field is `_10bit`" ]
            # [ inline ( always ) ]
            pub fn is_10bit(&self) -> bool {
                *self == ResR::_10bit
            }
        }
        # [ doc = "Possible values of the field `INPSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum InpselR {
            # [ doc = "Analog input specified by PSEL with no prescaling used as input for the conversion." ]
            AnalogInputNoPrescaling,
            # [ doc = "Analog input specified by PSEL with 2/3 prescaling used as input for the conversion." ]
            AnalogInputTwoThirdsPrescaling,
            # [ doc = "Analog input specified by PSEL with 1/3 prescaling used as input for the conversion." ]
            AnalogInputOneThirdPrescaling,
            # [ doc = "Supply voltage with 2/3 prescaling used as input for the conversion." ]
            SupplyTwoThirdsPrescaling,
            # [ doc = "Supply voltage with 1/3 prescaling used as input for the conversion." ]
            SupplyOneThirdPrescaling,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl InpselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    InpselR::AnalogInputNoPrescaling => 0,
                    InpselR::AnalogInputTwoThirdsPrescaling => 1,
                    InpselR::AnalogInputOneThirdPrescaling => 2,
                    InpselR::SupplyTwoThirdsPrescaling => 5,
                    InpselR::SupplyOneThirdPrescaling => 6,
                    InpselR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> InpselR {
                match bits {
                    0 => InpselR::AnalogInputNoPrescaling,
                    1 => InpselR::AnalogInputTwoThirdsPrescaling,
                    2 => InpselR::AnalogInputOneThirdPrescaling,
                    5 => InpselR::SupplyTwoThirdsPrescaling,
                    6 => InpselR::SupplyOneThirdPrescaling,
                    i => InpselR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `AnalogInputNoPrescaling`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input_no_prescaling(&self) -> bool {
                *self == InpselR::AnalogInputNoPrescaling
            }
            # [ doc = "Checks if the value of the field is `AnalogInputTwoThirdsPrescaling`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input_two_thirds_prescaling(&self) -> bool {
                *self == InpselR::AnalogInputTwoThirdsPrescaling
            }
            # [ doc = "Checks if the value of the field is `AnalogInputOneThirdPrescaling`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input_one_third_prescaling(&self) -> bool {
                *self == InpselR::AnalogInputOneThirdPrescaling
            }
            # [ doc = "Checks if the value of the field is `SupplyTwoThirdsPrescaling`" ]
            # [ inline ( always ) ]
            pub fn is_supply_two_thirds_prescaling(&self) -> bool {
                *self == InpselR::SupplyTwoThirdsPrescaling
            }
            # [ doc = "Checks if the value of the field is `SupplyOneThirdPrescaling`" ]
            # [ inline ( always ) ]
            pub fn is_supply_one_third_prescaling(&self) -> bool {
                *self == InpselR::SupplyOneThirdPrescaling
            }
        }
        # [ doc = "Possible values of the field `REFSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RefselR {
            # [ doc = "Use internal 1.2V bandgap voltage as reference for conversion." ]
            Vbg,
            # [ doc = "Use external source configured by EXTREFSEL as reference for conversion." ]
            External,
            # [ doc = "Use supply voltage with 1/2 prescaling as reference for conversion. Only usable when supply voltage is between 1.7V and 2.6V." ]
            SupplyOneHalfPrescaling,
            # [ doc = "Use supply voltage with 1/3 prescaling as reference for conversion. Only usable when supply voltage is between 2.5V and 3.6V." ]
            SupplyOneThirdPrescaling,
        }
        impl RefselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RefselR::Vbg => 0,
                    RefselR::External => 1,
                    RefselR::SupplyOneHalfPrescaling => 2,
                    RefselR::SupplyOneThirdPrescaling => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RefselR {
                match bits {
                    0 => RefselR::Vbg,
                    1 => RefselR::External,
                    2 => RefselR::SupplyOneHalfPrescaling,
                    3 => RefselR::SupplyOneThirdPrescaling,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Vbg`" ]
            # [ inline ( always ) ]
            pub fn is_vbg(&self) -> bool {
                *self == RefselR::Vbg
            }
            # [ doc = "Checks if the value of the field is `External`" ]
            # [ inline ( always ) ]
            pub fn is_external(&self) -> bool {
                *self == RefselR::External
            }
            # [ doc = "Checks if the value of the field is `SupplyOneHalfPrescaling`" ]
            # [ inline ( always ) ]
            pub fn is_supply_one_half_prescaling(&self) -> bool {
                *self == RefselR::SupplyOneHalfPrescaling
            }
            # [ doc = "Checks if the value of the field is `SupplyOneThirdPrescaling`" ]
            # [ inline ( always ) ]
            pub fn is_supply_one_third_prescaling(&self) -> bool {
                *self == RefselR::SupplyOneThirdPrescaling
            }
        }
        # [ doc = "Possible values of the field `PSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PselR {
            # [ doc = "Analog input pins disabled." ]
            Disabled,
            # [ doc = "Use analog input 0 as analog input." ]
            AnalogInput0,
            # [ doc = "Use analog input 1 as analog input." ]
            AnalogInput1,
            # [ doc = "Use analog input 2 as analog input." ]
            AnalogInput2,
            # [ doc = "Use analog input 3 as analog input." ]
            AnalogInput3,
            # [ doc = "Use analog input 4 as analog input." ]
            AnalogInput4,
            # [ doc = "Use analog input 5 as analog input." ]
            AnalogInput5,
            # [ doc = "Use analog input 6 as analog input." ]
            AnalogInput6,
            # [ doc = "Use analog input 7 as analog input." ]
            AnalogInput7,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl PselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PselR::Disabled => 0,
                    PselR::AnalogInput0 => 1,
                    PselR::AnalogInput1 => 2,
                    PselR::AnalogInput2 => 4,
                    PselR::AnalogInput3 => 8,
                    PselR::AnalogInput4 => 16,
                    PselR::AnalogInput5 => 32,
                    PselR::AnalogInput6 => 64,
                    PselR::AnalogInput7 => 128,
                    PselR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PselR {
                match bits {
                    0 => PselR::Disabled,
                    1 => PselR::AnalogInput0,
                    2 => PselR::AnalogInput1,
                    4 => PselR::AnalogInput2,
                    8 => PselR::AnalogInput3,
                    16 => PselR::AnalogInput4,
                    32 => PselR::AnalogInput5,
                    64 => PselR::AnalogInput6,
                    128 => PselR::AnalogInput7,
                    i => PselR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PselR::Disabled
            }
            # [ doc = "Checks if the value of the field is `AnalogInput0`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input0(&self) -> bool {
                *self == PselR::AnalogInput0
            }
            # [ doc = "Checks if the value of the field is `AnalogInput1`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input1(&self) -> bool {
                *self == PselR::AnalogInput1
            }
            # [ doc = "Checks if the value of the field is `AnalogInput2`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input2(&self) -> bool {
                *self == PselR::AnalogInput2
            }
            # [ doc = "Checks if the value of the field is `AnalogInput3`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input3(&self) -> bool {
                *self == PselR::AnalogInput3
            }
            # [ doc = "Checks if the value of the field is `AnalogInput4`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input4(&self) -> bool {
                *self == PselR::AnalogInput4
            }
            # [ doc = "Checks if the value of the field is `AnalogInput5`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input5(&self) -> bool {
                *self == PselR::AnalogInput5
            }
            # [ doc = "Checks if the value of the field is `AnalogInput6`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input6(&self) -> bool {
                *self == PselR::AnalogInput6
            }
            # [ doc = "Checks if the value of the field is `AnalogInput7`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input7(&self) -> bool {
                *self == PselR::AnalogInput7
            }
        }
        # [ doc = "Possible values of the field `EXTREFSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ExtrefselR {
            # [ doc = "Analog external reference inputs disabled." ]
            None,
            # [ doc = "Use analog reference 0 as reference." ]
            AnalogReference0,
            # [ doc = "Use analog reference 1 as reference." ]
            AnalogReference1,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl ExtrefselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ExtrefselR::None => 0,
                    ExtrefselR::AnalogReference0 => 1,
                    ExtrefselR::AnalogReference1 => 2,
                    ExtrefselR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ExtrefselR {
                match bits {
                    0 => ExtrefselR::None,
                    1 => ExtrefselR::AnalogReference0,
                    2 => ExtrefselR::AnalogReference1,
                    i => ExtrefselR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `None`" ]
            # [ inline ( always ) ]
            pub fn is_none(&self) -> bool {
                *self == ExtrefselR::None
            }
            # [ doc = "Checks if the value of the field is `AnalogReference0`" ]
            # [ inline ( always ) ]
            pub fn is_analog_reference0(&self) -> bool {
                *self == ExtrefselR::AnalogReference0
            }
            # [ doc = "Checks if the value of the field is `AnalogReference1`" ]
            # [ inline ( always ) ]
            pub fn is_analog_reference1(&self) -> bool {
                *self == ExtrefselR::AnalogReference1
            }
        }
        # [ doc = "Values that can be written to the field `RES`" ]
        pub enum ResW {
            # [ doc = "8bit ADC resolution." ]
            _8bit,
            # [ doc = "9bit ADC resolution." ]
            _9bit,
            # [ doc = "10bit ADC resolution." ]
            _10bit,
        }
        impl ResW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ResW::_8bit => 0,
                    ResW::_9bit => 1,
                    ResW::_10bit => 2,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ResW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ResW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ResW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "8bit ADC resolution." ]
            # [ inline ( always ) ]
            pub fn _8bit(self) -> &'a mut W {
                self.variant(ResW::_8bit)
            }
            # [ doc = "9bit ADC resolution." ]
            # [ inline ( always ) ]
            pub fn _9bit(self) -> &'a mut W {
                self.variant(ResW::_9bit)
            }
            # [ doc = "10bit ADC resolution." ]
            # [ inline ( always ) ]
            pub fn _10bit(self) -> &'a mut W {
                self.variant(ResW::_10bit)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `INPSEL`" ]
        pub enum InpselW {
            # [ doc = "Analog input specified by PSEL with no prescaling used as input for the conversion." ]
            AnalogInputNoPrescaling,
            # [ doc = "Analog input specified by PSEL with 2/3 prescaling used as input for the conversion." ]
            AnalogInputTwoThirdsPrescaling,
            # [ doc = "Analog input specified by PSEL with 1/3 prescaling used as input for the conversion." ]
            AnalogInputOneThirdPrescaling,
            # [ doc = "Supply voltage with 2/3 prescaling used as input for the conversion." ]
            SupplyTwoThirdsPrescaling,
            # [ doc = "Supply voltage with 1/3 prescaling used as input for the conversion." ]
            SupplyOneThirdPrescaling,
        }
        impl InpselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    InpselW::AnalogInputNoPrescaling => 0,
                    InpselW::AnalogInputTwoThirdsPrescaling => 1,
                    InpselW::AnalogInputOneThirdPrescaling => 2,
                    InpselW::SupplyTwoThirdsPrescaling => 5,
                    InpselW::SupplyOneThirdPrescaling => 6,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _InpselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _InpselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: InpselW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Analog input specified by PSEL with no prescaling used as input for the conversion." ]
            # [ inline ( always ) ]
            pub fn analog_input_no_prescaling(self) -> &'a mut W {
                self.variant(InpselW::AnalogInputNoPrescaling)
            }
            # [ doc = "Analog input specified by PSEL with 2/3 prescaling used as input for the conversion." ]
            # [ inline ( always ) ]
            pub fn analog_input_two_thirds_prescaling(self) -> &'a mut W {
                self.variant(InpselW::AnalogInputTwoThirdsPrescaling)
            }
            # [ doc = "Analog input specified by PSEL with 1/3 prescaling used as input for the conversion." ]
            # [ inline ( always ) ]
            pub fn analog_input_one_third_prescaling(self) -> &'a mut W {
                self.variant(InpselW::AnalogInputOneThirdPrescaling)
            }
            # [ doc = "Supply voltage with 2/3 prescaling used as input for the conversion." ]
            # [ inline ( always ) ]
            pub fn supply_two_thirds_prescaling(self) -> &'a mut W {
                self.variant(InpselW::SupplyTwoThirdsPrescaling)
            }
            # [ doc = "Supply voltage with 1/3 prescaling used as input for the conversion." ]
            # [ inline ( always ) ]
            pub fn supply_one_third_prescaling(self) -> &'a mut W {
                self.variant(InpselW::SupplyOneThirdPrescaling)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `REFSEL`" ]
        pub enum RefselW {
            # [ doc = "Use internal 1.2V bandgap voltage as reference for conversion." ]
            Vbg,
            # [ doc = "Use external source configured by EXTREFSEL as reference for conversion." ]
            External,
            # [ doc = "Use supply voltage with 1/2 prescaling as reference for conversion. Only usable when supply voltage is between 1.7V and 2.6V." ]
            SupplyOneHalfPrescaling,
            # [ doc = "Use supply voltage with 1/3 prescaling as reference for conversion. Only usable when supply voltage is between 2.5V and 3.6V." ]
            SupplyOneThirdPrescaling,
        }
        impl RefselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RefselW::Vbg => 0,
                    RefselW::External => 1,
                    RefselW::SupplyOneHalfPrescaling => 2,
                    RefselW::SupplyOneThirdPrescaling => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RefselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RefselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RefselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Use internal 1.2V bandgap voltage as reference for conversion." ]
            # [ inline ( always ) ]
            pub fn vbg(self) -> &'a mut W {
                self.variant(RefselW::Vbg)
            }
            # [ doc = "Use external source configured by EXTREFSEL as reference for conversion." ]
            # [ inline ( always ) ]
            pub fn external(self) -> &'a mut W {
                self.variant(RefselW::External)
            }
            # [ doc = "Use supply voltage with 1/2 prescaling as reference for conversion. Only usable when supply voltage is between 1.7V and 2.6V." ]
            # [ inline ( always ) ]
            pub fn supply_one_half_prescaling(self) -> &'a mut W {
                self.variant(RefselW::SupplyOneHalfPrescaling)
            }
            # [ doc = "Use supply voltage with 1/3 prescaling as reference for conversion. Only usable when supply voltage is between 2.5V and 3.6V." ]
            # [ inline ( always ) ]
            pub fn supply_one_third_prescaling(self) -> &'a mut W {
                self.variant(RefselW::SupplyOneThirdPrescaling)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PSEL`" ]
        pub enum PselW {
            # [ doc = "Analog input pins disabled." ]
            Disabled,
            # [ doc = "Use analog input 0 as analog input." ]
            AnalogInput0,
            # [ doc = "Use analog input 1 as analog input." ]
            AnalogInput1,
            # [ doc = "Use analog input 2 as analog input." ]
            AnalogInput2,
            # [ doc = "Use analog input 3 as analog input." ]
            AnalogInput3,
            # [ doc = "Use analog input 4 as analog input." ]
            AnalogInput4,
            # [ doc = "Use analog input 5 as analog input." ]
            AnalogInput5,
            # [ doc = "Use analog input 6 as analog input." ]
            AnalogInput6,
            # [ doc = "Use analog input 7 as analog input." ]
            AnalogInput7,
        }
        impl PselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PselW::Disabled => 0,
                    PselW::AnalogInput0 => 1,
                    PselW::AnalogInput1 => 2,
                    PselW::AnalogInput2 => 4,
                    PselW::AnalogInput3 => 8,
                    PselW::AnalogInput4 => 16,
                    PselW::AnalogInput5 => 32,
                    PselW::AnalogInput6 => 64,
                    PselW::AnalogInput7 => 128,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PselW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Analog input pins disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PselW::Disabled)
            }
            # [ doc = "Use analog input 0 as analog input." ]
            # [ inline ( always ) ]
            pub fn analog_input0(self) -> &'a mut W {
                self.variant(PselW::AnalogInput0)
            }
            # [ doc = "Use analog input 1 as analog input." ]
            # [ inline ( always ) ]
            pub fn analog_input1(self) -> &'a mut W {
                self.variant(PselW::AnalogInput1)
            }
            # [ doc = "Use analog input 2 as analog input." ]
            # [ inline ( always ) ]
            pub fn analog_input2(self) -> &'a mut W {
                self.variant(PselW::AnalogInput2)
            }
            # [ doc = "Use analog input 3 as analog input." ]
            # [ inline ( always ) ]
            pub fn analog_input3(self) -> &'a mut W {
                self.variant(PselW::AnalogInput3)
            }
            # [ doc = "Use analog input 4 as analog input." ]
            # [ inline ( always ) ]
            pub fn analog_input4(self) -> &'a mut W {
                self.variant(PselW::AnalogInput4)
            }
            # [ doc = "Use analog input 5 as analog input." ]
            # [ inline ( always ) ]
            pub fn analog_input5(self) -> &'a mut W {
                self.variant(PselW::AnalogInput5)
            }
            # [ doc = "Use analog input 6 as analog input." ]
            # [ inline ( always ) ]
            pub fn analog_input6(self) -> &'a mut W {
                self.variant(PselW::AnalogInput6)
            }
            # [ doc = "Use analog input 7 as analog input." ]
            # [ inline ( always ) ]
            pub fn analog_input7(self) -> &'a mut W {
                self.variant(PselW::AnalogInput7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `EXTREFSEL`" ]
        pub enum ExtrefselW {
            # [ doc = "Analog external reference inputs disabled." ]
            None,
            # [ doc = "Use analog reference 0 as reference." ]
            AnalogReference0,
            # [ doc = "Use analog reference 1 as reference." ]
            AnalogReference1,
        }
        impl ExtrefselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ExtrefselW::None => 0,
                    ExtrefselW::AnalogReference0 => 1,
                    ExtrefselW::AnalogReference1 => 2,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ExtrefselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ExtrefselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ExtrefselW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Analog external reference inputs disabled." ]
            # [ inline ( always ) ]
            pub fn none(self) -> &'a mut W {
                self.variant(ExtrefselW::None)
            }
            # [ doc = "Use analog reference 0 as reference." ]
            # [ inline ( always ) ]
            pub fn analog_reference0(self) -> &'a mut W {
                self.variant(ExtrefselW::AnalogReference0)
            }
            # [ doc = "Use analog reference 1 as reference." ]
            # [ inline ( always ) ]
            pub fn analog_reference1(self) -> &'a mut W {
                self.variant(ExtrefselW::AnalogReference1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - ADC resolution." ]
            # [ inline ( always ) ]
            pub fn res(&self) -> ResR {
                ResR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bits 2:4 - ADC input selection." ]
            # [ inline ( always ) ]
            pub fn inpsel(&self) -> InpselR {
                InpselR::_from(
                    {
                        const MASK: u8 = 7;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bits 5:6 - ADC reference selection." ]
            # [ inline ( always ) ]
            pub fn refsel(&self) -> RefselR {
                RefselR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bits 8:15 - ADC analog pin selection." ]
            # [ inline ( always ) ]
            pub fn psel(&self) -> PselR {
                PselR::_from(
                    {
                        const MASK: u8 = 255;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bits 16:17 - ADC external reference pin selection." ]
            # [ inline ( always ) ]
            pub fn extrefsel(&self) -> ExtrefselR {
                ExtrefselR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 24 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - ADC resolution." ]
            # [ inline ( always ) ]
            pub fn res(&mut self) -> _ResW {
                _ResW { w: self }
            }
            # [ doc = "Bits 2:4 - ADC input selection." ]
            # [ inline ( always ) ]
            pub fn inpsel(&mut self) -> _InpselW {
                _InpselW { w: self }
            }
            # [ doc = "Bits 5:6 - ADC reference selection." ]
            # [ inline ( always ) ]
            pub fn refsel(&mut self) -> _RefselW {
                _RefselW { w: self }
            }
            # [ doc = "Bits 8:15 - ADC analog pin selection." ]
            # [ inline ( always ) ]
            pub fn psel(&mut self) -> _PselW {
                _PselW { w: self }
            }
            # [ doc = "Bits 16:17 - ADC external reference pin selection." ]
            # [ inline ( always ) ]
            pub fn extrefsel(&mut self) -> _ExtrefselW {
                _ExtrefselW { w: self }
            }
        }
    }
    # [ doc = "Result of ADC conversion." ]
    pub struct Result {
        register: VolatileCell<u32>,
    }
    # [ doc = "Result of ADC conversion." ]
    pub mod result {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Result {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ResultR {
            bits: u16,
        }
        impl ResultR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:9 - Result of ADC conversion." ]
            # [ inline ( always ) ]
            pub fn result(&self) -> ResultR {
                let bits = {
                    const MASK: u16 = 1023;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ResultR { bits }
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "Analog to digital converter." ]
pub struct Adc {
    register_block: adc::RegisterBlock,
}
impl Deref for Adc {
    type Target = adc::RegisterBlock;
    fn deref(&self) -> &adc::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Timer 0." ]
pub const TIMER0: Peripheral<Timer0> = unsafe { Peripheral::new(1073774592) };
# [ doc = "Timer 0." ]
pub mod timer0 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Start Timer." ]
        pub tasks_start: TasksStart,
        # [ doc = "0x04 - Stop Timer." ]
        pub tasks_stop: TasksStop,
        # [ doc = "0x08 - Increment Timer (In counter mode)." ]
        pub tasks_count: TasksCount,
        # [ doc = "0x0c - Clear timer." ]
        pub tasks_clear: TasksClear,
        # [ doc = "0x10 - Shutdown timer." ]
        pub tasks_shutdown: TasksShutdown,
        _reserved0: [u8; 44usize],
        # [ doc = "0x40 - Capture Timer value to CC[n] registers." ]
        pub tasks_capture0: TasksCapture,
        # [ doc = "0x44 - Capture Timer value to CC[n] registers." ]
        pub tasks_capture1: TasksCapture,
        # [ doc = "0x48 - Capture Timer value to CC[n] registers." ]
        pub tasks_capture2: TasksCapture,
        # [ doc = "0x4c - Capture Timer value to CC[n] registers." ]
        pub tasks_capture3: TasksCapture,
        _reserved1: [u8; 240usize],
        # [ doc = "0x140 - Compare event on CC[n] match." ]
        pub events_compare0: EventsCompare,
        # [ doc = "0x144 - Compare event on CC[n] match." ]
        pub events_compare1: EventsCompare,
        # [ doc = "0x148 - Compare event on CC[n] match." ]
        pub events_compare2: EventsCompare,
        # [ doc = "0x14c - Compare event on CC[n] match." ]
        pub events_compare3: EventsCompare,
        _reserved2: [u8; 176usize],
        # [ doc = "0x200 - Shortcuts for Timer." ]
        pub shorts: Shorts,
        _reserved3: [u8; 256usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved4: [u8; 504usize],
        # [ doc = "0x504 - Timer Mode selection." ]
        pub mode: Mode,
        # [ doc = "0x508 - Sets timer behaviour." ]
        pub bitmode: Bitmode,
        _reserved5: [u8; 4usize],
        # [ doc = "0x510 - 4-bit prescaler to source clock frequency (max value 9). Source clock frequency is divided by 2^SCALE." ]
        pub prescaler: Prescaler,
        _reserved6: [u8; 44usize],
        # [ doc = "0x540 - Capture/compare registers." ]
        pub cc0: Cc,
        # [ doc = "0x544 - Capture/compare registers." ]
        pub cc1: Cc,
        # [ doc = "0x548 - Capture/compare registers." ]
        pub cc2: Cc,
        # [ doc = "0x54c - Capture/compare registers." ]
        pub cc3: Cc,
        _reserved7: [u8; 2732usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Start Timer." ]
    pub struct TasksStart {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start Timer." ]
    pub mod tasks_start {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStart {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop Timer." ]
    pub struct TasksStop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop Timer." ]
    pub mod tasks_stop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Increment Timer (In counter mode)." ]
    pub struct TasksCount {
        register: VolatileCell<u32>,
    }
    # [ doc = "Increment Timer (In counter mode)." ]
    pub mod tasks_count {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksCount {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Clear timer." ]
    pub struct TasksClear {
        register: VolatileCell<u32>,
    }
    # [ doc = "Clear timer." ]
    pub mod tasks_clear {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksClear {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Shutdown timer." ]
    pub struct TasksShutdown {
        register: VolatileCell<u32>,
    }
    # [ doc = "Shutdown timer." ]
    pub mod tasks_shutdown {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksShutdown {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Capture Timer value to CC[n] registers." ]
    pub struct TasksCapture {
        register: VolatileCell<u32>,
    }
    # [ doc = "Capture Timer value to CC[n] registers." ]
    pub mod tasks_capture {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksCapture {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Compare event on CC[n] match." ]
    pub struct EventsCompare {
        register: VolatileCell<u32>,
    }
    # [ doc = "Compare event on CC[n] match." ]
    pub mod events_compare {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsCompare {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Shortcuts for Timer." ]
    pub struct Shorts {
        register: VolatileCell<u32>,
    }
    # [ doc = "Shortcuts for Timer." ]
    pub mod shorts {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Shorts {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `COMPARE0_CLEAR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare0ClearR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl Compare0ClearR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare0ClearR::Disabled => 0,
                    Compare0ClearR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare0ClearR {
                match bits {
                    0 => Compare0ClearR::Disabled,
                    1 => Compare0ClearR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare0ClearR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare0ClearR::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE1_CLEAR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare1ClearR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl Compare1ClearR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare1ClearR::Disabled => 0,
                    Compare1ClearR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare1ClearR {
                match bits {
                    0 => Compare1ClearR::Disabled,
                    1 => Compare1ClearR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare1ClearR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare1ClearR::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE2_CLEAR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare2ClearR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl Compare2ClearR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare2ClearR::Disabled => 0,
                    Compare2ClearR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare2ClearR {
                match bits {
                    0 => Compare2ClearR::Disabled,
                    1 => Compare2ClearR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare2ClearR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare2ClearR::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE3_CLEAR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare3ClearR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl Compare3ClearR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare3ClearR::Disabled => 0,
                    Compare3ClearR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare3ClearR {
                match bits {
                    0 => Compare3ClearR::Disabled,
                    1 => Compare3ClearR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare3ClearR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare3ClearR::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE0_STOP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare0StopR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl Compare0StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare0StopR::Disabled => 0,
                    Compare0StopR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare0StopR {
                match bits {
                    0 => Compare0StopR::Disabled,
                    1 => Compare0StopR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare0StopR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare0StopR::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE1_STOP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare1StopR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl Compare1StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare1StopR::Disabled => 0,
                    Compare1StopR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare1StopR {
                match bits {
                    0 => Compare1StopR::Disabled,
                    1 => Compare1StopR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare1StopR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare1StopR::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE2_STOP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare2StopR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl Compare2StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare2StopR::Disabled => 0,
                    Compare2StopR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare2StopR {
                match bits {
                    0 => Compare2StopR::Disabled,
                    1 => Compare2StopR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare2StopR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare2StopR::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE3_STOP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare3StopR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl Compare3StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare3StopR::Disabled => 0,
                    Compare3StopR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare3StopR {
                match bits {
                    0 => Compare3StopR::Disabled,
                    1 => Compare3StopR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare3StopR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare3StopR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE0_CLEAR`" ]
        pub enum Compare0ClearW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl Compare0ClearW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare0ClearW::Disabled => 0,
                    Compare0ClearW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare0ClearW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare0ClearW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare0ClearW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Compare0ClearW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Compare0ClearW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE1_CLEAR`" ]
        pub enum Compare1ClearW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl Compare1ClearW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare1ClearW::Disabled => 0,
                    Compare1ClearW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare1ClearW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare1ClearW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare1ClearW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Compare1ClearW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Compare1ClearW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE2_CLEAR`" ]
        pub enum Compare2ClearW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl Compare2ClearW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare2ClearW::Disabled => 0,
                    Compare2ClearW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare2ClearW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare2ClearW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare2ClearW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Compare2ClearW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Compare2ClearW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE3_CLEAR`" ]
        pub enum Compare3ClearW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl Compare3ClearW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare3ClearW::Disabled => 0,
                    Compare3ClearW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare3ClearW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare3ClearW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare3ClearW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Compare3ClearW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Compare3ClearW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE0_STOP`" ]
        pub enum Compare0StopW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl Compare0StopW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare0StopW::Disabled => 0,
                    Compare0StopW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare0StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare0StopW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare0StopW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Compare0StopW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Compare0StopW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE1_STOP`" ]
        pub enum Compare1StopW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl Compare1StopW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare1StopW::Disabled => 0,
                    Compare1StopW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare1StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare1StopW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare1StopW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Compare1StopW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Compare1StopW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE2_STOP`" ]
        pub enum Compare2StopW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl Compare2StopW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare2StopW::Disabled => 0,
                    Compare2StopW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare2StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare2StopW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare2StopW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Compare2StopW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Compare2StopW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE3_STOP`" ]
        pub enum Compare3StopW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl Compare3StopW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare3StopW::Disabled => 0,
                    Compare3StopW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare3StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare3StopW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare3StopW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Compare3StopW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Compare3StopW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Shortcut between CC[0] event and the CLEAR task." ]
            # [ inline ( always ) ]
            pub fn compare0_clear(&self) -> Compare0ClearR {
                Compare0ClearR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Shortcut between CC[1] event and the CLEAR task." ]
            # [ inline ( always ) ]
            pub fn compare1_clear(&self) -> Compare1ClearR {
                Compare1ClearR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Shortcut between CC[2] event and the CLEAR task." ]
            # [ inline ( always ) ]
            pub fn compare2_clear(&self) -> Compare2ClearR {
                Compare2ClearR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Shortcut between CC[3] event and the CLEAR task." ]
            # [ inline ( always ) ]
            pub fn compare3_clear(&self) -> Compare3ClearR {
                Compare3ClearR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Shortcut between CC[0] event and the STOP task." ]
            # [ inline ( always ) ]
            pub fn compare0_stop(&self) -> Compare0StopR {
                Compare0StopR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Shortcut between CC[1] event and the STOP task." ]
            # [ inline ( always ) ]
            pub fn compare1_stop(&self) -> Compare1StopR {
                Compare1StopR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Shortcut between CC[2] event and the STOP task." ]
            # [ inline ( always ) ]
            pub fn compare2_stop(&self) -> Compare2StopR {
                Compare2StopR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 11 - Shortcut between CC[3] event and the STOP task." ]
            # [ inline ( always ) ]
            pub fn compare3_stop(&self) -> Compare3StopR {
                Compare3StopR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Shortcut between CC[0] event and the CLEAR task." ]
            # [ inline ( always ) ]
            pub fn compare0_clear(&mut self) -> _Compare0ClearW {
                _Compare0ClearW { w: self }
            }
            # [ doc = "Bit 1 - Shortcut between CC[1] event and the CLEAR task." ]
            # [ inline ( always ) ]
            pub fn compare1_clear(&mut self) -> _Compare1ClearW {
                _Compare1ClearW { w: self }
            }
            # [ doc = "Bit 2 - Shortcut between CC[2] event and the CLEAR task." ]
            # [ inline ( always ) ]
            pub fn compare2_clear(&mut self) -> _Compare2ClearW {
                _Compare2ClearW { w: self }
            }
            # [ doc = "Bit 3 - Shortcut between CC[3] event and the CLEAR task." ]
            # [ inline ( always ) ]
            pub fn compare3_clear(&mut self) -> _Compare3ClearW {
                _Compare3ClearW { w: self }
            }
            # [ doc = "Bit 8 - Shortcut between CC[0] event and the STOP task." ]
            # [ inline ( always ) ]
            pub fn compare0_stop(&mut self) -> _Compare0StopW {
                _Compare0StopW { w: self }
            }
            # [ doc = "Bit 9 - Shortcut between CC[1] event and the STOP task." ]
            # [ inline ( always ) ]
            pub fn compare1_stop(&mut self) -> _Compare1StopW {
                _Compare1StopW { w: self }
            }
            # [ doc = "Bit 10 - Shortcut between CC[2] event and the STOP task." ]
            # [ inline ( always ) ]
            pub fn compare2_stop(&mut self) -> _Compare2StopW {
                _Compare2StopW { w: self }
            }
            # [ doc = "Bit 11 - Shortcut between CC[3] event and the STOP task." ]
            # [ inline ( always ) ]
            pub fn compare3_stop(&mut self) -> _Compare3StopW {
                _Compare3StopW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `COMPARE0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare0R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl Compare0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare0R::Disabled => 0,
                    Compare0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare0R {
                match bits {
                    0 => Compare0R::Disabled,
                    1 => Compare0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare1R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl Compare1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare1R::Disabled => 0,
                    Compare1R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare1R {
                match bits {
                    0 => Compare1R::Disabled,
                    1 => Compare1R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare1R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare1R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare2R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl Compare2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare2R::Disabled => 0,
                    Compare2R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare2R {
                match bits {
                    0 => Compare2R::Disabled,
                    1 => Compare2R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare2R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare2R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare3R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl Compare3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare3R::Disabled => 0,
                    Compare3R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare3R {
                match bits {
                    0 => Compare3R::Disabled,
                    1 => Compare3R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare3R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare3R::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE0`" ]
        pub enum Compare0W {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl Compare0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare0W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Compare0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE1`" ]
        pub enum Compare1W {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl Compare1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare1W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Compare1W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE2`" ]
        pub enum Compare2W {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl Compare2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare2W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Compare2W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE3`" ]
        pub enum Compare3W {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl Compare3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare3W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Compare3W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 16 - Enable interrupt on COMPARE[0]" ]
            # [ inline ( always ) ]
            pub fn compare0(&self) -> Compare0R {
                Compare0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Enable interrupt on COMPARE[1]" ]
            # [ inline ( always ) ]
            pub fn compare1(&self) -> Compare1R {
                Compare1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Enable interrupt on COMPARE[2]" ]
            # [ inline ( always ) ]
            pub fn compare2(&self) -> Compare2R {
                Compare2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Enable interrupt on COMPARE[3]" ]
            # [ inline ( always ) ]
            pub fn compare3(&self) -> Compare3R {
                Compare3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 16 - Enable interrupt on COMPARE[0]" ]
            # [ inline ( always ) ]
            pub fn compare0(&mut self) -> _Compare0W {
                _Compare0W { w: self }
            }
            # [ doc = "Bit 17 - Enable interrupt on COMPARE[1]" ]
            # [ inline ( always ) ]
            pub fn compare1(&mut self) -> _Compare1W {
                _Compare1W { w: self }
            }
            # [ doc = "Bit 18 - Enable interrupt on COMPARE[2]" ]
            # [ inline ( always ) ]
            pub fn compare2(&mut self) -> _Compare2W {
                _Compare2W { w: self }
            }
            # [ doc = "Bit 19 - Enable interrupt on COMPARE[3]" ]
            # [ inline ( always ) ]
            pub fn compare3(&mut self) -> _Compare3W {
                _Compare3W { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `COMPARE0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare0R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl Compare0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare0R::Disabled => 0,
                    Compare0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare0R {
                match bits {
                    0 => Compare0R::Disabled,
                    1 => Compare0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare1R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl Compare1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare1R::Disabled => 0,
                    Compare1R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare1R {
                match bits {
                    0 => Compare1R::Disabled,
                    1 => Compare1R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare1R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare1R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare2R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl Compare2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare2R::Disabled => 0,
                    Compare2R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare2R {
                match bits {
                    0 => Compare2R::Disabled,
                    1 => Compare2R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare2R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare2R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare3R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl Compare3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare3R::Disabled => 0,
                    Compare3R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare3R {
                match bits {
                    0 => Compare3R::Disabled,
                    1 => Compare3R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare3R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare3R::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE0`" ]
        pub enum Compare0W {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl Compare0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare0W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Compare0W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE1`" ]
        pub enum Compare1W {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl Compare1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare1W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Compare1W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE2`" ]
        pub enum Compare2W {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl Compare2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare2W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Compare2W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE3`" ]
        pub enum Compare3W {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl Compare3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare3W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Compare3W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 16 - Disable interrupt on COMPARE[0]" ]
            # [ inline ( always ) ]
            pub fn compare0(&self) -> Compare0R {
                Compare0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Disable interrupt on COMPARE[1]" ]
            # [ inline ( always ) ]
            pub fn compare1(&self) -> Compare1R {
                Compare1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Disable interrupt on COMPARE[2]" ]
            # [ inline ( always ) ]
            pub fn compare2(&self) -> Compare2R {
                Compare2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Disable interrupt on COMPARE[3]" ]
            # [ inline ( always ) ]
            pub fn compare3(&self) -> Compare3R {
                Compare3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 16 - Disable interrupt on COMPARE[0]" ]
            # [ inline ( always ) ]
            pub fn compare0(&mut self) -> _Compare0W {
                _Compare0W { w: self }
            }
            # [ doc = "Bit 17 - Disable interrupt on COMPARE[1]" ]
            # [ inline ( always ) ]
            pub fn compare1(&mut self) -> _Compare1W {
                _Compare1W { w: self }
            }
            # [ doc = "Bit 18 - Disable interrupt on COMPARE[2]" ]
            # [ inline ( always ) ]
            pub fn compare2(&mut self) -> _Compare2W {
                _Compare2W { w: self }
            }
            # [ doc = "Bit 19 - Disable interrupt on COMPARE[3]" ]
            # [ inline ( always ) ]
            pub fn compare3(&mut self) -> _Compare3W {
                _Compare3W { w: self }
            }
        }
    }
    # [ doc = "Timer Mode selection." ]
    pub struct Mode {
        register: VolatileCell<u32>,
    }
    # [ doc = "Timer Mode selection." ]
    pub mod mode {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Mode {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `MODE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ModeR {
            # [ doc = "Timer in Counter mode." ]
            Counter,
            # [ doc = "Timer in Normal mode." ]
            Timer,
        }
        impl ModeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ModeR::Counter => 1,
                    ModeR::Timer => 0,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ModeR {
                match bits {
                    1 => ModeR::Counter,
                    0 => ModeR::Timer,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Counter`" ]
            # [ inline ( always ) ]
            pub fn is_counter(&self) -> bool {
                *self == ModeR::Counter
            }
            # [ doc = "Checks if the value of the field is `Timer`" ]
            # [ inline ( always ) ]
            pub fn is_timer(&self) -> bool {
                *self == ModeR::Timer
            }
        }
        # [ doc = "Values that can be written to the field `MODE`" ]
        pub enum ModeW {
            # [ doc = "Timer in Counter mode." ]
            Counter,
            # [ doc = "Timer in Normal mode." ]
            Timer,
        }
        impl ModeW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ModeW::Counter => 1,
                    ModeW::Timer => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ModeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ModeW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ModeW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Timer in Counter mode." ]
            # [ inline ( always ) ]
            pub fn counter(self) -> &'a mut W {
                self.variant(ModeW::Counter)
            }
            # [ doc = "Timer in Normal mode." ]
            # [ inline ( always ) ]
            pub fn timer(self) -> &'a mut W {
                self.variant(ModeW::Timer)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Select Normal or Counter mode." ]
            # [ inline ( always ) ]
            pub fn mode(&self) -> ModeR {
                ModeR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Select Normal or Counter mode." ]
            # [ inline ( always ) ]
            pub fn mode(&mut self) -> _ModeW {
                _ModeW { w: self }
            }
        }
    }
    # [ doc = "Sets timer behaviour." ]
    pub struct Bitmode {
        register: VolatileCell<u32>,
    }
    # [ doc = "Sets timer behaviour." ]
    pub mod bitmode {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Bitmode {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `BITMODE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum BitmodeR {
            # [ doc = "16-bit timer behaviour." ]
            _16bit,
            # [ doc = "8-bit timer behaviour." ]
            _08bit,
            # [ doc = "24-bit timer behaviour." ]
            _24bit,
            # [ doc = "32-bit timer behaviour." ]
            _32bit,
        }
        impl BitmodeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    BitmodeR::_16bit => 0,
                    BitmodeR::_08bit => 1,
                    BitmodeR::_24bit => 2,
                    BitmodeR::_32bit => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> BitmodeR {
                match bits {
                    0 => BitmodeR::_16bit,
                    1 => BitmodeR::_08bit,
                    2 => BitmodeR::_24bit,
                    3 => BitmodeR::_32bit,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `_16bit`" ]
            # [ inline ( always ) ]
            pub fn is_16bit(&self) -> bool {
                *self == BitmodeR::_16bit
            }
            # [ doc = "Checks if the value of the field is `_08bit`" ]
            # [ inline ( always ) ]
            pub fn is_08bit(&self) -> bool {
                *self == BitmodeR::_08bit
            }
            # [ doc = "Checks if the value of the field is `_24bit`" ]
            # [ inline ( always ) ]
            pub fn is_24bit(&self) -> bool {
                *self == BitmodeR::_24bit
            }
            # [ doc = "Checks if the value of the field is `_32bit`" ]
            # [ inline ( always ) ]
            pub fn is_32bit(&self) -> bool {
                *self == BitmodeR::_32bit
            }
        }
        # [ doc = "Values that can be written to the field `BITMODE`" ]
        pub enum BitmodeW {
            # [ doc = "16-bit timer behaviour." ]
            _16bit,
            # [ doc = "8-bit timer behaviour." ]
            _08bit,
            # [ doc = "24-bit timer behaviour." ]
            _24bit,
            # [ doc = "32-bit timer behaviour." ]
            _32bit,
        }
        impl BitmodeW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BitmodeW::_16bit => 0,
                    BitmodeW::_08bit => 1,
                    BitmodeW::_24bit => 2,
                    BitmodeW::_32bit => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BitmodeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BitmodeW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: BitmodeW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "16-bit timer behaviour." ]
            # [ inline ( always ) ]
            pub fn _16bit(self) -> &'a mut W {
                self.variant(BitmodeW::_16bit)
            }
            # [ doc = "8-bit timer behaviour." ]
            # [ inline ( always ) ]
            pub fn _08bit(self) -> &'a mut W {
                self.variant(BitmodeW::_08bit)
            }
            # [ doc = "24-bit timer behaviour." ]
            # [ inline ( always ) ]
            pub fn _24bit(self) -> &'a mut W {
                self.variant(BitmodeW::_24bit)
            }
            # [ doc = "32-bit timer behaviour." ]
            # [ inline ( always ) ]
            pub fn _32bit(self) -> &'a mut W {
                self.variant(BitmodeW::_32bit)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - Sets timer behaviour ro be like the implementation of a timer with width as indicated." ]
            # [ inline ( always ) ]
            pub fn bitmode(&self) -> BitmodeR {
                BitmodeR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - Sets timer behaviour ro be like the implementation of a timer with width as indicated." ]
            # [ inline ( always ) ]
            pub fn bitmode(&mut self) -> _BitmodeW {
                _BitmodeW { w: self }
            }
        }
    }
    # [ doc = "4-bit prescaler to source clock frequency (max value 9). Source clock frequency is divided by 2^SCALE." ]
    pub struct Prescaler {
        register: VolatileCell<u32>,
    }
    # [ doc = "4-bit prescaler to source clock frequency (max value 9). Source clock frequency is divided by 2^SCALE." ]
    pub mod prescaler {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Prescaler {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PrescalerR {
            bits: u8,
        }
        impl PrescalerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PrescalerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PrescalerW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - Timer PRESCALER value. Max value is 9." ]
            # [ inline ( always ) ]
            pub fn prescaler(&self) -> PrescalerR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PrescalerR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:3 - Timer PRESCALER value. Max value is 9." ]
            # [ inline ( always ) ]
            pub fn prescaler(&mut self) -> _PrescalerW {
                _PrescalerW { w: self }
            }
        }
    }
    # [ doc = "Capture/compare registers." ]
    pub struct Cc {
        register: VolatileCell<u32>,
    }
    # [ doc = "Capture/compare registers." ]
    pub mod cc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "Timer 0." ]
pub struct Timer0 {
    register_block: timer0::RegisterBlock,
}
impl Deref for Timer0 {
    type Target = timer0::RegisterBlock;
    fn deref(&self) -> &timer0::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Timer 1." ]
pub const TIMER1: Peripheral<Timer1> = unsafe { Peripheral::new(1073778688) };
# [ doc = r" Register block" ]
pub struct Timer1 {
    register_block: timer0::RegisterBlock,
}
impl Deref for Timer1 {
    type Target = timer0::RegisterBlock;
    fn deref(&self) -> &timer0::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Timer 2." ]
pub const TIMER2: Peripheral<Timer2> = unsafe { Peripheral::new(1073782784) };
# [ doc = r" Register block" ]
pub struct Timer2 {
    register_block: timer0::RegisterBlock,
}
impl Deref for Timer2 {
    type Target = timer0::RegisterBlock;
    fn deref(&self) -> &timer0::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Real time counter 0." ]
pub const RTC0: Peripheral<Rtc0> = unsafe { Peripheral::new(1073786880) };
# [ doc = "Real time counter 0." ]
pub mod rtc0 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Start RTC Counter." ]
        pub tasks_start: TasksStart,
        # [ doc = "0x04 - Stop RTC Counter." ]
        pub tasks_stop: TasksStop,
        # [ doc = "0x08 - Clear RTC Counter." ]
        pub tasks_clear: TasksClear,
        # [ doc = "0x0c - Set COUNTER to 0xFFFFFFF0." ]
        pub tasks_trigovrflw: TasksTrigovrflw,
        _reserved0: [u8; 240usize],
        # [ doc = "0x100 - Event on COUNTER increment." ]
        pub events_tick: EventsTick,
        # [ doc = "0x104 - Event on COUNTER overflow." ]
        pub events_ovrflw: EventsOvrflw,
        _reserved1: [u8; 56usize],
        # [ doc = "0x140 - Compare event on CC[n] match." ]
        pub events_compare0: EventsCompare,
        # [ doc = "0x144 - Compare event on CC[n] match." ]
        pub events_compare1: EventsCompare,
        # [ doc = "0x148 - Compare event on CC[n] match." ]
        pub events_compare2: EventsCompare,
        # [ doc = "0x14c - Compare event on CC[n] match." ]
        pub events_compare3: EventsCompare,
        _reserved2: [u8; 436usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved3: [u8; 52usize],
        # [ doc = "0x340 - Configures event enable routing to PPI for each RTC event." ]
        pub evten: Evten,
        # [ doc = "0x344 - Enable events routing to PPI. The reading of this register gives the value of EVTEN." ]
        pub evtenset: Evtenset,
        # [ doc = "0x348 - Disable events routing to PPI. The reading of this register gives the value of EVTEN." ]
        pub evtenclr: Evtenclr,
        _reserved4: [u8; 440usize],
        # [ doc = "0x504 - Current COUNTER value." ]
        pub counter: Counter,
        # [ doc = "0x508 - 12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)). Must be written when RTC is STOPed." ]
        pub prescaler: Prescaler,
        _reserved5: [u8; 52usize],
        # [ doc = "0x540 - Capture/compare registers." ]
        pub cc0: Cc,
        # [ doc = "0x544 - Capture/compare registers." ]
        pub cc1: Cc,
        # [ doc = "0x548 - Capture/compare registers." ]
        pub cc2: Cc,
        # [ doc = "0x54c - Capture/compare registers." ]
        pub cc3: Cc,
        _reserved6: [u8; 2732usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Start RTC Counter." ]
    pub struct TasksStart {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start RTC Counter." ]
    pub mod tasks_start {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStart {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop RTC Counter." ]
    pub struct TasksStop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop RTC Counter." ]
    pub mod tasks_stop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Clear RTC Counter." ]
    pub struct TasksClear {
        register: VolatileCell<u32>,
    }
    # [ doc = "Clear RTC Counter." ]
    pub mod tasks_clear {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksClear {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Set COUNTER to 0xFFFFFFF0." ]
    pub struct TasksTrigovrflw {
        register: VolatileCell<u32>,
    }
    # [ doc = "Set COUNTER to 0xFFFFFFF0." ]
    pub mod tasks_trigovrflw {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksTrigovrflw {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Event on COUNTER increment." ]
    pub struct EventsTick {
        register: VolatileCell<u32>,
    }
    # [ doc = "Event on COUNTER increment." ]
    pub mod events_tick {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsTick {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Event on COUNTER overflow." ]
    pub struct EventsOvrflw {
        register: VolatileCell<u32>,
    }
    # [ doc = "Event on COUNTER overflow." ]
    pub mod events_ovrflw {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsOvrflw {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Compare event on CC[n] match." ]
    pub struct EventsCompare {
        register: VolatileCell<u32>,
    }
    # [ doc = "Compare event on CC[n] match." ]
    pub mod events_compare {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsCompare {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `TICK`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TickR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl TickR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TickR::Disabled => 0,
                    TickR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TickR {
                match bits {
                    0 => TickR::Disabled,
                    1 => TickR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == TickR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == TickR::Enabled
            }
        }
        # [ doc = "Possible values of the field `OVRFLW`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OvrflwR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl OvrflwR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OvrflwR::Disabled => 0,
                    OvrflwR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OvrflwR {
                match bits {
                    0 => OvrflwR::Disabled,
                    1 => OvrflwR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == OvrflwR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == OvrflwR::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare0R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl Compare0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare0R::Disabled => 0,
                    Compare0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare0R {
                match bits {
                    0 => Compare0R::Disabled,
                    1 => Compare0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare1R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl Compare1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare1R::Disabled => 0,
                    Compare1R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare1R {
                match bits {
                    0 => Compare1R::Disabled,
                    1 => Compare1R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare1R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare1R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare2R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl Compare2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare2R::Disabled => 0,
                    Compare2R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare2R {
                match bits {
                    0 => Compare2R::Disabled,
                    1 => Compare2R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare2R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare2R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare3R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl Compare3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare3R::Disabled => 0,
                    Compare3R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare3R {
                match bits {
                    0 => Compare3R::Disabled,
                    1 => Compare3R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare3R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare3R::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `TICK`" ]
        pub enum TickW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl TickW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TickW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TickW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TickW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TickW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(TickW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OVRFLW`" ]
        pub enum OvrflwW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl OvrflwW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OvrflwW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OvrflwW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OvrflwW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OvrflwW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(OvrflwW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE0`" ]
        pub enum Compare0W {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl Compare0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare0W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Compare0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE1`" ]
        pub enum Compare1W {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl Compare1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare1W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Compare1W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE2`" ]
        pub enum Compare2W {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl Compare2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare2W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Compare2W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE3`" ]
        pub enum Compare3W {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl Compare3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare3W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Compare3W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable interrupt on TICK event." ]
            # [ inline ( always ) ]
            pub fn tick(&self) -> TickR {
                TickR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Enable interrupt on OVRFLW event." ]
            # [ inline ( always ) ]
            pub fn ovrflw(&self) -> OvrflwR {
                OvrflwR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - Enable interrupt on COMPARE[0] event." ]
            # [ inline ( always ) ]
            pub fn compare0(&self) -> Compare0R {
                Compare0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Enable interrupt on COMPARE[1] event." ]
            # [ inline ( always ) ]
            pub fn compare1(&self) -> Compare1R {
                Compare1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Enable interrupt on COMPARE[2] event." ]
            # [ inline ( always ) ]
            pub fn compare2(&self) -> Compare2R {
                Compare2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Enable interrupt on COMPARE[3] event." ]
            # [ inline ( always ) ]
            pub fn compare3(&self) -> Compare3R {
                Compare3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable interrupt on TICK event." ]
            # [ inline ( always ) ]
            pub fn tick(&mut self) -> _TickW {
                _TickW { w: self }
            }
            # [ doc = "Bit 1 - Enable interrupt on OVRFLW event." ]
            # [ inline ( always ) ]
            pub fn ovrflw(&mut self) -> _OvrflwW {
                _OvrflwW { w: self }
            }
            # [ doc = "Bit 16 - Enable interrupt on COMPARE[0] event." ]
            # [ inline ( always ) ]
            pub fn compare0(&mut self) -> _Compare0W {
                _Compare0W { w: self }
            }
            # [ doc = "Bit 17 - Enable interrupt on COMPARE[1] event." ]
            # [ inline ( always ) ]
            pub fn compare1(&mut self) -> _Compare1W {
                _Compare1W { w: self }
            }
            # [ doc = "Bit 18 - Enable interrupt on COMPARE[2] event." ]
            # [ inline ( always ) ]
            pub fn compare2(&mut self) -> _Compare2W {
                _Compare2W { w: self }
            }
            # [ doc = "Bit 19 - Enable interrupt on COMPARE[3] event." ]
            # [ inline ( always ) ]
            pub fn compare3(&mut self) -> _Compare3W {
                _Compare3W { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `TICK`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TickR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl TickR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TickR::Disabled => 0,
                    TickR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TickR {
                match bits {
                    0 => TickR::Disabled,
                    1 => TickR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == TickR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == TickR::Enabled
            }
        }
        # [ doc = "Possible values of the field `OVRFLW`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OvrflwR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl OvrflwR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OvrflwR::Disabled => 0,
                    OvrflwR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OvrflwR {
                match bits {
                    0 => OvrflwR::Disabled,
                    1 => OvrflwR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == OvrflwR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == OvrflwR::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare0R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl Compare0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare0R::Disabled => 0,
                    Compare0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare0R {
                match bits {
                    0 => Compare0R::Disabled,
                    1 => Compare0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare1R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl Compare1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare1R::Disabled => 0,
                    Compare1R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare1R {
                match bits {
                    0 => Compare1R::Disabled,
                    1 => Compare1R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare1R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare1R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare2R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl Compare2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare2R::Disabled => 0,
                    Compare2R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare2R {
                match bits {
                    0 => Compare2R::Disabled,
                    1 => Compare2R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare2R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare2R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare3R {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl Compare3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare3R::Disabled => 0,
                    Compare3R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare3R {
                match bits {
                    0 => Compare3R::Disabled,
                    1 => Compare3R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare3R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare3R::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `TICK`" ]
        pub enum TickW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl TickW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TickW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TickW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TickW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TickW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(TickW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OVRFLW`" ]
        pub enum OvrflwW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl OvrflwW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OvrflwW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OvrflwW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OvrflwW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OvrflwW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(OvrflwW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE0`" ]
        pub enum Compare0W {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl Compare0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare0W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Compare0W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE1`" ]
        pub enum Compare1W {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl Compare1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare1W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Compare1W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE2`" ]
        pub enum Compare2W {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl Compare2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare2W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Compare2W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE3`" ]
        pub enum Compare3W {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl Compare3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare3W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Compare3W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable interrupt on TICK event." ]
            # [ inline ( always ) ]
            pub fn tick(&self) -> TickR {
                TickR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Disable interrupt on OVRFLW event." ]
            # [ inline ( always ) ]
            pub fn ovrflw(&self) -> OvrflwR {
                OvrflwR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - Disable interrupt on COMPARE[0] event." ]
            # [ inline ( always ) ]
            pub fn compare0(&self) -> Compare0R {
                Compare0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Disable interrupt on COMPARE[1] event." ]
            # [ inline ( always ) ]
            pub fn compare1(&self) -> Compare1R {
                Compare1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Disable interrupt on COMPARE[2] event." ]
            # [ inline ( always ) ]
            pub fn compare2(&self) -> Compare2R {
                Compare2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Disable interrupt on COMPARE[3] event." ]
            # [ inline ( always ) ]
            pub fn compare3(&self) -> Compare3R {
                Compare3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable interrupt on TICK event." ]
            # [ inline ( always ) ]
            pub fn tick(&mut self) -> _TickW {
                _TickW { w: self }
            }
            # [ doc = "Bit 1 - Disable interrupt on OVRFLW event." ]
            # [ inline ( always ) ]
            pub fn ovrflw(&mut self) -> _OvrflwW {
                _OvrflwW { w: self }
            }
            # [ doc = "Bit 16 - Disable interrupt on COMPARE[0] event." ]
            # [ inline ( always ) ]
            pub fn compare0(&mut self) -> _Compare0W {
                _Compare0W { w: self }
            }
            # [ doc = "Bit 17 - Disable interrupt on COMPARE[1] event." ]
            # [ inline ( always ) ]
            pub fn compare1(&mut self) -> _Compare1W {
                _Compare1W { w: self }
            }
            # [ doc = "Bit 18 - Disable interrupt on COMPARE[2] event." ]
            # [ inline ( always ) ]
            pub fn compare2(&mut self) -> _Compare2W {
                _Compare2W { w: self }
            }
            # [ doc = "Bit 19 - Disable interrupt on COMPARE[3] event." ]
            # [ inline ( always ) ]
            pub fn compare3(&mut self) -> _Compare3W {
                _Compare3W { w: self }
            }
        }
    }
    # [ doc = "Configures event enable routing to PPI for each RTC event." ]
    pub struct Evten {
        register: VolatileCell<u32>,
    }
    # [ doc = "Configures event enable routing to PPI for each RTC event." ]
    pub mod evten {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Evten {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `TICK`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TickR {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl TickR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TickR::Disabled => 0,
                    TickR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TickR {
                match bits {
                    0 => TickR::Disabled,
                    1 => TickR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == TickR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == TickR::Enabled
            }
        }
        # [ doc = "Possible values of the field `OVRFLW`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OvrflwR {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl OvrflwR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OvrflwR::Disabled => 0,
                    OvrflwR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OvrflwR {
                match bits {
                    0 => OvrflwR::Disabled,
                    1 => OvrflwR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == OvrflwR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == OvrflwR::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare0R {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl Compare0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare0R::Disabled => 0,
                    Compare0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare0R {
                match bits {
                    0 => Compare0R::Disabled,
                    1 => Compare0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare1R {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl Compare1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare1R::Disabled => 0,
                    Compare1R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare1R {
                match bits {
                    0 => Compare1R::Disabled,
                    1 => Compare1R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare1R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare1R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare2R {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl Compare2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare2R::Disabled => 0,
                    Compare2R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare2R {
                match bits {
                    0 => Compare2R::Disabled,
                    1 => Compare2R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare2R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare2R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare3R {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl Compare3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare3R::Disabled => 0,
                    Compare3R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare3R {
                match bits {
                    0 => Compare3R::Disabled,
                    1 => Compare3R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare3R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare3R::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `TICK`" ]
        pub enum TickW {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl TickW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TickW::Disabled => 0,
                    TickW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TickW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TickW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TickW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Event disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TickW::Disabled)
            }
            # [ doc = "Event enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TickW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OVRFLW`" ]
        pub enum OvrflwW {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl OvrflwW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OvrflwW::Disabled => 0,
                    OvrflwW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OvrflwW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OvrflwW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OvrflwW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Event disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OvrflwW::Disabled)
            }
            # [ doc = "Event enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OvrflwW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE0`" ]
        pub enum Compare0W {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl Compare0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare0W::Disabled => 0,
                    Compare0W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Event disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Compare0W::Disabled)
            }
            # [ doc = "Event enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Compare0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE1`" ]
        pub enum Compare1W {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl Compare1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare1W::Disabled => 0,
                    Compare1W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Event disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Compare1W::Disabled)
            }
            # [ doc = "Event enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Compare1W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE2`" ]
        pub enum Compare2W {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl Compare2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare2W::Disabled => 0,
                    Compare2W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Event disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Compare2W::Disabled)
            }
            # [ doc = "Event enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Compare2W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE3`" ]
        pub enum Compare3W {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl Compare3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare3W::Disabled => 0,
                    Compare3W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Event disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Compare3W::Disabled)
            }
            # [ doc = "Event enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Compare3W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - TICK event enable." ]
            # [ inline ( always ) ]
            pub fn tick(&self) -> TickR {
                TickR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - OVRFLW event enable." ]
            # [ inline ( always ) ]
            pub fn ovrflw(&self) -> OvrflwR {
                OvrflwR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - COMPARE[0] event enable." ]
            # [ inline ( always ) ]
            pub fn compare0(&self) -> Compare0R {
                Compare0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - COMPARE[1] event enable." ]
            # [ inline ( always ) ]
            pub fn compare1(&self) -> Compare1R {
                Compare1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - COMPARE[2] event enable." ]
            # [ inline ( always ) ]
            pub fn compare2(&self) -> Compare2R {
                Compare2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - COMPARE[3] event enable." ]
            # [ inline ( always ) ]
            pub fn compare3(&self) -> Compare3R {
                Compare3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - TICK event enable." ]
            # [ inline ( always ) ]
            pub fn tick(&mut self) -> _TickW {
                _TickW { w: self }
            }
            # [ doc = "Bit 1 - OVRFLW event enable." ]
            # [ inline ( always ) ]
            pub fn ovrflw(&mut self) -> _OvrflwW {
                _OvrflwW { w: self }
            }
            # [ doc = "Bit 16 - COMPARE[0] event enable." ]
            # [ inline ( always ) ]
            pub fn compare0(&mut self) -> _Compare0W {
                _Compare0W { w: self }
            }
            # [ doc = "Bit 17 - COMPARE[1] event enable." ]
            # [ inline ( always ) ]
            pub fn compare1(&mut self) -> _Compare1W {
                _Compare1W { w: self }
            }
            # [ doc = "Bit 18 - COMPARE[2] event enable." ]
            # [ inline ( always ) ]
            pub fn compare2(&mut self) -> _Compare2W {
                _Compare2W { w: self }
            }
            # [ doc = "Bit 19 - COMPARE[3] event enable." ]
            # [ inline ( always ) ]
            pub fn compare3(&mut self) -> _Compare3W {
                _Compare3W { w: self }
            }
        }
    }
    # [ doc = "Enable events routing to PPI. The reading of this register gives the value of EVTEN." ]
    pub struct Evtenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Enable events routing to PPI. The reading of this register gives the value of EVTEN." ]
    pub mod evtenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Evtenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `TICK`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TickR {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl TickR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TickR::Disabled => 0,
                    TickR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TickR {
                match bits {
                    0 => TickR::Disabled,
                    1 => TickR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == TickR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == TickR::Enabled
            }
        }
        # [ doc = "Possible values of the field `OVRFLW`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OvrflwR {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl OvrflwR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OvrflwR::Disabled => 0,
                    OvrflwR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OvrflwR {
                match bits {
                    0 => OvrflwR::Disabled,
                    1 => OvrflwR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == OvrflwR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == OvrflwR::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare0R {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl Compare0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare0R::Disabled => 0,
                    Compare0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare0R {
                match bits {
                    0 => Compare0R::Disabled,
                    1 => Compare0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare1R {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl Compare1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare1R::Disabled => 0,
                    Compare1R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare1R {
                match bits {
                    0 => Compare1R::Disabled,
                    1 => Compare1R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare1R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare1R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare2R {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl Compare2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare2R::Disabled => 0,
                    Compare2R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare2R {
                match bits {
                    0 => Compare2R::Disabled,
                    1 => Compare2R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare2R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare2R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare3R {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl Compare3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare3R::Disabled => 0,
                    Compare3R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare3R {
                match bits {
                    0 => Compare3R::Disabled,
                    1 => Compare3R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare3R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare3R::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `TICK`" ]
        pub enum TickW {
            # [ doc = "Enable event on write." ]
            Set,
        }
        impl TickW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TickW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TickW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TickW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TickW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable event on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(TickW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OVRFLW`" ]
        pub enum OvrflwW {
            # [ doc = "Enable event on write." ]
            Set,
        }
        impl OvrflwW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OvrflwW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OvrflwW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OvrflwW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OvrflwW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable event on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(OvrflwW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE0`" ]
        pub enum Compare0W {
            # [ doc = "Enable event on write." ]
            Set,
        }
        impl Compare0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare0W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable event on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Compare0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE1`" ]
        pub enum Compare1W {
            # [ doc = "Enable event on write." ]
            Set,
        }
        impl Compare1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare1W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable event on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Compare1W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE2`" ]
        pub enum Compare2W {
            # [ doc = "Enable event on write." ]
            Set,
        }
        impl Compare2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare2W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable event on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Compare2W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE3`" ]
        pub enum Compare3W {
            # [ doc = "Enable event on write." ]
            Set,
        }
        impl Compare3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare3W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable event on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Compare3W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable routing to PPI of TICK event." ]
            # [ inline ( always ) ]
            pub fn tick(&self) -> TickR {
                TickR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Enable routing to PPI of OVRFLW event." ]
            # [ inline ( always ) ]
            pub fn ovrflw(&self) -> OvrflwR {
                OvrflwR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - Enable routing to PPI of COMPARE[0] event." ]
            # [ inline ( always ) ]
            pub fn compare0(&self) -> Compare0R {
                Compare0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Enable routing to PPI of COMPARE[1] event." ]
            # [ inline ( always ) ]
            pub fn compare1(&self) -> Compare1R {
                Compare1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Enable routing to PPI of COMPARE[2] event." ]
            # [ inline ( always ) ]
            pub fn compare2(&self) -> Compare2R {
                Compare2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Enable routing to PPI of COMPARE[3] event." ]
            # [ inline ( always ) ]
            pub fn compare3(&self) -> Compare3R {
                Compare3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable routing to PPI of TICK event." ]
            # [ inline ( always ) ]
            pub fn tick(&mut self) -> _TickW {
                _TickW { w: self }
            }
            # [ doc = "Bit 1 - Enable routing to PPI of OVRFLW event." ]
            # [ inline ( always ) ]
            pub fn ovrflw(&mut self) -> _OvrflwW {
                _OvrflwW { w: self }
            }
            # [ doc = "Bit 16 - Enable routing to PPI of COMPARE[0] event." ]
            # [ inline ( always ) ]
            pub fn compare0(&mut self) -> _Compare0W {
                _Compare0W { w: self }
            }
            # [ doc = "Bit 17 - Enable routing to PPI of COMPARE[1] event." ]
            # [ inline ( always ) ]
            pub fn compare1(&mut self) -> _Compare1W {
                _Compare1W { w: self }
            }
            # [ doc = "Bit 18 - Enable routing to PPI of COMPARE[2] event." ]
            # [ inline ( always ) ]
            pub fn compare2(&mut self) -> _Compare2W {
                _Compare2W { w: self }
            }
            # [ doc = "Bit 19 - Enable routing to PPI of COMPARE[3] event." ]
            # [ inline ( always ) ]
            pub fn compare3(&mut self) -> _Compare3W {
                _Compare3W { w: self }
            }
        }
    }
    # [ doc = "Disable events routing to PPI. The reading of this register gives the value of EVTEN." ]
    pub struct Evtenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Disable events routing to PPI. The reading of this register gives the value of EVTEN." ]
    pub mod evtenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Evtenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `TICK`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TickR {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl TickR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TickR::Disabled => 0,
                    TickR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TickR {
                match bits {
                    0 => TickR::Disabled,
                    1 => TickR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == TickR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == TickR::Enabled
            }
        }
        # [ doc = "Possible values of the field `OVRFLW`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OvrflwR {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl OvrflwR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OvrflwR::Disabled => 0,
                    OvrflwR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OvrflwR {
                match bits {
                    0 => OvrflwR::Disabled,
                    1 => OvrflwR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == OvrflwR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == OvrflwR::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare0R {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl Compare0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare0R::Disabled => 0,
                    Compare0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare0R {
                match bits {
                    0 => Compare0R::Disabled,
                    1 => Compare0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare1R {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl Compare1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare1R::Disabled => 0,
                    Compare1R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare1R {
                match bits {
                    0 => Compare1R::Disabled,
                    1 => Compare1R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare1R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare1R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare2R {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl Compare2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare2R::Disabled => 0,
                    Compare2R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare2R {
                match bits {
                    0 => Compare2R::Disabled,
                    1 => Compare2R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare2R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare2R::Enabled
            }
        }
        # [ doc = "Possible values of the field `COMPARE3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Compare3R {
            # [ doc = "Event disabled." ]
            Disabled,
            # [ doc = "Event enabled." ]
            Enabled,
        }
        impl Compare3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Compare3R::Disabled => 0,
                    Compare3R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Compare3R {
                match bits {
                    0 => Compare3R::Disabled,
                    1 => Compare3R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Compare3R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Compare3R::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `TICK`" ]
        pub enum TickW {
            # [ doc = "Disable event on write." ]
            Clear,
        }
        impl TickW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TickW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TickW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TickW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TickW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable event on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(TickW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OVRFLW`" ]
        pub enum OvrflwW {
            # [ doc = "Disable event on write." ]
            Clear,
        }
        impl OvrflwW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OvrflwW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OvrflwW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OvrflwW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OvrflwW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable event on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(OvrflwW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE0`" ]
        pub enum Compare0W {
            # [ doc = "Disable event on write." ]
            Clear,
        }
        impl Compare0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare0W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable event on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Compare0W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE1`" ]
        pub enum Compare1W {
            # [ doc = "Disable event on write." ]
            Clear,
        }
        impl Compare1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare1W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable event on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Compare1W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE2`" ]
        pub enum Compare2W {
            # [ doc = "Disable event on write." ]
            Clear,
        }
        impl Compare2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare2W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable event on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Compare2W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `COMPARE3`" ]
        pub enum Compare3W {
            # [ doc = "Disable event on write." ]
            Clear,
        }
        impl Compare3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Compare3W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Compare3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Compare3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Compare3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable event on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Compare3W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable routing to PPI of TICK event." ]
            # [ inline ( always ) ]
            pub fn tick(&self) -> TickR {
                TickR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Disable routing to PPI of OVRFLW event." ]
            # [ inline ( always ) ]
            pub fn ovrflw(&self) -> OvrflwR {
                OvrflwR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - Disable routing to PPI of COMPARE[0] event." ]
            # [ inline ( always ) ]
            pub fn compare0(&self) -> Compare0R {
                Compare0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Disable routing to PPI of COMPARE[1] event." ]
            # [ inline ( always ) ]
            pub fn compare1(&self) -> Compare1R {
                Compare1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Disable routing to PPI of COMPARE[2] event." ]
            # [ inline ( always ) ]
            pub fn compare2(&self) -> Compare2R {
                Compare2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Disable routing to PPI of COMPARE[3] event." ]
            # [ inline ( always ) ]
            pub fn compare3(&self) -> Compare3R {
                Compare3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable routing to PPI of TICK event." ]
            # [ inline ( always ) ]
            pub fn tick(&mut self) -> _TickW {
                _TickW { w: self }
            }
            # [ doc = "Bit 1 - Disable routing to PPI of OVRFLW event." ]
            # [ inline ( always ) ]
            pub fn ovrflw(&mut self) -> _OvrflwW {
                _OvrflwW { w: self }
            }
            # [ doc = "Bit 16 - Disable routing to PPI of COMPARE[0] event." ]
            # [ inline ( always ) ]
            pub fn compare0(&mut self) -> _Compare0W {
                _Compare0W { w: self }
            }
            # [ doc = "Bit 17 - Disable routing to PPI of COMPARE[1] event." ]
            # [ inline ( always ) ]
            pub fn compare1(&mut self) -> _Compare1W {
                _Compare1W { w: self }
            }
            # [ doc = "Bit 18 - Disable routing to PPI of COMPARE[2] event." ]
            # [ inline ( always ) ]
            pub fn compare2(&mut self) -> _Compare2W {
                _Compare2W { w: self }
            }
            # [ doc = "Bit 19 - Disable routing to PPI of COMPARE[3] event." ]
            # [ inline ( always ) ]
            pub fn compare3(&mut self) -> _Compare3W {
                _Compare3W { w: self }
            }
        }
    }
    # [ doc = "Current COUNTER value." ]
    pub struct Counter {
        register: VolatileCell<u32>,
    }
    # [ doc = "Current COUNTER value." ]
    pub mod counter {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Counter {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CounterR {
            bits: u32,
        }
        impl CounterR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:23 - Counter value." ]
            # [ inline ( always ) ]
            pub fn counter(&self) -> CounterR {
                let bits = {
                    const MASK: u32 = 16777215;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CounterR { bits }
            }
        }
    }
    # [ doc = "12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)). Must be written when RTC is STOPed." ]
    pub struct Prescaler {
        register: VolatileCell<u32>,
    }
    # [ doc = "12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)). Must be written when RTC is STOPed." ]
    pub mod prescaler {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Prescaler {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PrescalerR {
            bits: u16,
        }
        impl PrescalerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PrescalerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PrescalerW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:11 - RTC PRESCALER value." ]
            # [ inline ( always ) ]
            pub fn prescaler(&self) -> PrescalerR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PrescalerR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:11 - RTC PRESCALER value." ]
            # [ inline ( always ) ]
            pub fn prescaler(&mut self) -> _PrescalerW {
                _PrescalerW { w: self }
            }
        }
    }
    # [ doc = "Capture/compare registers." ]
    pub struct Cc {
        register: VolatileCell<u32>,
    }
    # [ doc = "Capture/compare registers." ]
    pub mod cc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CompareR {
            bits: u32,
        }
        impl CompareR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CompareW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CompareW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 16777215;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:23 - Compare value." ]
            # [ inline ( always ) ]
            pub fn compare(&self) -> CompareR {
                let bits = {
                    const MASK: u32 = 16777215;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CompareR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:23 - Compare value." ]
            # [ inline ( always ) ]
            pub fn compare(&mut self) -> _CompareW {
                _CompareW { w: self }
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "Real time counter 0." ]
pub struct Rtc0 {
    register_block: rtc0::RegisterBlock,
}
impl Deref for Rtc0 {
    type Target = rtc0::RegisterBlock;
    fn deref(&self) -> &rtc0::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Temperature Sensor." ]
pub const TEMP: Peripheral<Temp> = unsafe { Peripheral::new(1073790976) };
# [ doc = "Temperature Sensor." ]
pub mod temp {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Start temperature measurement." ]
        pub tasks_start: TasksStart,
        # [ doc = "0x04 - Stop temperature measurement." ]
        pub tasks_stop: TasksStop,
        _reserved0: [u8; 248usize],
        # [ doc = "0x100 - Temperature measurement complete, data ready event." ]
        pub events_datardy: EventsDatardy,
        _reserved1: [u8; 512usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved2: [u8; 508usize],
        # [ doc = "0x508 - Die temperature in degC, 2's complement format, 0.25 degC pecision." ]
        pub temp: Temp,
        _reserved3: [u8; 2800usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Start temperature measurement." ]
    pub struct TasksStart {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start temperature measurement." ]
    pub mod tasks_start {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStart {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop temperature measurement." ]
    pub struct TasksStop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop temperature measurement." ]
    pub mod tasks_stop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Temperature measurement complete, data ready event." ]
    pub struct EventsDatardy {
        register: VolatileCell<u32>,
    }
    # [ doc = "Temperature measurement complete, data ready event." ]
    pub mod events_datardy {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsDatardy {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `DATARDY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DatardyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl DatardyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DatardyR::Disabled => 0,
                    DatardyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DatardyR {
                match bits {
                    0 => DatardyR::Disabled,
                    1 => DatardyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DatardyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DatardyR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `DATARDY`" ]
        pub enum DatardyW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl DatardyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DatardyW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatardyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatardyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DatardyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(DatardyW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable interrupt on DATARDY event." ]
            # [ inline ( always ) ]
            pub fn datardy(&self) -> DatardyR {
                DatardyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable interrupt on DATARDY event." ]
            # [ inline ( always ) ]
            pub fn datardy(&mut self) -> _DatardyW {
                _DatardyW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `DATARDY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DatardyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl DatardyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DatardyR::Disabled => 0,
                    DatardyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DatardyR {
                match bits {
                    0 => DatardyR::Disabled,
                    1 => DatardyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DatardyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DatardyR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `DATARDY`" ]
        pub enum DatardyW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl DatardyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DatardyW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatardyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatardyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DatardyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(DatardyW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable interrupt on DATARDY event." ]
            # [ inline ( always ) ]
            pub fn datardy(&self) -> DatardyR {
                DatardyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable interrupt on DATARDY event." ]
            # [ inline ( always ) ]
            pub fn datardy(&mut self) -> _DatardyW {
                _DatardyW { w: self }
            }
        }
    }
    # [ doc = "Die temperature in degC, 2's complement format, 0.25 degC pecision." ]
    pub struct Temp {
        register: VolatileCell<u32>,
    }
    # [ doc = "Die temperature in degC, 2's complement format, 0.25 degC pecision." ]
    pub mod temp {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Temp {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "Temperature Sensor." ]
pub struct Temp {
    register_block: temp::RegisterBlock,
}
impl Deref for Temp {
    type Target = temp::RegisterBlock;
    fn deref(&self) -> &temp::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Random Number Generator." ]
pub const RNG: Peripheral<Rng> = unsafe { Peripheral::new(1073795072) };
# [ doc = "Random Number Generator." ]
pub mod rng {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Start the random number generator." ]
        pub tasks_start: TasksStart,
        # [ doc = "0x04 - Stop the random number generator." ]
        pub tasks_stop: TasksStop,
        _reserved0: [u8; 248usize],
        # [ doc = "0x100 - New random number generated and written to VALUE register." ]
        pub events_valrdy: EventsValrdy,
        _reserved1: [u8; 252usize],
        # [ doc = "0x200 - Shortcuts for the RNG." ]
        pub shorts: Shorts,
        _reserved2: [u8; 256usize],
        # [ doc = "0x304 - Interrupt enable set register" ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register" ]
        pub intenclr: Intenclr,
        _reserved3: [u8; 504usize],
        # [ doc = "0x504 - Configuration register." ]
        pub config: Config,
        # [ doc = "0x508 - RNG random number." ]
        pub value: Value,
        _reserved4: [u8; 2800usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Start the random number generator." ]
    pub struct TasksStart {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start the random number generator." ]
    pub mod tasks_start {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStart {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop the random number generator." ]
    pub struct TasksStop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop the random number generator." ]
    pub mod tasks_stop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "New random number generated and written to VALUE register." ]
    pub struct EventsValrdy {
        register: VolatileCell<u32>,
    }
    # [ doc = "New random number generated and written to VALUE register." ]
    pub mod events_valrdy {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsValrdy {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Shortcuts for the RNG." ]
    pub struct Shorts {
        register: VolatileCell<u32>,
    }
    # [ doc = "Shortcuts for the RNG." ]
    pub mod shorts {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Shorts {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `VALRDY_STOP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ValrdyStopR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl ValrdyStopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ValrdyStopR::Disabled => 0,
                    ValrdyStopR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ValrdyStopR {
                match bits {
                    0 => ValrdyStopR::Disabled,
                    1 => ValrdyStopR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ValrdyStopR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ValrdyStopR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `VALRDY_STOP`" ]
        pub enum ValrdyStopW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl ValrdyStopW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ValrdyStopW::Disabled => 0,
                    ValrdyStopW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ValrdyStopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ValrdyStopW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ValrdyStopW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ValrdyStopW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ValrdyStopW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Shortcut between VALRDY event and STOP task." ]
            # [ inline ( always ) ]
            pub fn valrdy_stop(&self) -> ValrdyStopR {
                ValrdyStopR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Shortcut between VALRDY event and STOP task." ]
            # [ inline ( always ) ]
            pub fn valrdy_stop(&mut self) -> _ValrdyStopW {
                _ValrdyStopW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable set register" ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register" ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `VALRDY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ValrdyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ValrdyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ValrdyR::Disabled => 0,
                    ValrdyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ValrdyR {
                match bits {
                    0 => ValrdyR::Disabled,
                    1 => ValrdyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ValrdyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ValrdyR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `VALRDY`" ]
        pub enum ValrdyW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl ValrdyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ValrdyW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ValrdyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ValrdyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ValrdyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(ValrdyW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable interrupt on VALRDY event." ]
            # [ inline ( always ) ]
            pub fn valrdy(&self) -> ValrdyR {
                ValrdyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable interrupt on VALRDY event." ]
            # [ inline ( always ) ]
            pub fn valrdy(&mut self) -> _ValrdyW {
                _ValrdyW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register" ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register" ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `VALRDY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ValrdyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ValrdyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ValrdyR::Disabled => 0,
                    ValrdyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ValrdyR {
                match bits {
                    0 => ValrdyR::Disabled,
                    1 => ValrdyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ValrdyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ValrdyR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `VALRDY`" ]
        pub enum ValrdyW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl ValrdyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ValrdyW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ValrdyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ValrdyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ValrdyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(ValrdyW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable interrupt on VALRDY event." ]
            # [ inline ( always ) ]
            pub fn valrdy(&self) -> ValrdyR {
                ValrdyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable interrupt on VALRDY event." ]
            # [ inline ( always ) ]
            pub fn valrdy(&mut self) -> _ValrdyW {
                _ValrdyW { w: self }
            }
        }
    }
    # [ doc = "Configuration register." ]
    pub struct Config {
        register: VolatileCell<u32>,
    }
    # [ doc = "Configuration register." ]
    pub mod config {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Config {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `DERCEN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DercenR {
            # [ doc = "Digital error correction disabled." ]
            Disabled,
            # [ doc = "Digital error correction enabled." ]
            Enabled,
        }
        impl DercenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DercenR::Disabled => 0,
                    DercenR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DercenR {
                match bits {
                    0 => DercenR::Disabled,
                    1 => DercenR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DercenR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DercenR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `DERCEN`" ]
        pub enum DercenW {
            # [ doc = "Digital error correction disabled." ]
            Disabled,
            # [ doc = "Digital error correction enabled." ]
            Enabled,
        }
        impl DercenW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DercenW::Disabled => 0,
                    DercenW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DercenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DercenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DercenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Digital error correction disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DercenW::Disabled)
            }
            # [ doc = "Digital error correction enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DercenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Digital error correction enable." ]
            # [ inline ( always ) ]
            pub fn dercen(&self) -> DercenR {
                DercenR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Digital error correction enable." ]
            # [ inline ( always ) ]
            pub fn dercen(&mut self) -> _DercenW {
                _DercenW { w: self }
            }
        }
    }
    # [ doc = "RNG random number." ]
    pub struct Value {
        register: VolatileCell<u32>,
    }
    # [ doc = "RNG random number." ]
    pub mod value {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Value {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ValueR {
            bits: u8,
        }
        impl ValueR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Generated random number." ]
            # [ inline ( always ) ]
            pub fn value(&self) -> ValueR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ValueR { bits }
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "Random Number Generator." ]
pub struct Rng {
    register_block: rng::RegisterBlock,
}
impl Deref for Rng {
    type Target = rng::RegisterBlock;
    fn deref(&self) -> &rng::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "AES ECB Mode Encryption." ]
pub const ECB: Peripheral<Ecb> = unsafe { Peripheral::new(1073799168) };
# [ doc = "AES ECB Mode Encryption." ]
pub mod ecb {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Start ECB block encrypt. If a crypto operation is running, this will not initiate a new encryption and the ERRORECB event will be triggered." ]
        pub tasks_startecb: TasksStartecb,
        # [ doc = "0x04 - Stop current ECB encryption. If a crypto operation is running, this will will trigger the ERRORECB event." ]
        pub tasks_stopecb: TasksStopecb,
        _reserved0: [u8; 248usize],
        # [ doc = "0x100 - ECB block encrypt complete." ]
        pub events_endecb: EventsEndecb,
        # [ doc = "0x104 - ECB block encrypt aborted due to a STOPECB task or due to an error." ]
        pub events_errorecb: EventsErrorecb,
        _reserved1: [u8; 508usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved2: [u8; 504usize],
        # [ doc = "0x504 - ECB block encrypt memory pointer." ]
        pub ecbdataptr: Ecbdataptr,
        _reserved3: [u8; 2804usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Start ECB block encrypt. If a crypto operation is running, this will not initiate a new encryption and the ERRORECB event will be triggered." ]
    pub struct TasksStartecb {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start ECB block encrypt. If a crypto operation is running, this will not initiate a new encryption and the ERRORECB event will be triggered." ]
    pub mod tasks_startecb {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStartecb {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop current ECB encryption. If a crypto operation is running, this will will trigger the ERRORECB event." ]
    pub struct TasksStopecb {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop current ECB encryption. If a crypto operation is running, this will will trigger the ERRORECB event." ]
    pub mod tasks_stopecb {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStopecb {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "ECB block encrypt complete." ]
    pub struct EventsEndecb {
        register: VolatileCell<u32>,
    }
    # [ doc = "ECB block encrypt complete." ]
    pub mod events_endecb {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsEndecb {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "ECB block encrypt aborted due to a STOPECB task or due to an error." ]
    pub struct EventsErrorecb {
        register: VolatileCell<u32>,
    }
    # [ doc = "ECB block encrypt aborted due to a STOPECB task or due to an error." ]
    pub mod events_errorecb {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsErrorecb {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ENDECB`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndecbR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndecbR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndecbR::Disabled => 0,
                    EndecbR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndecbR {
                match bits {
                    0 => EndecbR::Disabled,
                    1 => EndecbR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndecbR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndecbR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ERRORECB`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ErrorecbR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ErrorecbR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ErrorecbR::Disabled => 0,
                    ErrorecbR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ErrorecbR {
                match bits {
                    0 => ErrorecbR::Disabled,
                    1 => ErrorecbR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ErrorecbR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ErrorecbR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `ENDECB`" ]
        pub enum EndecbW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl EndecbW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndecbW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndecbW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndecbW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndecbW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(EndecbW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ERRORECB`" ]
        pub enum ErrorecbW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl ErrorecbW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ErrorecbW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ErrorecbW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ErrorecbW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ErrorecbW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(ErrorecbW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable interrupt on ENDECB event." ]
            # [ inline ( always ) ]
            pub fn endecb(&self) -> EndecbR {
                EndecbR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Enable interrupt on ERRORECB event." ]
            # [ inline ( always ) ]
            pub fn errorecb(&self) -> ErrorecbR {
                ErrorecbR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable interrupt on ENDECB event." ]
            # [ inline ( always ) ]
            pub fn endecb(&mut self) -> _EndecbW {
                _EndecbW { w: self }
            }
            # [ doc = "Bit 1 - Enable interrupt on ERRORECB event." ]
            # [ inline ( always ) ]
            pub fn errorecb(&mut self) -> _ErrorecbW {
                _ErrorecbW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ENDECB`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndecbR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndecbR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndecbR::Disabled => 0,
                    EndecbR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndecbR {
                match bits {
                    0 => EndecbR::Disabled,
                    1 => EndecbR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndecbR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndecbR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ERRORECB`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ErrorecbR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ErrorecbR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ErrorecbR::Disabled => 0,
                    ErrorecbR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ErrorecbR {
                match bits {
                    0 => ErrorecbR::Disabled,
                    1 => ErrorecbR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ErrorecbR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ErrorecbR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `ENDECB`" ]
        pub enum EndecbW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl EndecbW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndecbW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndecbW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndecbW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndecbW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(EndecbW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ERRORECB`" ]
        pub enum ErrorecbW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl ErrorecbW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ErrorecbW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ErrorecbW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ErrorecbW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ErrorecbW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(ErrorecbW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable interrupt on ENDECB event." ]
            # [ inline ( always ) ]
            pub fn endecb(&self) -> EndecbR {
                EndecbR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Disable interrupt on ERRORECB event." ]
            # [ inline ( always ) ]
            pub fn errorecb(&self) -> ErrorecbR {
                ErrorecbR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable interrupt on ENDECB event." ]
            # [ inline ( always ) ]
            pub fn endecb(&mut self) -> _EndecbW {
                _EndecbW { w: self }
            }
            # [ doc = "Bit 1 - Disable interrupt on ERRORECB event." ]
            # [ inline ( always ) ]
            pub fn errorecb(&mut self) -> _ErrorecbW {
                _ErrorecbW { w: self }
            }
        }
    }
    # [ doc = "ECB block encrypt memory pointer." ]
    pub struct Ecbdataptr {
        register: VolatileCell<u32>,
    }
    # [ doc = "ECB block encrypt memory pointer." ]
    pub mod ecbdataptr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ecbdataptr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "AES ECB Mode Encryption." ]
pub struct Ecb {
    register_block: ecb::RegisterBlock,
}
impl Deref for Ecb {
    type Target = ecb::RegisterBlock;
    fn deref(&self) -> &ecb::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Accelerated Address Resolver." ]
pub const AAR: Peripheral<Aar> = unsafe { Peripheral::new(1073803264) };
# [ doc = "Accelerated Address Resolver." ]
pub mod aar {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Start resolving addresses based on IRKs specified in the IRK data structure." ]
        pub tasks_start: TasksStart,
        _reserved0: [u8; 4usize],
        # [ doc = "0x08 - Stop resolving addresses." ]
        pub tasks_stop: TasksStop,
        _reserved1: [u8; 244usize],
        # [ doc = "0x100 - Address resolution procedure completed." ]
        pub events_end: EventsEnd,
        # [ doc = "0x104 - Address resolved." ]
        pub events_resolved: EventsResolved,
        # [ doc = "0x108 - Address not resolved." ]
        pub events_notresolved: EventsNotresolved,
        _reserved2: [u8; 504usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved3: [u8; 244usize],
        # [ doc = "0x400 - Resolution status." ]
        pub status: Status,
        _reserved4: [u8; 252usize],
        # [ doc = "0x500 - Enable AAR." ]
        pub enable: Enable,
        # [ doc = "0x504 - Number of Identity root Keys in the IRK data structure." ]
        pub nirk: Nirk,
        # [ doc = "0x508 - Pointer to the IRK data structure." ]
        pub irkptr: Irkptr,
        _reserved5: [u8; 4usize],
        # [ doc = "0x510 - Pointer to the resolvable address (6 bytes)." ]
        pub addrptr: Addrptr,
        # [ doc = "0x514 - Pointer to a \"scratch\" data area used for temporary storage during resolution. A minimum of 3 bytes must be reserved." ]
        pub scratchptr: Scratchptr,
        _reserved6: [u8; 2788usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Start resolving addresses based on IRKs specified in the IRK data structure." ]
    pub struct TasksStart {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start resolving addresses based on IRKs specified in the IRK data structure." ]
    pub mod tasks_start {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStart {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop resolving addresses." ]
    pub struct TasksStop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop resolving addresses." ]
    pub mod tasks_stop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Address resolution procedure completed." ]
    pub struct EventsEnd {
        register: VolatileCell<u32>,
    }
    # [ doc = "Address resolution procedure completed." ]
    pub mod events_end {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsEnd {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Address resolved." ]
    pub struct EventsResolved {
        register: VolatileCell<u32>,
    }
    # [ doc = "Address resolved." ]
    pub mod events_resolved {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsResolved {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Address not resolved." ]
    pub struct EventsNotresolved {
        register: VolatileCell<u32>,
    }
    # [ doc = "Address not resolved." ]
    pub mod events_notresolved {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsNotresolved {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `END`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndR::Disabled => 0,
                    EndR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndR {
                match bits {
                    0 => EndR::Disabled,
                    1 => EndR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndR::Enabled
            }
        }
        # [ doc = "Possible values of the field `RESOLVED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ResolvedR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ResolvedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ResolvedR::Disabled => 0,
                    ResolvedR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ResolvedR {
                match bits {
                    0 => ResolvedR::Disabled,
                    1 => ResolvedR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ResolvedR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ResolvedR::Enabled
            }
        }
        # [ doc = "Possible values of the field `NOTRESOLVED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum NotresolvedR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl NotresolvedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    NotresolvedR::Disabled => 0,
                    NotresolvedR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> NotresolvedR {
                match bits {
                    0 => NotresolvedR::Disabled,
                    1 => NotresolvedR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == NotresolvedR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == NotresolvedR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `END`" ]
        pub enum EndW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl EndW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(EndW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RESOLVED`" ]
        pub enum ResolvedW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl ResolvedW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ResolvedW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ResolvedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ResolvedW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ResolvedW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(ResolvedW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `NOTRESOLVED`" ]
        pub enum NotresolvedW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl NotresolvedW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    NotresolvedW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NotresolvedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NotresolvedW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: NotresolvedW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(NotresolvedW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable interrupt on END event." ]
            # [ inline ( always ) ]
            pub fn end(&self) -> EndR {
                EndR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Enable interrupt on RESOLVED event." ]
            # [ inline ( always ) ]
            pub fn resolved(&self) -> ResolvedR {
                ResolvedR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Enable interrupt on NOTRESOLVED event." ]
            # [ inline ( always ) ]
            pub fn notresolved(&self) -> NotresolvedR {
                NotresolvedR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable interrupt on END event." ]
            # [ inline ( always ) ]
            pub fn end(&mut self) -> _EndW {
                _EndW { w: self }
            }
            # [ doc = "Bit 1 - Enable interrupt on RESOLVED event." ]
            # [ inline ( always ) ]
            pub fn resolved(&mut self) -> _ResolvedW {
                _ResolvedW { w: self }
            }
            # [ doc = "Bit 2 - Enable interrupt on NOTRESOLVED event." ]
            # [ inline ( always ) ]
            pub fn notresolved(&mut self) -> _NotresolvedW {
                _NotresolvedW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `END`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndR::Disabled => 0,
                    EndR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndR {
                match bits {
                    0 => EndR::Disabled,
                    1 => EndR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndR::Enabled
            }
        }
        # [ doc = "Possible values of the field `RESOLVED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ResolvedR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ResolvedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ResolvedR::Disabled => 0,
                    ResolvedR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ResolvedR {
                match bits {
                    0 => ResolvedR::Disabled,
                    1 => ResolvedR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ResolvedR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ResolvedR::Enabled
            }
        }
        # [ doc = "Possible values of the field `NOTRESOLVED`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum NotresolvedR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl NotresolvedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    NotresolvedR::Disabled => 0,
                    NotresolvedR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> NotresolvedR {
                match bits {
                    0 => NotresolvedR::Disabled,
                    1 => NotresolvedR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == NotresolvedR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == NotresolvedR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `END`" ]
        pub enum EndW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl EndW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(EndW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RESOLVED`" ]
        pub enum ResolvedW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl ResolvedW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ResolvedW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ResolvedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ResolvedW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ResolvedW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(ResolvedW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `NOTRESOLVED`" ]
        pub enum NotresolvedW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl NotresolvedW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    NotresolvedW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NotresolvedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NotresolvedW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: NotresolvedW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(NotresolvedW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable interrupt on ENDKSGEN event." ]
            # [ inline ( always ) ]
            pub fn end(&self) -> EndR {
                EndR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Disable interrupt on RESOLVED event." ]
            # [ inline ( always ) ]
            pub fn resolved(&self) -> ResolvedR {
                ResolvedR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Disable interrupt on NOTRESOLVED event." ]
            # [ inline ( always ) ]
            pub fn notresolved(&self) -> NotresolvedR {
                NotresolvedR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable interrupt on ENDKSGEN event." ]
            # [ inline ( always ) ]
            pub fn end(&mut self) -> _EndW {
                _EndW { w: self }
            }
            # [ doc = "Bit 1 - Disable interrupt on RESOLVED event." ]
            # [ inline ( always ) ]
            pub fn resolved(&mut self) -> _ResolvedW {
                _ResolvedW { w: self }
            }
            # [ doc = "Bit 2 - Disable interrupt on NOTRESOLVED event." ]
            # [ inline ( always ) ]
            pub fn notresolved(&mut self) -> _NotresolvedW {
                _NotresolvedW { w: self }
            }
        }
    }
    # [ doc = "Resolution status." ]
    pub struct Status {
        register: VolatileCell<u32>,
    }
    # [ doc = "Resolution status." ]
    pub mod status {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Status {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct StatusR {
            bits: u8,
        }
        impl StatusR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - The IRK used last time an address was resolved." ]
            # [ inline ( always ) ]
            pub fn status(&self) -> StatusR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StatusR { bits }
            }
        }
    }
    # [ doc = "Enable AAR." ]
    pub struct Enable {
        register: VolatileCell<u32>,
    }
    # [ doc = "Enable AAR." ]
    pub mod enable {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Enable {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ENABLE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EnableR {
            # [ doc = "Disabled AAR." ]
            Disabled,
            # [ doc = "Enable AAR." ]
            Enabled,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl EnableR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EnableR::Disabled => 0,
                    EnableR::Enabled => 3,
                    EnableR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EnableR {
                match bits {
                    0 => EnableR::Disabled,
                    3 => EnableR::Enabled,
                    i => EnableR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EnableR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EnableR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `ENABLE`" ]
        pub enum EnableW {
            # [ doc = "Disabled AAR." ]
            Disabled,
            # [ doc = "Enable AAR." ]
            Enabled,
        }
        impl EnableW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EnableW::Disabled => 0,
                    EnableW::Enabled => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnableW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnableW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EnableW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disabled AAR." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EnableW::Disabled)
            }
            # [ doc = "Enable AAR." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EnableW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - Enable AAR." ]
            # [ inline ( always ) ]
            pub fn enable(&self) -> EnableR {
                EnableR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - Enable AAR." ]
            # [ inline ( always ) ]
            pub fn enable(&mut self) -> _EnableW {
                _EnableW { w: self }
            }
        }
    }
    # [ doc = "Number of Identity root Keys in the IRK data structure." ]
    pub struct Nirk {
        register: VolatileCell<u32>,
    }
    # [ doc = "Number of Identity root Keys in the IRK data structure." ]
    pub mod nirk {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Nirk {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NirkR {
            bits: u8,
        }
        impl NirkR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NirkW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NirkW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:4 - Number of Identity root Keys in the IRK data structure." ]
            # [ inline ( always ) ]
            pub fn nirk(&self) -> NirkR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NirkR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 1 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:4 - Number of Identity root Keys in the IRK data structure." ]
            # [ inline ( always ) ]
            pub fn nirk(&mut self) -> _NirkW {
                _NirkW { w: self }
            }
        }
    }
    # [ doc = "Pointer to the IRK data structure." ]
    pub struct Irkptr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pointer to the IRK data structure." ]
    pub mod irkptr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Irkptr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pointer to the resolvable address (6 bytes)." ]
    pub struct Addrptr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pointer to the resolvable address (6 bytes)." ]
    pub mod addrptr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Addrptr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pointer to a \"scratch\" data area used for temporary storage during resolution. A minimum of 3 bytes must be reserved." ]
    pub struct Scratchptr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pointer to a \"scratch\" data area used for temporary storage during resolution. A minimum of 3 bytes must be reserved." ]
    pub mod scratchptr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Scratchptr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "Accelerated Address Resolver." ]
pub struct Aar {
    register_block: aar::RegisterBlock,
}
impl Deref for Aar {
    type Target = aar::RegisterBlock;
    fn deref(&self) -> &aar::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "AES CCM Mode Encryption." ]
pub const CCM: Peripheral<Ccm> = unsafe { Peripheral::new(1073803264) };
# [ doc = "AES CCM Mode Encryption." ]
pub mod ccm {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Start generation of key-stream. This operation will stop by itself when completed." ]
        pub tasks_ksgen: TasksKsgen,
        # [ doc = "0x04 - Start encrypt/decrypt. This operation will stop by itself when completed." ]
        pub tasks_crypt: TasksCrypt,
        # [ doc = "0x08 - Stop encrypt/decrypt." ]
        pub tasks_stop: TasksStop,
        _reserved0: [u8; 244usize],
        # [ doc = "0x100 - Keystream generation completed." ]
        pub events_endksgen: EventsEndksgen,
        # [ doc = "0x104 - Encrypt/decrypt completed." ]
        pub events_endcrypt: EventsEndcrypt,
        # [ doc = "0x108 - Error happened." ]
        pub events_error: EventsError,
        _reserved1: [u8; 244usize],
        # [ doc = "0x200 - Shortcuts for the CCM." ]
        pub shorts: Shorts,
        _reserved2: [u8; 256usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved3: [u8; 244usize],
        # [ doc = "0x400 - CCM RX MIC check result." ]
        pub micstatus: Micstatus,
        _reserved4: [u8; 252usize],
        # [ doc = "0x500 - CCM enable." ]
        pub enable: Enable,
        # [ doc = "0x504 - Operation mode." ]
        pub mode: Mode,
        # [ doc = "0x508 - Pointer to a data structure holding AES key and NONCE vector." ]
        pub cnfptr: Cnfptr,
        # [ doc = "0x50c - Pointer to the input packet." ]
        pub inptr: Inptr,
        # [ doc = "0x510 - Pointer to the output packet." ]
        pub outptr: Outptr,
        # [ doc = "0x514 - Pointer to a \"scratch\" data area used for temporary storage during resolution. A minimum of 43 bytes must be reserved." ]
        pub scratchptr: Scratchptr,
        _reserved5: [u8; 2788usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Start generation of key-stream. This operation will stop by itself when completed." ]
    pub struct TasksKsgen {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start generation of key-stream. This operation will stop by itself when completed." ]
    pub mod tasks_ksgen {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksKsgen {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Start encrypt/decrypt. This operation will stop by itself when completed." ]
    pub struct TasksCrypt {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start encrypt/decrypt. This operation will stop by itself when completed." ]
    pub mod tasks_crypt {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksCrypt {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop encrypt/decrypt." ]
    pub struct TasksStop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop encrypt/decrypt." ]
    pub mod tasks_stop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Keystream generation completed." ]
    pub struct EventsEndksgen {
        register: VolatileCell<u32>,
    }
    # [ doc = "Keystream generation completed." ]
    pub mod events_endksgen {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsEndksgen {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Encrypt/decrypt completed." ]
    pub struct EventsEndcrypt {
        register: VolatileCell<u32>,
    }
    # [ doc = "Encrypt/decrypt completed." ]
    pub mod events_endcrypt {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsEndcrypt {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Error happened." ]
    pub struct EventsError {
        register: VolatileCell<u32>,
    }
    # [ doc = "Error happened." ]
    pub mod events_error {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsError {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Shortcuts for the CCM." ]
    pub struct Shorts {
        register: VolatileCell<u32>,
    }
    # [ doc = "Shortcuts for the CCM." ]
    pub mod shorts {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Shorts {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ENDKSGEN_CRYPT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndksgenCryptR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl EndksgenCryptR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndksgenCryptR::Disabled => 0,
                    EndksgenCryptR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndksgenCryptR {
                match bits {
                    0 => EndksgenCryptR::Disabled,
                    1 => EndksgenCryptR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndksgenCryptR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndksgenCryptR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `ENDKSGEN_CRYPT`" ]
        pub enum EndksgenCryptW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl EndksgenCryptW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndksgenCryptW::Disabled => 0,
                    EndksgenCryptW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndksgenCryptW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndksgenCryptW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndksgenCryptW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EndksgenCryptW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EndksgenCryptW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Shortcut between ENDKSGEN event and CRYPT task." ]
            # [ inline ( always ) ]
            pub fn endksgen_crypt(&self) -> EndksgenCryptR {
                EndksgenCryptR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Shortcut between ENDKSGEN event and CRYPT task." ]
            # [ inline ( always ) ]
            pub fn endksgen_crypt(&mut self) -> _EndksgenCryptW {
                _EndksgenCryptW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ENDKSGEN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndksgenR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndksgenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndksgenR::Disabled => 0,
                    EndksgenR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndksgenR {
                match bits {
                    0 => EndksgenR::Disabled,
                    1 => EndksgenR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndksgenR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndksgenR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ENDCRYPT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndcryptR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndcryptR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndcryptR::Disabled => 0,
                    EndcryptR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndcryptR {
                match bits {
                    0 => EndcryptR::Disabled,
                    1 => EndcryptR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndcryptR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndcryptR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ERROR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ErrorR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ErrorR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ErrorR::Disabled => 0,
                    ErrorR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ErrorR {
                match bits {
                    0 => ErrorR::Disabled,
                    1 => ErrorR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ErrorR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ErrorR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `ENDKSGEN`" ]
        pub enum EndksgenW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl EndksgenW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndksgenW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndksgenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndksgenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndksgenW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(EndksgenW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ENDCRYPT`" ]
        pub enum EndcryptW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl EndcryptW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndcryptW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndcryptW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndcryptW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndcryptW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(EndcryptW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ERROR`" ]
        pub enum ErrorW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl ErrorW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ErrorW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ErrorW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ErrorW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ErrorW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(ErrorW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable interrupt on ENDKSGEN event." ]
            # [ inline ( always ) ]
            pub fn endksgen(&self) -> EndksgenR {
                EndksgenR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Enable interrupt on ENDCRYPT event." ]
            # [ inline ( always ) ]
            pub fn endcrypt(&self) -> EndcryptR {
                EndcryptR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Enable interrupt on ERROR event." ]
            # [ inline ( always ) ]
            pub fn error(&self) -> ErrorR {
                ErrorR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable interrupt on ENDKSGEN event." ]
            # [ inline ( always ) ]
            pub fn endksgen(&mut self) -> _EndksgenW {
                _EndksgenW { w: self }
            }
            # [ doc = "Bit 1 - Enable interrupt on ENDCRYPT event." ]
            # [ inline ( always ) ]
            pub fn endcrypt(&mut self) -> _EndcryptW {
                _EndcryptW { w: self }
            }
            # [ doc = "Bit 2 - Enable interrupt on ERROR event." ]
            # [ inline ( always ) ]
            pub fn error(&mut self) -> _ErrorW {
                _ErrorW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ENDKSGEN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndksgenR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndksgenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndksgenR::Disabled => 0,
                    EndksgenR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndksgenR {
                match bits {
                    0 => EndksgenR::Disabled,
                    1 => EndksgenR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndksgenR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndksgenR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ENDCRYPT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EndcryptR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl EndcryptR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EndcryptR::Disabled => 0,
                    EndcryptR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EndcryptR {
                match bits {
                    0 => EndcryptR::Disabled,
                    1 => EndcryptR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EndcryptR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EndcryptR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ERROR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ErrorR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ErrorR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ErrorR::Disabled => 0,
                    ErrorR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ErrorR {
                match bits {
                    0 => ErrorR::Disabled,
                    1 => ErrorR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ErrorR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ErrorR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `ENDKSGEN`" ]
        pub enum EndksgenW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl EndksgenW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndksgenW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndksgenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndksgenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndksgenW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(EndksgenW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ENDCRYPT`" ]
        pub enum EndcryptW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl EndcryptW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EndcryptW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndcryptW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndcryptW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EndcryptW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(EndcryptW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ERROR`" ]
        pub enum ErrorW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl ErrorW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ErrorW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ErrorW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ErrorW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ErrorW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(ErrorW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable interrupt on ENDKSGEN event." ]
            # [ inline ( always ) ]
            pub fn endksgen(&self) -> EndksgenR {
                EndksgenR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Disable interrupt on ENDCRYPT event." ]
            # [ inline ( always ) ]
            pub fn endcrypt(&self) -> EndcryptR {
                EndcryptR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Disable interrupt on ERROR event." ]
            # [ inline ( always ) ]
            pub fn error(&self) -> ErrorR {
                ErrorR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable interrupt on ENDKSGEN event." ]
            # [ inline ( always ) ]
            pub fn endksgen(&mut self) -> _EndksgenW {
                _EndksgenW { w: self }
            }
            # [ doc = "Bit 1 - Disable interrupt on ENDCRYPT event." ]
            # [ inline ( always ) ]
            pub fn endcrypt(&mut self) -> _EndcryptW {
                _EndcryptW { w: self }
            }
            # [ doc = "Bit 2 - Disable interrupt on ERROR event." ]
            # [ inline ( always ) ]
            pub fn error(&mut self) -> _ErrorW {
                _ErrorW { w: self }
            }
        }
    }
    # [ doc = "CCM RX MIC check result." ]
    pub struct Micstatus {
        register: VolatileCell<u32>,
    }
    # [ doc = "CCM RX MIC check result." ]
    pub mod micstatus {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Micstatus {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = "Possible values of the field `MICSTATUS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum MicstatusR {
            # [ doc = "MIC check failed." ]
            CheckFailed,
            # [ doc = "MIC check passed." ]
            CheckPassed,
        }
        impl MicstatusR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    MicstatusR::CheckFailed => 0,
                    MicstatusR::CheckPassed => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> MicstatusR {
                match bits {
                    0 => MicstatusR::CheckFailed,
                    1 => MicstatusR::CheckPassed,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `CheckFailed`" ]
            # [ inline ( always ) ]
            pub fn is_check_failed(&self) -> bool {
                *self == MicstatusR::CheckFailed
            }
            # [ doc = "Checks if the value of the field is `CheckPassed`" ]
            # [ inline ( always ) ]
            pub fn is_check_passed(&self) -> bool {
                *self == MicstatusR::CheckPassed
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Result of the MIC check performed during the previous CCM RX STARTCRYPT" ]
            # [ inline ( always ) ]
            pub fn micstatus(&self) -> MicstatusR {
                MicstatusR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
    }
    # [ doc = "CCM enable." ]
    pub struct Enable {
        register: VolatileCell<u32>,
    }
    # [ doc = "CCM enable." ]
    pub mod enable {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Enable {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ENABLE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EnableR {
            # [ doc = "CCM is disabled." ]
            Disabled,
            # [ doc = "CCM is enabled." ]
            Enabled,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl EnableR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EnableR::Disabled => 0,
                    EnableR::Enabled => 2,
                    EnableR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EnableR {
                match bits {
                    0 => EnableR::Disabled,
                    2 => EnableR::Enabled,
                    i => EnableR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EnableR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EnableR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `ENABLE`" ]
        pub enum EnableW {
            # [ doc = "CCM is disabled." ]
            Disabled,
            # [ doc = "CCM is enabled." ]
            Enabled,
        }
        impl EnableW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EnableW::Disabled => 0,
                    EnableW::Enabled => 2,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnableW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnableW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EnableW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "CCM is disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EnableW::Disabled)
            }
            # [ doc = "CCM is enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EnableW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - CCM enable." ]
            # [ inline ( always ) ]
            pub fn enable(&self) -> EnableR {
                EnableR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - CCM enable." ]
            # [ inline ( always ) ]
            pub fn enable(&mut self) -> _EnableW {
                _EnableW { w: self }
            }
        }
    }
    # [ doc = "Operation mode." ]
    pub struct Mode {
        register: VolatileCell<u32>,
    }
    # [ doc = "Operation mode." ]
    pub mod mode {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Mode {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `MODE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ModeR {
            # [ doc = "CCM mode TX" ]
            Encryption,
            # [ doc = "CCM mode TX" ]
            Decryption,
        }
        impl ModeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ModeR::Encryption => 0,
                    ModeR::Decryption => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ModeR {
                match bits {
                    0 => ModeR::Encryption,
                    1 => ModeR::Decryption,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Encryption`" ]
            # [ inline ( always ) ]
            pub fn is_encryption(&self) -> bool {
                *self == ModeR::Encryption
            }
            # [ doc = "Checks if the value of the field is `Decryption`" ]
            # [ inline ( always ) ]
            pub fn is_decryption(&self) -> bool {
                *self == ModeR::Decryption
            }
        }
        # [ doc = "Values that can be written to the field `MODE`" ]
        pub enum ModeW {
            # [ doc = "CCM mode TX" ]
            Encryption,
            # [ doc = "CCM mode TX" ]
            Decryption,
        }
        impl ModeW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ModeW::Encryption => 0,
                    ModeW::Decryption => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ModeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ModeW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ModeW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "CCM mode TX" ]
            # [ inline ( always ) ]
            pub fn encryption(self) -> &'a mut W {
                self.variant(ModeW::Encryption)
            }
            # [ doc = "CCM mode TX" ]
            # [ inline ( always ) ]
            pub fn decryption(self) -> &'a mut W {
                self.variant(ModeW::Decryption)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - CCM mode operation." ]
            # [ inline ( always ) ]
            pub fn mode(&self) -> ModeR {
                ModeR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 1 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - CCM mode operation." ]
            # [ inline ( always ) ]
            pub fn mode(&mut self) -> _ModeW {
                _ModeW { w: self }
            }
        }
    }
    # [ doc = "Pointer to a data structure holding AES key and NONCE vector." ]
    pub struct Cnfptr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pointer to a data structure holding AES key and NONCE vector." ]
    pub mod cnfptr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cnfptr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pointer to the input packet." ]
    pub struct Inptr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pointer to the input packet." ]
    pub mod inptr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Inptr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pointer to the output packet." ]
    pub struct Outptr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pointer to the output packet." ]
    pub mod outptr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Outptr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pointer to a \"scratch\" data area used for temporary storage during resolution. A minimum of 43 bytes must be reserved." ]
    pub struct Scratchptr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pointer to a \"scratch\" data area used for temporary storage during resolution. A minimum of 43 bytes must be reserved." ]
    pub mod scratchptr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Scratchptr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "AES CCM Mode Encryption." ]
pub struct Ccm {
    register_block: ccm::RegisterBlock,
}
impl Deref for Ccm {
    type Target = ccm::RegisterBlock;
    fn deref(&self) -> &ccm::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Watchdog Timer." ]
pub const WDT: Peripheral<Wdt> = unsafe { Peripheral::new(1073807360) };
# [ doc = "Watchdog Timer." ]
pub mod wdt {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Start the watchdog." ]
        pub tasks_start: TasksStart,
        _reserved0: [u8; 252usize],
        # [ doc = "0x100 - Watchdog timeout." ]
        pub events_timeout: EventsTimeout,
        _reserved1: [u8; 512usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved2: [u8; 244usize],
        # [ doc = "0x400 - Watchdog running status." ]
        pub runstatus: Runstatus,
        # [ doc = "0x404 - Request status." ]
        pub reqstatus: Reqstatus,
        _reserved3: [u8; 252usize],
        # [ doc = "0x504 - Counter reload value in number of 32kiHz clock cycles." ]
        pub crv: Crv,
        # [ doc = "0x508 - Reload request enable." ]
        pub rren: Rren,
        # [ doc = "0x50c - Configuration register." ]
        pub config: Config,
        _reserved4: [u8; 240usize],
        # [ doc = "0x600 - Reload requests registers." ]
        pub rr0: Rr,
        # [ doc = "0x604 - Reload requests registers." ]
        pub rr1: Rr,
        # [ doc = "0x608 - Reload requests registers." ]
        pub rr2: Rr,
        # [ doc = "0x60c - Reload requests registers." ]
        pub rr3: Rr,
        # [ doc = "0x610 - Reload requests registers." ]
        pub rr4: Rr,
        # [ doc = "0x614 - Reload requests registers." ]
        pub rr5: Rr,
        # [ doc = "0x618 - Reload requests registers." ]
        pub rr6: Rr,
        # [ doc = "0x61c - Reload requests registers." ]
        pub rr7: Rr,
        _reserved5: [u8; 2524usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Start the watchdog." ]
    pub struct TasksStart {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start the watchdog." ]
    pub mod tasks_start {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStart {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Watchdog timeout." ]
    pub struct EventsTimeout {
        register: VolatileCell<u32>,
    }
    # [ doc = "Watchdog timeout." ]
    pub mod events_timeout {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsTimeout {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `TIMEOUT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TimeoutR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl TimeoutR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TimeoutR::Disabled => 0,
                    TimeoutR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TimeoutR {
                match bits {
                    0 => TimeoutR::Disabled,
                    1 => TimeoutR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == TimeoutR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == TimeoutR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `TIMEOUT`" ]
        pub enum TimeoutW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl TimeoutW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TimeoutW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TimeoutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TimeoutW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TimeoutW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(TimeoutW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable interrupt on TIMEOUT event." ]
            # [ inline ( always ) ]
            pub fn timeout(&self) -> TimeoutR {
                TimeoutR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable interrupt on TIMEOUT event." ]
            # [ inline ( always ) ]
            pub fn timeout(&mut self) -> _TimeoutW {
                _TimeoutW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `TIMEOUT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TimeoutR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl TimeoutR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TimeoutR::Disabled => 0,
                    TimeoutR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TimeoutR {
                match bits {
                    0 => TimeoutR::Disabled,
                    1 => TimeoutR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == TimeoutR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == TimeoutR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `TIMEOUT`" ]
        pub enum TimeoutW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl TimeoutW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TimeoutW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TimeoutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TimeoutW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TimeoutW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(TimeoutW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable interrupt on TIMEOUT event." ]
            # [ inline ( always ) ]
            pub fn timeout(&self) -> TimeoutR {
                TimeoutR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable interrupt on TIMEOUT event." ]
            # [ inline ( always ) ]
            pub fn timeout(&mut self) -> _TimeoutW {
                _TimeoutW { w: self }
            }
        }
    }
    # [ doc = "Watchdog running status." ]
    pub struct Runstatus {
        register: VolatileCell<u32>,
    }
    # [ doc = "Watchdog running status." ]
    pub mod runstatus {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Runstatus {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = "Possible values of the field `RUNSTATUS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RunstatusR {
            # [ doc = "Watchdog timer is not running." ]
            NotRunning,
            # [ doc = "Watchdog timer is running." ]
            Running,
        }
        impl RunstatusR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RunstatusR::NotRunning => 0,
                    RunstatusR::Running => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RunstatusR {
                match bits {
                    0 => RunstatusR::NotRunning,
                    1 => RunstatusR::Running,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NotRunning`" ]
            # [ inline ( always ) ]
            pub fn is_not_running(&self) -> bool {
                *self == RunstatusR::NotRunning
            }
            # [ doc = "Checks if the value of the field is `Running`" ]
            # [ inline ( always ) ]
            pub fn is_running(&self) -> bool {
                *self == RunstatusR::Running
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Watchdog running status." ]
            # [ inline ( always ) ]
            pub fn runstatus(&self) -> RunstatusR {
                RunstatusR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
    }
    # [ doc = "Request status." ]
    pub struct Reqstatus {
        register: VolatileCell<u32>,
    }
    # [ doc = "Request status." ]
    pub mod reqstatus {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Reqstatus {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = "Possible values of the field `RR0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rr0R {
            # [ doc = "RR[0] register is not enabled or has already requested reload." ]
            DisabledOrRequested,
            # [ doc = "RR[0] register is enabled and has not jet requested." ]
            EnabledAndUnrequested,
        }
        impl Rr0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rr0R::DisabledOrRequested => 0,
                    Rr0R::EnabledAndUnrequested => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rr0R {
                match bits {
                    0 => Rr0R::DisabledOrRequested,
                    1 => Rr0R::EnabledAndUnrequested,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `DisabledOrRequested`" ]
            # [ inline ( always ) ]
            pub fn is_disabled_or_requested(&self) -> bool {
                *self == Rr0R::DisabledOrRequested
            }
            # [ doc = "Checks if the value of the field is `EnabledAndUnrequested`" ]
            # [ inline ( always ) ]
            pub fn is_enabled_and_unrequested(&self) -> bool {
                *self == Rr0R::EnabledAndUnrequested
            }
        }
        # [ doc = "Possible values of the field `RR1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rr1R {
            # [ doc = "RR[1] register is not enabled or has already requested reload." ]
            DisabledOrRequested,
            # [ doc = "RR[1] register is enabled and has not jet requested." ]
            EnabledAndUnrequested,
        }
        impl Rr1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rr1R::DisabledOrRequested => 0,
                    Rr1R::EnabledAndUnrequested => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rr1R {
                match bits {
                    0 => Rr1R::DisabledOrRequested,
                    1 => Rr1R::EnabledAndUnrequested,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `DisabledOrRequested`" ]
            # [ inline ( always ) ]
            pub fn is_disabled_or_requested(&self) -> bool {
                *self == Rr1R::DisabledOrRequested
            }
            # [ doc = "Checks if the value of the field is `EnabledAndUnrequested`" ]
            # [ inline ( always ) ]
            pub fn is_enabled_and_unrequested(&self) -> bool {
                *self == Rr1R::EnabledAndUnrequested
            }
        }
        # [ doc = "Possible values of the field `RR2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rr2R {
            # [ doc = "RR[2] register is not enabled or has already requested reload." ]
            DisabledOrRequested,
            # [ doc = "RR[2] register is enabled and has not jet requested." ]
            EnabledAndUnrequested,
        }
        impl Rr2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rr2R::DisabledOrRequested => 0,
                    Rr2R::EnabledAndUnrequested => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rr2R {
                match bits {
                    0 => Rr2R::DisabledOrRequested,
                    1 => Rr2R::EnabledAndUnrequested,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `DisabledOrRequested`" ]
            # [ inline ( always ) ]
            pub fn is_disabled_or_requested(&self) -> bool {
                *self == Rr2R::DisabledOrRequested
            }
            # [ doc = "Checks if the value of the field is `EnabledAndUnrequested`" ]
            # [ inline ( always ) ]
            pub fn is_enabled_and_unrequested(&self) -> bool {
                *self == Rr2R::EnabledAndUnrequested
            }
        }
        # [ doc = "Possible values of the field `RR3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rr3R {
            # [ doc = "RR[3] register is not enabled or has already requested reload." ]
            DisabledOrRequested,
            # [ doc = "RR[3] register is enabled and has not jet requested." ]
            EnabledAndUnrequested,
        }
        impl Rr3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rr3R::DisabledOrRequested => 0,
                    Rr3R::EnabledAndUnrequested => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rr3R {
                match bits {
                    0 => Rr3R::DisabledOrRequested,
                    1 => Rr3R::EnabledAndUnrequested,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `DisabledOrRequested`" ]
            # [ inline ( always ) ]
            pub fn is_disabled_or_requested(&self) -> bool {
                *self == Rr3R::DisabledOrRequested
            }
            # [ doc = "Checks if the value of the field is `EnabledAndUnrequested`" ]
            # [ inline ( always ) ]
            pub fn is_enabled_and_unrequested(&self) -> bool {
                *self == Rr3R::EnabledAndUnrequested
            }
        }
        # [ doc = "Possible values of the field `RR4`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rr4R {
            # [ doc = "RR[4] register is not enabled or has already requested reload." ]
            DisabledOrRequested,
            # [ doc = "RR[4] register is enabled and has not jet requested." ]
            EnabledAndUnrequested,
        }
        impl Rr4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rr4R::DisabledOrRequested => 0,
                    Rr4R::EnabledAndUnrequested => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rr4R {
                match bits {
                    0 => Rr4R::DisabledOrRequested,
                    1 => Rr4R::EnabledAndUnrequested,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `DisabledOrRequested`" ]
            # [ inline ( always ) ]
            pub fn is_disabled_or_requested(&self) -> bool {
                *self == Rr4R::DisabledOrRequested
            }
            # [ doc = "Checks if the value of the field is `EnabledAndUnrequested`" ]
            # [ inline ( always ) ]
            pub fn is_enabled_and_unrequested(&self) -> bool {
                *self == Rr4R::EnabledAndUnrequested
            }
        }
        # [ doc = "Possible values of the field `RR5`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rr5R {
            # [ doc = "RR[5] register is not enabled or has already requested reload." ]
            DisabledOrRequested,
            # [ doc = "RR[5] register is enabled and has not jet requested." ]
            EnabledAndUnrequested,
        }
        impl Rr5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rr5R::DisabledOrRequested => 0,
                    Rr5R::EnabledAndUnrequested => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rr5R {
                match bits {
                    0 => Rr5R::DisabledOrRequested,
                    1 => Rr5R::EnabledAndUnrequested,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `DisabledOrRequested`" ]
            # [ inline ( always ) ]
            pub fn is_disabled_or_requested(&self) -> bool {
                *self == Rr5R::DisabledOrRequested
            }
            # [ doc = "Checks if the value of the field is `EnabledAndUnrequested`" ]
            # [ inline ( always ) ]
            pub fn is_enabled_and_unrequested(&self) -> bool {
                *self == Rr5R::EnabledAndUnrequested
            }
        }
        # [ doc = "Possible values of the field `RR6`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rr6R {
            # [ doc = "RR[6] register is not enabled or has already requested reload." ]
            DisabledOrRequested,
            # [ doc = "RR[6] register is enabled and has not jet requested." ]
            EnabledAndUnrequested,
        }
        impl Rr6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rr6R::DisabledOrRequested => 0,
                    Rr6R::EnabledAndUnrequested => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rr6R {
                match bits {
                    0 => Rr6R::DisabledOrRequested,
                    1 => Rr6R::EnabledAndUnrequested,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `DisabledOrRequested`" ]
            # [ inline ( always ) ]
            pub fn is_disabled_or_requested(&self) -> bool {
                *self == Rr6R::DisabledOrRequested
            }
            # [ doc = "Checks if the value of the field is `EnabledAndUnrequested`" ]
            # [ inline ( always ) ]
            pub fn is_enabled_and_unrequested(&self) -> bool {
                *self == Rr6R::EnabledAndUnrequested
            }
        }
        # [ doc = "Possible values of the field `RR7`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rr7R {
            # [ doc = "RR[7] register is not enabled or has already requested reload." ]
            DisabledOrRequested,
            # [ doc = "RR[7] register is enabled and has not jet requested." ]
            EnabledAndUnrequested,
        }
        impl Rr7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rr7R::DisabledOrRequested => 0,
                    Rr7R::EnabledAndUnrequested => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rr7R {
                match bits {
                    0 => Rr7R::DisabledOrRequested,
                    1 => Rr7R::EnabledAndUnrequested,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `DisabledOrRequested`" ]
            # [ inline ( always ) ]
            pub fn is_disabled_or_requested(&self) -> bool {
                *self == Rr7R::DisabledOrRequested
            }
            # [ doc = "Checks if the value of the field is `EnabledAndUnrequested`" ]
            # [ inline ( always ) ]
            pub fn is_enabled_and_unrequested(&self) -> bool {
                *self == Rr7R::EnabledAndUnrequested
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Request status for RR[0]." ]
            # [ inline ( always ) ]
            pub fn rr0(&self) -> Rr0R {
                Rr0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Request status for RR[1]." ]
            # [ inline ( always ) ]
            pub fn rr1(&self) -> Rr1R {
                Rr1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Request status for RR[2]." ]
            # [ inline ( always ) ]
            pub fn rr2(&self) -> Rr2R {
                Rr2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Request status for RR[3]." ]
            # [ inline ( always ) ]
            pub fn rr3(&self) -> Rr3R {
                Rr3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Request status for RR[4]." ]
            # [ inline ( always ) ]
            pub fn rr4(&self) -> Rr4R {
                Rr4R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Request status for RR[5]." ]
            # [ inline ( always ) ]
            pub fn rr5(&self) -> Rr5R {
                Rr5R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Request status for RR[6]." ]
            # [ inline ( always ) ]
            pub fn rr6(&self) -> Rr6R {
                Rr6R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Request status for RR[7]." ]
            # [ inline ( always ) ]
            pub fn rr7(&self) -> Rr7R {
                Rr7R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
    }
    # [ doc = "Counter reload value in number of 32kiHz clock cycles." ]
    pub struct Crv {
        register: VolatileCell<u32>,
    }
    # [ doc = "Counter reload value in number of 32kiHz clock cycles." ]
    pub mod crv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Crv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Reload request enable." ]
    pub struct Rren {
        register: VolatileCell<u32>,
    }
    # [ doc = "Reload request enable." ]
    pub mod rren {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Rren {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `RR0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rr0R {
            # [ doc = "RR[0] register is disabled." ]
            Disabled,
            # [ doc = "RR[0] register is enabled." ]
            Enabled,
        }
        impl Rr0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rr0R::Disabled => 0,
                    Rr0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rr0R {
                match bits {
                    0 => Rr0R::Disabled,
                    1 => Rr0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Rr0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Rr0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `RR1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rr1R {
            # [ doc = "RR[1] register is disabled." ]
            Disabled,
            # [ doc = "RR[1] register is enabled." ]
            Enabled,
        }
        impl Rr1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rr1R::Disabled => 0,
                    Rr1R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rr1R {
                match bits {
                    0 => Rr1R::Disabled,
                    1 => Rr1R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Rr1R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Rr1R::Enabled
            }
        }
        # [ doc = "Possible values of the field `RR2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rr2R {
            # [ doc = "RR[2] register is disabled." ]
            Disabled,
            # [ doc = "RR[2] register is enabled." ]
            Enabled,
        }
        impl Rr2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rr2R::Disabled => 0,
                    Rr2R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rr2R {
                match bits {
                    0 => Rr2R::Disabled,
                    1 => Rr2R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Rr2R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Rr2R::Enabled
            }
        }
        # [ doc = "Possible values of the field `RR3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rr3R {
            # [ doc = "RR[3] register is disabled." ]
            Disabled,
            # [ doc = "RR[3] register is enabled." ]
            Enabled,
        }
        impl Rr3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rr3R::Disabled => 0,
                    Rr3R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rr3R {
                match bits {
                    0 => Rr3R::Disabled,
                    1 => Rr3R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Rr3R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Rr3R::Enabled
            }
        }
        # [ doc = "Possible values of the field `RR4`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rr4R {
            # [ doc = "RR[4] register is disabled." ]
            Disabled,
            # [ doc = "RR[4] register is enabled." ]
            Enabled,
        }
        impl Rr4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rr4R::Disabled => 0,
                    Rr4R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rr4R {
                match bits {
                    0 => Rr4R::Disabled,
                    1 => Rr4R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Rr4R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Rr4R::Enabled
            }
        }
        # [ doc = "Possible values of the field `RR5`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rr5R {
            # [ doc = "RR[5] register is disabled." ]
            Disabled,
            # [ doc = "RR[5] register is enabled." ]
            Enabled,
        }
        impl Rr5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rr5R::Disabled => 0,
                    Rr5R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rr5R {
                match bits {
                    0 => Rr5R::Disabled,
                    1 => Rr5R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Rr5R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Rr5R::Enabled
            }
        }
        # [ doc = "Possible values of the field `RR6`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rr6R {
            # [ doc = "RR[6] register is disabled." ]
            Disabled,
            # [ doc = "RR[6] register is enabled." ]
            Enabled,
        }
        impl Rr6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rr6R::Disabled => 0,
                    Rr6R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rr6R {
                match bits {
                    0 => Rr6R::Disabled,
                    1 => Rr6R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Rr6R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Rr6R::Enabled
            }
        }
        # [ doc = "Possible values of the field `RR7`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rr7R {
            # [ doc = "RR[7] register is disabled." ]
            Disabled,
            # [ doc = "RR[7] register is enabled." ]
            Enabled,
        }
        impl Rr7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rr7R::Disabled => 0,
                    Rr7R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rr7R {
                match bits {
                    0 => Rr7R::Disabled,
                    1 => Rr7R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Rr7R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Rr7R::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `RR0`" ]
        pub enum Rr0W {
            # [ doc = "RR[0] register is disabled." ]
            Disabled,
            # [ doc = "RR[0] register is enabled." ]
            Enabled,
        }
        impl Rr0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Rr0W::Disabled => 0,
                    Rr0W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rr0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Rr0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RR[0] register is disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Rr0W::Disabled)
            }
            # [ doc = "RR[0] register is enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Rr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RR1`" ]
        pub enum Rr1W {
            # [ doc = "RR[1] register is disabled." ]
            Disabled,
            # [ doc = "RR[1] register is enabled." ]
            Enabled,
        }
        impl Rr1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Rr1W::Disabled => 0,
                    Rr1W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rr1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Rr1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RR[1] register is disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Rr1W::Disabled)
            }
            # [ doc = "RR[1] register is enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Rr1W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RR2`" ]
        pub enum Rr2W {
            # [ doc = "RR[2] register is disabled." ]
            Disabled,
            # [ doc = "RR[2] register is enabled." ]
            Enabled,
        }
        impl Rr2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Rr2W::Disabled => 0,
                    Rr2W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rr2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Rr2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RR[2] register is disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Rr2W::Disabled)
            }
            # [ doc = "RR[2] register is enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Rr2W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RR3`" ]
        pub enum Rr3W {
            # [ doc = "RR[3] register is disabled." ]
            Disabled,
            # [ doc = "RR[3] register is enabled." ]
            Enabled,
        }
        impl Rr3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Rr3W::Disabled => 0,
                    Rr3W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rr3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Rr3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RR[3] register is disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Rr3W::Disabled)
            }
            # [ doc = "RR[3] register is enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Rr3W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RR4`" ]
        pub enum Rr4W {
            # [ doc = "RR[4] register is disabled." ]
            Disabled,
            # [ doc = "RR[4] register is enabled." ]
            Enabled,
        }
        impl Rr4W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Rr4W::Disabled => 0,
                    Rr4W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rr4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Rr4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RR[4] register is disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Rr4W::Disabled)
            }
            # [ doc = "RR[4] register is enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Rr4W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RR5`" ]
        pub enum Rr5W {
            # [ doc = "RR[5] register is disabled." ]
            Disabled,
            # [ doc = "RR[5] register is enabled." ]
            Enabled,
        }
        impl Rr5W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Rr5W::Disabled => 0,
                    Rr5W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rr5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Rr5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RR[5] register is disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Rr5W::Disabled)
            }
            # [ doc = "RR[5] register is enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Rr5W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RR6`" ]
        pub enum Rr6W {
            # [ doc = "RR[6] register is disabled." ]
            Disabled,
            # [ doc = "RR[6] register is enabled." ]
            Enabled,
        }
        impl Rr6W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Rr6W::Disabled => 0,
                    Rr6W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rr6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Rr6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RR[6] register is disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Rr6W::Disabled)
            }
            # [ doc = "RR[6] register is enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Rr6W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RR7`" ]
        pub enum Rr7W {
            # [ doc = "RR[7] register is disabled." ]
            Disabled,
            # [ doc = "RR[7] register is enabled." ]
            Enabled,
        }
        impl Rr7W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Rr7W::Disabled => 0,
                    Rr7W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rr7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Rr7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RR[7] register is disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Rr7W::Disabled)
            }
            # [ doc = "RR[7] register is enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Rr7W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable or disable RR[0] register." ]
            # [ inline ( always ) ]
            pub fn rr0(&self) -> Rr0R {
                Rr0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Enable or disable RR[1] register." ]
            # [ inline ( always ) ]
            pub fn rr1(&self) -> Rr1R {
                Rr1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Enable or disable RR[2] register." ]
            # [ inline ( always ) ]
            pub fn rr2(&self) -> Rr2R {
                Rr2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Enable or disable RR[3] register." ]
            # [ inline ( always ) ]
            pub fn rr3(&self) -> Rr3R {
                Rr3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Enable or disable RR[4] register." ]
            # [ inline ( always ) ]
            pub fn rr4(&self) -> Rr4R {
                Rr4R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Enable or disable RR[5] register." ]
            # [ inline ( always ) ]
            pub fn rr5(&self) -> Rr5R {
                Rr5R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Enable or disable RR[6] register." ]
            # [ inline ( always ) ]
            pub fn rr6(&self) -> Rr6R {
                Rr6R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Enable or disable RR[7] register." ]
            # [ inline ( always ) ]
            pub fn rr7(&self) -> Rr7R {
                Rr7R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 1 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable or disable RR[0] register." ]
            # [ inline ( always ) ]
            pub fn rr0(&mut self) -> _Rr0W {
                _Rr0W { w: self }
            }
            # [ doc = "Bit 1 - Enable or disable RR[1] register." ]
            # [ inline ( always ) ]
            pub fn rr1(&mut self) -> _Rr1W {
                _Rr1W { w: self }
            }
            # [ doc = "Bit 2 - Enable or disable RR[2] register." ]
            # [ inline ( always ) ]
            pub fn rr2(&mut self) -> _Rr2W {
                _Rr2W { w: self }
            }
            # [ doc = "Bit 3 - Enable or disable RR[3] register." ]
            # [ inline ( always ) ]
            pub fn rr3(&mut self) -> _Rr3W {
                _Rr3W { w: self }
            }
            # [ doc = "Bit 4 - Enable or disable RR[4] register." ]
            # [ inline ( always ) ]
            pub fn rr4(&mut self) -> _Rr4W {
                _Rr4W { w: self }
            }
            # [ doc = "Bit 5 - Enable or disable RR[5] register." ]
            # [ inline ( always ) ]
            pub fn rr5(&mut self) -> _Rr5W {
                _Rr5W { w: self }
            }
            # [ doc = "Bit 6 - Enable or disable RR[6] register." ]
            # [ inline ( always ) ]
            pub fn rr6(&mut self) -> _Rr6W {
                _Rr6W { w: self }
            }
            # [ doc = "Bit 7 - Enable or disable RR[7] register." ]
            # [ inline ( always ) ]
            pub fn rr7(&mut self) -> _Rr7W {
                _Rr7W { w: self }
            }
        }
    }
    # [ doc = "Configuration register." ]
    pub struct Config {
        register: VolatileCell<u32>,
    }
    # [ doc = "Configuration register." ]
    pub mod config {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Config {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `SLEEP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SleepR {
            # [ doc = "Pause watchdog while the CPU is asleep." ]
            Pause,
            # [ doc = "Do not pause watchdog while the CPU is asleep." ]
            Run,
        }
        impl SleepR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SleepR::Pause => 0,
                    SleepR::Run => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SleepR {
                match bits {
                    0 => SleepR::Pause,
                    1 => SleepR::Run,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Pause`" ]
            # [ inline ( always ) ]
            pub fn is_pause(&self) -> bool {
                *self == SleepR::Pause
            }
            # [ doc = "Checks if the value of the field is `Run`" ]
            # [ inline ( always ) ]
            pub fn is_run(&self) -> bool {
                *self == SleepR::Run
            }
        }
        # [ doc = "Possible values of the field `HALT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum HaltR {
            # [ doc = "Pause watchdog while the CPU is halted by the debugger." ]
            Pause,
            # [ doc = "Do not pause watchdog while the CPU is halted by the debugger." ]
            Run,
        }
        impl HaltR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    HaltR::Pause => 0,
                    HaltR::Run => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> HaltR {
                match bits {
                    0 => HaltR::Pause,
                    1 => HaltR::Run,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Pause`" ]
            # [ inline ( always ) ]
            pub fn is_pause(&self) -> bool {
                *self == HaltR::Pause
            }
            # [ doc = "Checks if the value of the field is `Run`" ]
            # [ inline ( always ) ]
            pub fn is_run(&self) -> bool {
                *self == HaltR::Run
            }
        }
        # [ doc = "Values that can be written to the field `SLEEP`" ]
        pub enum SleepW {
            # [ doc = "Pause watchdog while the CPU is asleep." ]
            Pause,
            # [ doc = "Do not pause watchdog while the CPU is asleep." ]
            Run,
        }
        impl SleepW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SleepW::Pause => 0,
                    SleepW::Run => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SleepW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SleepW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SleepW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pause watchdog while the CPU is asleep." ]
            # [ inline ( always ) ]
            pub fn pause(self) -> &'a mut W {
                self.variant(SleepW::Pause)
            }
            # [ doc = "Do not pause watchdog while the CPU is asleep." ]
            # [ inline ( always ) ]
            pub fn run(self) -> &'a mut W {
                self.variant(SleepW::Run)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `HALT`" ]
        pub enum HaltW {
            # [ doc = "Pause watchdog while the CPU is halted by the debugger." ]
            Pause,
            # [ doc = "Do not pause watchdog while the CPU is halted by the debugger." ]
            Run,
        }
        impl HaltW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    HaltW::Pause => 0,
                    HaltW::Run => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HaltW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HaltW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: HaltW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pause watchdog while the CPU is halted by the debugger." ]
            # [ inline ( always ) ]
            pub fn pause(self) -> &'a mut W {
                self.variant(HaltW::Pause)
            }
            # [ doc = "Do not pause watchdog while the CPU is halted by the debugger." ]
            # [ inline ( always ) ]
            pub fn run(self) -> &'a mut W {
                self.variant(HaltW::Run)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Configure the watchdog to pause or not while the CPU is sleeping." ]
            # [ inline ( always ) ]
            pub fn sleep(&self) -> SleepR {
                SleepR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Configure the watchdog to pause or not while the CPU is halted by the debugger." ]
            # [ inline ( always ) ]
            pub fn halt(&self) -> HaltR {
                HaltR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 1 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Configure the watchdog to pause or not while the CPU is sleeping." ]
            # [ inline ( always ) ]
            pub fn sleep(&mut self) -> _SleepW {
                _SleepW { w: self }
            }
            # [ doc = "Bit 3 - Configure the watchdog to pause or not while the CPU is halted by the debugger." ]
            # [ inline ( always ) ]
            pub fn halt(&mut self) -> _HaltW {
                _HaltW { w: self }
            }
        }
    }
    # [ doc = "Reload requests registers." ]
    pub struct Rr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Reload requests registers." ]
    pub mod rr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Rr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Values that can be written to the field `RR`" ]
        pub enum RrW {
            # [ doc = "Value to request a reload of the watchdog timer." ]
            Reload,
        }
        impl RrW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u32 {
                match *self {
                    RrW::Reload => 1850885685,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RrW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RrW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Value to request a reload of the watchdog timer." ]
            # [ inline ( always ) ]
            pub fn reload(self) -> &'a mut W {
                self.variant(RrW::Reload)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Reload register." ]
            # [ inline ( always ) ]
            pub fn rr(&mut self) -> _RrW {
                _RrW { w: self }
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "Watchdog Timer." ]
pub struct Wdt {
    register_block: wdt::RegisterBlock,
}
impl Deref for Wdt {
    type Target = wdt::RegisterBlock;
    fn deref(&self) -> &wdt::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Real time counter 1." ]
pub const RTC1: Peripheral<Rtc1> = unsafe { Peripheral::new(1073811456) };
# [ doc = r" Register block" ]
pub struct Rtc1 {
    register_block: rtc0::RegisterBlock,
}
impl Deref for Rtc1 {
    type Target = rtc0::RegisterBlock;
    fn deref(&self) -> &rtc0::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Rotary decoder." ]
pub const QDEC: Peripheral<Qdec> = unsafe { Peripheral::new(1073815552) };
# [ doc = "Rotary decoder." ]
pub mod qdec {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Start the quadrature decoder." ]
        pub tasks_start: TasksStart,
        # [ doc = "0x04 - Stop the quadrature decoder." ]
        pub tasks_stop: TasksStop,
        # [ doc = "0x08 - Transfers the content from ACC registers to ACCREAD registers, and clears the ACC registers." ]
        pub tasks_readclracc: TasksReadclracc,
        _reserved0: [u8; 244usize],
        # [ doc = "0x100 - A new sample is written to the sample register." ]
        pub events_samplerdy: EventsSamplerdy,
        # [ doc = "0x104 - REPORTPER number of samples accumulated in ACC register, and ACC register different than zero." ]
        pub events_reportrdy: EventsReportrdy,
        # [ doc = "0x108 - ACC or ACCDBL register overflow." ]
        pub events_accof: EventsAccof,
        _reserved1: [u8; 244usize],
        # [ doc = "0x200 - Shortcuts for the QDEC." ]
        pub shorts: Shorts,
        _reserved2: [u8; 256usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved3: [u8; 500usize],
        # [ doc = "0x500 - Enable the QDEC." ]
        pub enable: Enable,
        # [ doc = "0x504 - LED output pin polarity." ]
        pub ledpol: Ledpol,
        # [ doc = "0x508 - Sample period." ]
        pub sampleper: Sampleper,
        # [ doc = "0x50c - Motion sample value." ]
        pub sample: Sample,
        # [ doc = "0x510 - Number of samples to generate an EVENT_REPORTRDY." ]
        pub reportper: Reportper,
        # [ doc = "0x514 - Accumulated valid transitions register." ]
        pub acc: Acc,
        # [ doc = "0x518 - Snapshot of ACC register. Value generated by the TASKS_READCLEACC task." ]
        pub accread: Accread,
        # [ doc = "0x51c - Pin select for LED output." ]
        pub pselled: Pselled,
        # [ doc = "0x520 - Pin select for phase A input." ]
        pub psela: Psela,
        # [ doc = "0x524 - Pin select for phase B input." ]
        pub pselb: Pselb,
        # [ doc = "0x528 - Enable debouncer input filters." ]
        pub dbfen: Dbfen,
        _reserved4: [u8; 20usize],
        # [ doc = "0x540 - Time LED is switched ON before the sample." ]
        pub ledpre: Ledpre,
        # [ doc = "0x544 - Accumulated double (error) transitions register." ]
        pub accdbl: Accdbl,
        # [ doc = "0x548 - Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC task." ]
        pub accdblread: Accdblread,
        _reserved5: [u8; 2736usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Start the quadrature decoder." ]
    pub struct TasksStart {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start the quadrature decoder." ]
    pub mod tasks_start {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStart {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop the quadrature decoder." ]
    pub struct TasksStop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop the quadrature decoder." ]
    pub mod tasks_stop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Transfers the content from ACC registers to ACCREAD registers, and clears the ACC registers." ]
    pub struct TasksReadclracc {
        register: VolatileCell<u32>,
    }
    # [ doc = "Transfers the content from ACC registers to ACCREAD registers, and clears the ACC registers." ]
    pub mod tasks_readclracc {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksReadclracc {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "A new sample is written to the sample register." ]
    pub struct EventsSamplerdy {
        register: VolatileCell<u32>,
    }
    # [ doc = "A new sample is written to the sample register." ]
    pub mod events_samplerdy {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsSamplerdy {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "REPORTPER number of samples accumulated in ACC register, and ACC register different than zero." ]
    pub struct EventsReportrdy {
        register: VolatileCell<u32>,
    }
    # [ doc = "REPORTPER number of samples accumulated in ACC register, and ACC register different than zero." ]
    pub mod events_reportrdy {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsReportrdy {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "ACC or ACCDBL register overflow." ]
    pub struct EventsAccof {
        register: VolatileCell<u32>,
    }
    # [ doc = "ACC or ACCDBL register overflow." ]
    pub mod events_accof {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsAccof {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Shortcuts for the QDEC." ]
    pub struct Shorts {
        register: VolatileCell<u32>,
    }
    # [ doc = "Shortcuts for the QDEC." ]
    pub mod shorts {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Shorts {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `REPORTRDY_READCLRACC`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ReportrdyReadclraccR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl ReportrdyReadclraccR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ReportrdyReadclraccR::Disabled => 0,
                    ReportrdyReadclraccR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ReportrdyReadclraccR {
                match bits {
                    0 => ReportrdyReadclraccR::Disabled,
                    1 => ReportrdyReadclraccR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ReportrdyReadclraccR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ReportrdyReadclraccR::Enabled
            }
        }
        # [ doc = "Possible values of the field `SAMPLERDY_STOP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SamplerdyStopR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl SamplerdyStopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SamplerdyStopR::Disabled => 0,
                    SamplerdyStopR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SamplerdyStopR {
                match bits {
                    0 => SamplerdyStopR::Disabled,
                    1 => SamplerdyStopR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == SamplerdyStopR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == SamplerdyStopR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `REPORTRDY_READCLRACC`" ]
        pub enum ReportrdyReadclraccW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl ReportrdyReadclraccW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ReportrdyReadclraccW::Disabled => 0,
                    ReportrdyReadclraccW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReportrdyReadclraccW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReportrdyReadclraccW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ReportrdyReadclraccW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ReportrdyReadclraccW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ReportrdyReadclraccW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `SAMPLERDY_STOP`" ]
        pub enum SamplerdyStopW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl SamplerdyStopW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SamplerdyStopW::Disabled => 0,
                    SamplerdyStopW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SamplerdyStopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SamplerdyStopW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SamplerdyStopW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SamplerdyStopW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SamplerdyStopW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Shortcut between REPORTRDY event and READCLRACC task." ]
            # [ inline ( always ) ]
            pub fn reportrdy_readclracc(&self) -> ReportrdyReadclraccR {
                ReportrdyReadclraccR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Shortcut between SAMPLERDY event and STOP task." ]
            # [ inline ( always ) ]
            pub fn samplerdy_stop(&self) -> SamplerdyStopR {
                SamplerdyStopR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Shortcut between REPORTRDY event and READCLRACC task." ]
            # [ inline ( always ) ]
            pub fn reportrdy_readclracc(&mut self) -> _ReportrdyReadclraccW {
                _ReportrdyReadclraccW { w: self }
            }
            # [ doc = "Bit 1 - Shortcut between SAMPLERDY event and STOP task." ]
            # [ inline ( always ) ]
            pub fn samplerdy_stop(&mut self) -> _SamplerdyStopW {
                _SamplerdyStopW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `SAMPLERDY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SamplerdyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl SamplerdyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SamplerdyR::Disabled => 0,
                    SamplerdyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SamplerdyR {
                match bits {
                    0 => SamplerdyR::Disabled,
                    1 => SamplerdyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == SamplerdyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == SamplerdyR::Enabled
            }
        }
        # [ doc = "Possible values of the field `REPORTRDY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ReportrdyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ReportrdyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ReportrdyR::Disabled => 0,
                    ReportrdyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ReportrdyR {
                match bits {
                    0 => ReportrdyR::Disabled,
                    1 => ReportrdyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ReportrdyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ReportrdyR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ACCOF`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum AccofR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl AccofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    AccofR::Disabled => 0,
                    AccofR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> AccofR {
                match bits {
                    0 => AccofR::Disabled,
                    1 => AccofR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == AccofR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == AccofR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `SAMPLERDY`" ]
        pub enum SamplerdyW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl SamplerdyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SamplerdyW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SamplerdyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SamplerdyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SamplerdyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(SamplerdyW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `REPORTRDY`" ]
        pub enum ReportrdyW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl ReportrdyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ReportrdyW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReportrdyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReportrdyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ReportrdyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(ReportrdyW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ACCOF`" ]
        pub enum AccofW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl AccofW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AccofW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AccofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AccofW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: AccofW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(AccofW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable interrupt on SAMPLERDY event." ]
            # [ inline ( always ) ]
            pub fn samplerdy(&self) -> SamplerdyR {
                SamplerdyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Enable interrupt on REPORTRDY event." ]
            # [ inline ( always ) ]
            pub fn reportrdy(&self) -> ReportrdyR {
                ReportrdyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Enable interrupt on ACCOF event." ]
            # [ inline ( always ) ]
            pub fn accof(&self) -> AccofR {
                AccofR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable interrupt on SAMPLERDY event." ]
            # [ inline ( always ) ]
            pub fn samplerdy(&mut self) -> _SamplerdyW {
                _SamplerdyW { w: self }
            }
            # [ doc = "Bit 1 - Enable interrupt on REPORTRDY event." ]
            # [ inline ( always ) ]
            pub fn reportrdy(&mut self) -> _ReportrdyW {
                _ReportrdyW { w: self }
            }
            # [ doc = "Bit 2 - Enable interrupt on ACCOF event." ]
            # [ inline ( always ) ]
            pub fn accof(&mut self) -> _AccofW {
                _AccofW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `SAMPLERDY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SamplerdyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl SamplerdyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SamplerdyR::Disabled => 0,
                    SamplerdyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SamplerdyR {
                match bits {
                    0 => SamplerdyR::Disabled,
                    1 => SamplerdyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == SamplerdyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == SamplerdyR::Enabled
            }
        }
        # [ doc = "Possible values of the field `REPORTRDY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ReportrdyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ReportrdyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ReportrdyR::Disabled => 0,
                    ReportrdyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ReportrdyR {
                match bits {
                    0 => ReportrdyR::Disabled,
                    1 => ReportrdyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ReportrdyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ReportrdyR::Enabled
            }
        }
        # [ doc = "Possible values of the field `ACCOF`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum AccofR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl AccofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    AccofR::Disabled => 0,
                    AccofR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> AccofR {
                match bits {
                    0 => AccofR::Disabled,
                    1 => AccofR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == AccofR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == AccofR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `SAMPLERDY`" ]
        pub enum SamplerdyW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl SamplerdyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SamplerdyW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SamplerdyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SamplerdyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SamplerdyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(SamplerdyW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `REPORTRDY`" ]
        pub enum ReportrdyW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl ReportrdyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ReportrdyW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReportrdyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReportrdyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ReportrdyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(ReportrdyW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ACCOF`" ]
        pub enum AccofW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl AccofW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AccofW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AccofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AccofW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: AccofW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(AccofW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable interrupt on SAMPLERDY event." ]
            # [ inline ( always ) ]
            pub fn samplerdy(&self) -> SamplerdyR {
                SamplerdyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Disable interrupt on REPORTRDY event." ]
            # [ inline ( always ) ]
            pub fn reportrdy(&self) -> ReportrdyR {
                ReportrdyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Disable interrupt on ACCOF event." ]
            # [ inline ( always ) ]
            pub fn accof(&self) -> AccofR {
                AccofR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable interrupt on SAMPLERDY event." ]
            # [ inline ( always ) ]
            pub fn samplerdy(&mut self) -> _SamplerdyW {
                _SamplerdyW { w: self }
            }
            # [ doc = "Bit 1 - Disable interrupt on REPORTRDY event." ]
            # [ inline ( always ) ]
            pub fn reportrdy(&mut self) -> _ReportrdyW {
                _ReportrdyW { w: self }
            }
            # [ doc = "Bit 2 - Disable interrupt on ACCOF event." ]
            # [ inline ( always ) ]
            pub fn accof(&mut self) -> _AccofW {
                _AccofW { w: self }
            }
        }
    }
    # [ doc = "Enable the QDEC." ]
    pub struct Enable {
        register: VolatileCell<u32>,
    }
    # [ doc = "Enable the QDEC." ]
    pub mod enable {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Enable {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ENABLE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EnableR {
            # [ doc = "Disabled QDEC." ]
            Disabled,
            # [ doc = "Enable QDEC." ]
            Enabled,
        }
        impl EnableR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EnableR::Disabled => 0,
                    EnableR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EnableR {
                match bits {
                    0 => EnableR::Disabled,
                    1 => EnableR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EnableR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EnableR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `ENABLE`" ]
        pub enum EnableW {
            # [ doc = "Disabled QDEC." ]
            Disabled,
            # [ doc = "Enable QDEC." ]
            Enabled,
        }
        impl EnableW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EnableW::Disabled => 0,
                    EnableW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnableW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnableW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EnableW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled QDEC." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EnableW::Disabled)
            }
            # [ doc = "Enable QDEC." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EnableW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable or disable QDEC." ]
            # [ inline ( always ) ]
            pub fn enable(&self) -> EnableR {
                EnableR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable or disable QDEC." ]
            # [ inline ( always ) ]
            pub fn enable(&mut self) -> _EnableW {
                _EnableW { w: self }
            }
        }
    }
    # [ doc = "LED output pin polarity." ]
    pub struct Ledpol {
        register: VolatileCell<u32>,
    }
    # [ doc = "LED output pin polarity." ]
    pub mod ledpol {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ledpol {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `LEDPOL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum LedpolR {
            # [ doc = "LED output is active low." ]
            ActiveLow,
            # [ doc = "LED output is active high." ]
            ActiveHigh,
        }
        impl LedpolR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    LedpolR::ActiveLow => 0,
                    LedpolR::ActiveHigh => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> LedpolR {
                match bits {
                    0 => LedpolR::ActiveLow,
                    1 => LedpolR::ActiveHigh,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `ActiveLow`" ]
            # [ inline ( always ) ]
            pub fn is_active_low(&self) -> bool {
                *self == LedpolR::ActiveLow
            }
            # [ doc = "Checks if the value of the field is `ActiveHigh`" ]
            # [ inline ( always ) ]
            pub fn is_active_high(&self) -> bool {
                *self == LedpolR::ActiveHigh
            }
        }
        # [ doc = "Values that can be written to the field `LEDPOL`" ]
        pub enum LedpolW {
            # [ doc = "LED output is active low." ]
            ActiveLow,
            # [ doc = "LED output is active high." ]
            ActiveHigh,
        }
        impl LedpolW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    LedpolW::ActiveLow => 0,
                    LedpolW::ActiveHigh => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LedpolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LedpolW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: LedpolW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "LED output is active low." ]
            # [ inline ( always ) ]
            pub fn active_low(self) -> &'a mut W {
                self.variant(LedpolW::ActiveLow)
            }
            # [ doc = "LED output is active high." ]
            # [ inline ( always ) ]
            pub fn active_high(self) -> &'a mut W {
                self.variant(LedpolW::ActiveHigh)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - LED output pin polarity." ]
            # [ inline ( always ) ]
            pub fn ledpol(&self) -> LedpolR {
                LedpolR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - LED output pin polarity." ]
            # [ inline ( always ) ]
            pub fn ledpol(&mut self) -> _LedpolW {
                _LedpolW { w: self }
            }
        }
    }
    # [ doc = "Sample period." ]
    pub struct Sampleper {
        register: VolatileCell<u32>,
    }
    # [ doc = "Sample period." ]
    pub mod sampleper {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sampleper {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `SAMPLEPER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SampleperR {
            # [ doc = "128us sample period." ]
            _128us,
            # [ doc = "256us sample period." ]
            _256us,
            # [ doc = "512us sample period." ]
            _512us,
            # [ doc = "1024us sample period." ]
            _1024us,
            # [ doc = "2048us sample period." ]
            _2048us,
            # [ doc = "4096us sample period." ]
            _4096us,
            # [ doc = "8192us sample period." ]
            _8192us,
            # [ doc = "16384us sample period." ]
            _16384us,
        }
        impl SampleperR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SampleperR::_128us => 0,
                    SampleperR::_256us => 1,
                    SampleperR::_512us => 2,
                    SampleperR::_1024us => 3,
                    SampleperR::_2048us => 4,
                    SampleperR::_4096us => 5,
                    SampleperR::_8192us => 6,
                    SampleperR::_16384us => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SampleperR {
                match bits {
                    0 => SampleperR::_128us,
                    1 => SampleperR::_256us,
                    2 => SampleperR::_512us,
                    3 => SampleperR::_1024us,
                    4 => SampleperR::_2048us,
                    5 => SampleperR::_4096us,
                    6 => SampleperR::_8192us,
                    7 => SampleperR::_16384us,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `_128us`" ]
            # [ inline ( always ) ]
            pub fn is_128us(&self) -> bool {
                *self == SampleperR::_128us
            }
            # [ doc = "Checks if the value of the field is `_256us`" ]
            # [ inline ( always ) ]
            pub fn is_256us(&self) -> bool {
                *self == SampleperR::_256us
            }
            # [ doc = "Checks if the value of the field is `_512us`" ]
            # [ inline ( always ) ]
            pub fn is_512us(&self) -> bool {
                *self == SampleperR::_512us
            }
            # [ doc = "Checks if the value of the field is `_1024us`" ]
            # [ inline ( always ) ]
            pub fn is_1024us(&self) -> bool {
                *self == SampleperR::_1024us
            }
            # [ doc = "Checks if the value of the field is `_2048us`" ]
            # [ inline ( always ) ]
            pub fn is_2048us(&self) -> bool {
                *self == SampleperR::_2048us
            }
            # [ doc = "Checks if the value of the field is `_4096us`" ]
            # [ inline ( always ) ]
            pub fn is_4096us(&self) -> bool {
                *self == SampleperR::_4096us
            }
            # [ doc = "Checks if the value of the field is `_8192us`" ]
            # [ inline ( always ) ]
            pub fn is_8192us(&self) -> bool {
                *self == SampleperR::_8192us
            }
            # [ doc = "Checks if the value of the field is `_16384us`" ]
            # [ inline ( always ) ]
            pub fn is_16384us(&self) -> bool {
                *self == SampleperR::_16384us
            }
        }
        # [ doc = "Values that can be written to the field `SAMPLEPER`" ]
        pub enum SampleperW {
            # [ doc = "128us sample period." ]
            _128us,
            # [ doc = "256us sample period." ]
            _256us,
            # [ doc = "512us sample period." ]
            _512us,
            # [ doc = "1024us sample period." ]
            _1024us,
            # [ doc = "2048us sample period." ]
            _2048us,
            # [ doc = "4096us sample period." ]
            _4096us,
            # [ doc = "8192us sample period." ]
            _8192us,
            # [ doc = "16384us sample period." ]
            _16384us,
        }
        impl SampleperW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SampleperW::_128us => 0,
                    SampleperW::_256us => 1,
                    SampleperW::_512us => 2,
                    SampleperW::_1024us => 3,
                    SampleperW::_2048us => 4,
                    SampleperW::_4096us => 5,
                    SampleperW::_8192us => 6,
                    SampleperW::_16384us => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SampleperW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SampleperW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SampleperW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "128us sample period." ]
            # [ inline ( always ) ]
            pub fn _128us(self) -> &'a mut W {
                self.variant(SampleperW::_128us)
            }
            # [ doc = "256us sample period." ]
            # [ inline ( always ) ]
            pub fn _256us(self) -> &'a mut W {
                self.variant(SampleperW::_256us)
            }
            # [ doc = "512us sample period." ]
            # [ inline ( always ) ]
            pub fn _512us(self) -> &'a mut W {
                self.variant(SampleperW::_512us)
            }
            # [ doc = "1024us sample period." ]
            # [ inline ( always ) ]
            pub fn _1024us(self) -> &'a mut W {
                self.variant(SampleperW::_1024us)
            }
            # [ doc = "2048us sample period." ]
            # [ inline ( always ) ]
            pub fn _2048us(self) -> &'a mut W {
                self.variant(SampleperW::_2048us)
            }
            # [ doc = "4096us sample period." ]
            # [ inline ( always ) ]
            pub fn _4096us(self) -> &'a mut W {
                self.variant(SampleperW::_4096us)
            }
            # [ doc = "8192us sample period." ]
            # [ inline ( always ) ]
            pub fn _8192us(self) -> &'a mut W {
                self.variant(SampleperW::_8192us)
            }
            # [ doc = "16384us sample period." ]
            # [ inline ( always ) ]
            pub fn _16384us(self) -> &'a mut W {
                self.variant(SampleperW::_16384us)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:2 - Sample period." ]
            # [ inline ( always ) ]
            pub fn sampleper(&self) -> SampleperR {
                SampleperR::_from(
                    {
                        const MASK: u8 = 7;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:2 - Sample period." ]
            # [ inline ( always ) ]
            pub fn sampleper(&mut self) -> _SampleperW {
                _SampleperW { w: self }
            }
        }
    }
    # [ doc = "Motion sample value." ]
    pub struct Sample {
        register: VolatileCell<u32>,
    }
    # [ doc = "Motion sample value." ]
    pub mod sample {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Sample {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SampleR {
            bits: u32,
        }
        impl SampleR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Last sample taken in compliment to 2." ]
            # [ inline ( always ) ]
            pub fn sample(&self) -> SampleR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                SampleR { bits }
            }
        }
    }
    # [ doc = "Number of samples to generate an EVENT_REPORTRDY." ]
    pub struct Reportper {
        register: VolatileCell<u32>,
    }
    # [ doc = "Number of samples to generate an EVENT_REPORTRDY." ]
    pub mod reportper {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Reportper {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `REPORTPER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ReportperR {
            # [ doc = "10 samples per report." ]
            _10smpl,
            # [ doc = "40 samples per report." ]
            _40smpl,
            # [ doc = "80 samples per report." ]
            _80smpl,
            # [ doc = "120 samples per report." ]
            _120smpl,
            # [ doc = "160 samples per report." ]
            _160smpl,
            # [ doc = "200 samples per report." ]
            _200smpl,
            # [ doc = "240 samples per report." ]
            _240smpl,
            # [ doc = "280 samples per report." ]
            _280smpl,
        }
        impl ReportperR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ReportperR::_10smpl => 0,
                    ReportperR::_40smpl => 1,
                    ReportperR::_80smpl => 2,
                    ReportperR::_120smpl => 3,
                    ReportperR::_160smpl => 4,
                    ReportperR::_200smpl => 5,
                    ReportperR::_240smpl => 6,
                    ReportperR::_280smpl => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ReportperR {
                match bits {
                    0 => ReportperR::_10smpl,
                    1 => ReportperR::_40smpl,
                    2 => ReportperR::_80smpl,
                    3 => ReportperR::_120smpl,
                    4 => ReportperR::_160smpl,
                    5 => ReportperR::_200smpl,
                    6 => ReportperR::_240smpl,
                    7 => ReportperR::_280smpl,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `_10smpl`" ]
            # [ inline ( always ) ]
            pub fn is_10smpl(&self) -> bool {
                *self == ReportperR::_10smpl
            }
            # [ doc = "Checks if the value of the field is `_40smpl`" ]
            # [ inline ( always ) ]
            pub fn is_40smpl(&self) -> bool {
                *self == ReportperR::_40smpl
            }
            # [ doc = "Checks if the value of the field is `_80smpl`" ]
            # [ inline ( always ) ]
            pub fn is_80smpl(&self) -> bool {
                *self == ReportperR::_80smpl
            }
            # [ doc = "Checks if the value of the field is `_120smpl`" ]
            # [ inline ( always ) ]
            pub fn is_120smpl(&self) -> bool {
                *self == ReportperR::_120smpl
            }
            # [ doc = "Checks if the value of the field is `_160smpl`" ]
            # [ inline ( always ) ]
            pub fn is_160smpl(&self) -> bool {
                *self == ReportperR::_160smpl
            }
            # [ doc = "Checks if the value of the field is `_200smpl`" ]
            # [ inline ( always ) ]
            pub fn is_200smpl(&self) -> bool {
                *self == ReportperR::_200smpl
            }
            # [ doc = "Checks if the value of the field is `_240smpl`" ]
            # [ inline ( always ) ]
            pub fn is_240smpl(&self) -> bool {
                *self == ReportperR::_240smpl
            }
            # [ doc = "Checks if the value of the field is `_280smpl`" ]
            # [ inline ( always ) ]
            pub fn is_280smpl(&self) -> bool {
                *self == ReportperR::_280smpl
            }
        }
        # [ doc = "Values that can be written to the field `REPORTPER`" ]
        pub enum ReportperW {
            # [ doc = "10 samples per report." ]
            _10smpl,
            # [ doc = "40 samples per report." ]
            _40smpl,
            # [ doc = "80 samples per report." ]
            _80smpl,
            # [ doc = "120 samples per report." ]
            _120smpl,
            # [ doc = "160 samples per report." ]
            _160smpl,
            # [ doc = "200 samples per report." ]
            _200smpl,
            # [ doc = "240 samples per report." ]
            _240smpl,
            # [ doc = "280 samples per report." ]
            _280smpl,
        }
        impl ReportperW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ReportperW::_10smpl => 0,
                    ReportperW::_40smpl => 1,
                    ReportperW::_80smpl => 2,
                    ReportperW::_120smpl => 3,
                    ReportperW::_160smpl => 4,
                    ReportperW::_200smpl => 5,
                    ReportperW::_240smpl => 6,
                    ReportperW::_280smpl => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReportperW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReportperW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ReportperW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "10 samples per report." ]
            # [ inline ( always ) ]
            pub fn _10smpl(self) -> &'a mut W {
                self.variant(ReportperW::_10smpl)
            }
            # [ doc = "40 samples per report." ]
            # [ inline ( always ) ]
            pub fn _40smpl(self) -> &'a mut W {
                self.variant(ReportperW::_40smpl)
            }
            # [ doc = "80 samples per report." ]
            # [ inline ( always ) ]
            pub fn _80smpl(self) -> &'a mut W {
                self.variant(ReportperW::_80smpl)
            }
            # [ doc = "120 samples per report." ]
            # [ inline ( always ) ]
            pub fn _120smpl(self) -> &'a mut W {
                self.variant(ReportperW::_120smpl)
            }
            # [ doc = "160 samples per report." ]
            # [ inline ( always ) ]
            pub fn _160smpl(self) -> &'a mut W {
                self.variant(ReportperW::_160smpl)
            }
            # [ doc = "200 samples per report." ]
            # [ inline ( always ) ]
            pub fn _200smpl(self) -> &'a mut W {
                self.variant(ReportperW::_200smpl)
            }
            # [ doc = "240 samples per report." ]
            # [ inline ( always ) ]
            pub fn _240smpl(self) -> &'a mut W {
                self.variant(ReportperW::_240smpl)
            }
            # [ doc = "280 samples per report." ]
            # [ inline ( always ) ]
            pub fn _280smpl(self) -> &'a mut W {
                self.variant(ReportperW::_280smpl)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:2 - Number of samples to generate an EVENT_REPORTRDY." ]
            # [ inline ( always ) ]
            pub fn reportper(&self) -> ReportperR {
                ReportperR::_from(
                    {
                        const MASK: u8 = 7;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:2 - Number of samples to generate an EVENT_REPORTRDY." ]
            # [ inline ( always ) ]
            pub fn reportper(&mut self) -> _ReportperW {
                _ReportperW { w: self }
            }
        }
    }
    # [ doc = "Accumulated valid transitions register." ]
    pub struct Acc {
        register: VolatileCell<u32>,
    }
    # [ doc = "Accumulated valid transitions register." ]
    pub mod acc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Acc {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    # [ doc = "Snapshot of ACC register. Value generated by the TASKS_READCLEACC task." ]
    pub struct Accread {
        register: VolatileCell<u32>,
    }
    # [ doc = "Snapshot of ACC register. Value generated by the TASKS_READCLEACC task." ]
    pub mod accread {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Accread {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    # [ doc = "Pin select for LED output." ]
    pub struct Pselled {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin select for LED output." ]
    pub mod pselled {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pselled {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pin select for phase A input." ]
    pub struct Psela {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin select for phase A input." ]
    pub mod psela {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Psela {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pin select for phase B input." ]
    pub struct Pselb {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pin select for phase B input." ]
    pub mod pselb {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pselb {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Enable debouncer input filters." ]
    pub struct Dbfen {
        register: VolatileCell<u32>,
    }
    # [ doc = "Enable debouncer input filters." ]
    pub mod dbfen {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dbfen {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `DBFEN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DbfenR {
            # [ doc = "Debounce input filters disabled." ]
            Disabled,
            # [ doc = "Debounce input filters enabled." ]
            Enabled,
        }
        impl DbfenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DbfenR::Disabled => 0,
                    DbfenR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DbfenR {
                match bits {
                    0 => DbfenR::Disabled,
                    1 => DbfenR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DbfenR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DbfenR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `DBFEN`" ]
        pub enum DbfenW {
            # [ doc = "Debounce input filters disabled." ]
            Disabled,
            # [ doc = "Debounce input filters enabled." ]
            Enabled,
        }
        impl DbfenW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DbfenW::Disabled => 0,
                    DbfenW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbfenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbfenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DbfenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Debounce input filters disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DbfenW::Disabled)
            }
            # [ doc = "Debounce input filters enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DbfenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable debounce input filters." ]
            # [ inline ( always ) ]
            pub fn dbfen(&self) -> DbfenR {
                DbfenR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable debounce input filters." ]
            # [ inline ( always ) ]
            pub fn dbfen(&mut self) -> _DbfenW {
                _DbfenW { w: self }
            }
        }
    }
    # [ doc = "Time LED is switched ON before the sample." ]
    pub struct Ledpre {
        register: VolatileCell<u32>,
    }
    # [ doc = "Time LED is switched ON before the sample." ]
    pub mod ledpre {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ledpre {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LedpreR {
            bits: u16,
        }
        impl LedpreR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LedpreW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LedpreW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 511;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:8 - Period in us the LED in switched on prior to sampling." ]
            # [ inline ( always ) ]
            pub fn ledpre(&self) -> LedpreR {
                let bits = {
                    const MASK: u16 = 511;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                LedpreR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 16 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:8 - Period in us the LED in switched on prior to sampling." ]
            # [ inline ( always ) ]
            pub fn ledpre(&mut self) -> _LedpreW {
                _LedpreW { w: self }
            }
        }
    }
    # [ doc = "Accumulated double (error) transitions register." ]
    pub struct Accdbl {
        register: VolatileCell<u32>,
    }
    # [ doc = "Accumulated double (error) transitions register." ]
    pub mod accdbl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Accdbl {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AccdblR {
            bits: u8,
        }
        impl AccdblR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - Accumulated double (error) transitions." ]
            # [ inline ( always ) ]
            pub fn accdbl(&self) -> AccdblR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AccdblR { bits }
            }
        }
    }
    # [ doc = "Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC task." ]
    pub struct Accdblread {
        register: VolatileCell<u32>,
    }
    # [ doc = "Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC task." ]
    pub mod accdblread {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Accdblread {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AccdblreadR {
            bits: u8,
        }
        impl AccdblreadR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - Snapshot of accumulated double (error) transitions." ]
            # [ inline ( always ) ]
            pub fn accdblread(&self) -> AccdblreadR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AccdblreadR { bits }
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "Rotary decoder." ]
pub struct Qdec {
    register_block: qdec::RegisterBlock,
}
impl Deref for Qdec {
    type Target = qdec::RegisterBlock;
    fn deref(&self) -> &qdec::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Low power comparator." ]
pub const LPCOMP: Peripheral<Lpcomp> = unsafe { Peripheral::new(1073819648) };
# [ doc = "Low power comparator." ]
pub mod lpcomp {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Start the comparator." ]
        pub tasks_start: TasksStart,
        # [ doc = "0x04 - Stop the comparator." ]
        pub tasks_stop: TasksStop,
        # [ doc = "0x08 - Sample comparator value." ]
        pub tasks_sample: TasksSample,
        _reserved0: [u8; 244usize],
        # [ doc = "0x100 - LPCOMP is ready and output is valid." ]
        pub events_ready: EventsReady,
        # [ doc = "0x104 - Input voltage crossed the threshold going down." ]
        pub events_down: EventsDown,
        # [ doc = "0x108 - Input voltage crossed the threshold going up." ]
        pub events_up: EventsUp,
        # [ doc = "0x10c - Input voltage crossed the threshold in any direction." ]
        pub events_cross: EventsCross,
        _reserved1: [u8; 240usize],
        # [ doc = "0x200 - Shortcuts for the LPCOMP." ]
        pub shorts: Shorts,
        _reserved2: [u8; 256usize],
        # [ doc = "0x304 - Interrupt enable set register." ]
        pub intenset: Intenset,
        # [ doc = "0x308 - Interrupt enable clear register." ]
        pub intenclr: Intenclr,
        _reserved3: [u8; 244usize],
        # [ doc = "0x400 - Result of last compare." ]
        pub result: Result,
        _reserved4: [u8; 252usize],
        # [ doc = "0x500 - Enable the LPCOMP." ]
        pub enable: Enable,
        # [ doc = "0x504 - Input pin select." ]
        pub psel: Psel,
        # [ doc = "0x508 - Reference select." ]
        pub refsel: Refsel,
        # [ doc = "0x50c - External reference select." ]
        pub extrefsel: Extrefsel,
        _reserved5: [u8; 16usize],
        # [ doc = "0x520 - Analog detect configuration." ]
        pub anadetect: Anadetect,
        _reserved6: [u8; 2776usize],
        # [ doc = "0xffc - Peripheral power control." ]
        pub power: Power,
    }
    # [ doc = "Start the comparator." ]
    pub struct TasksStart {
        register: VolatileCell<u32>,
    }
    # [ doc = "Start the comparator." ]
    pub mod tasks_start {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStart {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Stop the comparator." ]
    pub struct TasksStop {
        register: VolatileCell<u32>,
    }
    # [ doc = "Stop the comparator." ]
    pub mod tasks_stop {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksStop {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Sample comparator value." ]
    pub struct TasksSample {
        register: VolatileCell<u32>,
    }
    # [ doc = "Sample comparator value." ]
    pub mod tasks_sample {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::TasksSample {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "LPCOMP is ready and output is valid." ]
    pub struct EventsReady {
        register: VolatileCell<u32>,
    }
    # [ doc = "LPCOMP is ready and output is valid." ]
    pub mod events_ready {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsReady {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Input voltage crossed the threshold going down." ]
    pub struct EventsDown {
        register: VolatileCell<u32>,
    }
    # [ doc = "Input voltage crossed the threshold going down." ]
    pub mod events_down {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsDown {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Input voltage crossed the threshold going up." ]
    pub struct EventsUp {
        register: VolatileCell<u32>,
    }
    # [ doc = "Input voltage crossed the threshold going up." ]
    pub mod events_up {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsUp {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Input voltage crossed the threshold in any direction." ]
    pub struct EventsCross {
        register: VolatileCell<u32>,
    }
    # [ doc = "Input voltage crossed the threshold in any direction." ]
    pub mod events_cross {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::EventsCross {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Shortcuts for the LPCOMP." ]
    pub struct Shorts {
        register: VolatileCell<u32>,
    }
    # [ doc = "Shortcuts for the LPCOMP." ]
    pub mod shorts {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Shorts {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `READY_SAMPLE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ReadySampleR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl ReadySampleR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ReadySampleR::Disabled => 0,
                    ReadySampleR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ReadySampleR {
                match bits {
                    0 => ReadySampleR::Disabled,
                    1 => ReadySampleR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ReadySampleR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ReadySampleR::Enabled
            }
        }
        # [ doc = "Possible values of the field `READY_STOP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ReadyStopR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl ReadyStopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ReadyStopR::Disabled => 0,
                    ReadyStopR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ReadyStopR {
                match bits {
                    0 => ReadyStopR::Disabled,
                    1 => ReadyStopR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ReadyStopR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ReadyStopR::Enabled
            }
        }
        # [ doc = "Possible values of the field `DOWN_STOP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DownStopR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl DownStopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DownStopR::Disabled => 0,
                    DownStopR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DownStopR {
                match bits {
                    0 => DownStopR::Disabled,
                    1 => DownStopR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DownStopR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DownStopR::Enabled
            }
        }
        # [ doc = "Possible values of the field `UP_STOP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum UpStopR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl UpStopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    UpStopR::Disabled => 0,
                    UpStopR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> UpStopR {
                match bits {
                    0 => UpStopR::Disabled,
                    1 => UpStopR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == UpStopR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == UpStopR::Enabled
            }
        }
        # [ doc = "Possible values of the field `CROSS_STOP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CrossStopR {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl CrossStopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CrossStopR::Disabled => 0,
                    CrossStopR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CrossStopR {
                match bits {
                    0 => CrossStopR::Disabled,
                    1 => CrossStopR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == CrossStopR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == CrossStopR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `READY_SAMPLE`" ]
        pub enum ReadySampleW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl ReadySampleW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ReadySampleW::Disabled => 0,
                    ReadySampleW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReadySampleW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReadySampleW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ReadySampleW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ReadySampleW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ReadySampleW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `READY_STOP`" ]
        pub enum ReadyStopW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl ReadyStopW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ReadyStopW::Disabled => 0,
                    ReadyStopW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReadyStopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReadyStopW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ReadyStopW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ReadyStopW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ReadyStopW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DOWN_STOP`" ]
        pub enum DownStopW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl DownStopW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DownStopW::Disabled => 0,
                    DownStopW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DownStopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DownStopW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DownStopW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DownStopW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DownStopW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `UP_STOP`" ]
        pub enum UpStopW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl UpStopW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UpStopW::Disabled => 0,
                    UpStopW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UpStopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UpStopW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: UpStopW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UpStopW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UpStopW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CROSS_STOP`" ]
        pub enum CrossStopW {
            # [ doc = "Shortcut disabled." ]
            Disabled,
            # [ doc = "Shortcut enabled." ]
            Enabled,
        }
        impl CrossStopW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CrossStopW::Disabled => 0,
                    CrossStopW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CrossStopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CrossStopW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CrossStopW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Shortcut disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CrossStopW::Disabled)
            }
            # [ doc = "Shortcut enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CrossStopW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Shortcut between READY event and SAMPLE task." ]
            # [ inline ( always ) ]
            pub fn ready_sample(&self) -> ReadySampleR {
                ReadySampleR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Shortcut between RADY event and STOP task." ]
            # [ inline ( always ) ]
            pub fn ready_stop(&self) -> ReadyStopR {
                ReadyStopR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Shortcut between DOWN event and STOP task." ]
            # [ inline ( always ) ]
            pub fn down_stop(&self) -> DownStopR {
                DownStopR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Shortcut between UP event and STOP task." ]
            # [ inline ( always ) ]
            pub fn up_stop(&self) -> UpStopR {
                UpStopR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Shortcut between CROSS event and STOP task." ]
            # [ inline ( always ) ]
            pub fn cross_stop(&self) -> CrossStopR {
                CrossStopR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Shortcut between READY event and SAMPLE task." ]
            # [ inline ( always ) ]
            pub fn ready_sample(&mut self) -> _ReadySampleW {
                _ReadySampleW { w: self }
            }
            # [ doc = "Bit 1 - Shortcut between RADY event and STOP task." ]
            # [ inline ( always ) ]
            pub fn ready_stop(&mut self) -> _ReadyStopW {
                _ReadyStopW { w: self }
            }
            # [ doc = "Bit 2 - Shortcut between DOWN event and STOP task." ]
            # [ inline ( always ) ]
            pub fn down_stop(&mut self) -> _DownStopW {
                _DownStopW { w: self }
            }
            # [ doc = "Bit 3 - Shortcut between UP event and STOP task." ]
            # [ inline ( always ) ]
            pub fn up_stop(&mut self) -> _UpStopW {
                _UpStopW { w: self }
            }
            # [ doc = "Bit 4 - Shortcut between CROSS event and STOP task." ]
            # [ inline ( always ) ]
            pub fn cross_stop(&mut self) -> _CrossStopW {
                _CrossStopW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable set register." ]
    pub struct Intenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable set register." ]
    pub mod intenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `READY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ReadyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ReadyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ReadyR::Disabled => 0,
                    ReadyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ReadyR {
                match bits {
                    0 => ReadyR::Disabled,
                    1 => ReadyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ReadyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ReadyR::Enabled
            }
        }
        # [ doc = "Possible values of the field `DOWN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DownR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl DownR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DownR::Disabled => 0,
                    DownR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DownR {
                match bits {
                    0 => DownR::Disabled,
                    1 => DownR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DownR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DownR::Enabled
            }
        }
        # [ doc = "Possible values of the field `UP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum UpR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl UpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    UpR::Disabled => 0,
                    UpR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> UpR {
                match bits {
                    0 => UpR::Disabled,
                    1 => UpR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == UpR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == UpR::Enabled
            }
        }
        # [ doc = "Possible values of the field `CROSS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CrossR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl CrossR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CrossR::Disabled => 0,
                    CrossR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CrossR {
                match bits {
                    0 => CrossR::Disabled,
                    1 => CrossR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == CrossR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == CrossR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `READY`" ]
        pub enum ReadyW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl ReadyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ReadyW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReadyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReadyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ReadyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(ReadyW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DOWN`" ]
        pub enum DownW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl DownW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DownW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DownW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DownW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DownW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(DownW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `UP`" ]
        pub enum UpW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl UpW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UpW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UpW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: UpW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(UpW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CROSS`" ]
        pub enum CrossW {
            # [ doc = "Enable interrupt on write." ]
            Set,
        }
        impl CrossW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CrossW::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CrossW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CrossW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CrossW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(CrossW::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable interrupt on READY event." ]
            # [ inline ( always ) ]
            pub fn ready(&self) -> ReadyR {
                ReadyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Enable interrupt on DOWN event." ]
            # [ inline ( always ) ]
            pub fn down(&self) -> DownR {
                DownR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Enable interrupt on UP event." ]
            # [ inline ( always ) ]
            pub fn up(&self) -> UpR {
                UpR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Enable interrupt on CROSS event." ]
            # [ inline ( always ) ]
            pub fn cross(&self) -> CrossR {
                CrossR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable interrupt on READY event." ]
            # [ inline ( always ) ]
            pub fn ready(&mut self) -> _ReadyW {
                _ReadyW { w: self }
            }
            # [ doc = "Bit 1 - Enable interrupt on DOWN event." ]
            # [ inline ( always ) ]
            pub fn down(&mut self) -> _DownW {
                _DownW { w: self }
            }
            # [ doc = "Bit 2 - Enable interrupt on UP event." ]
            # [ inline ( always ) ]
            pub fn up(&mut self) -> _UpW {
                _UpW { w: self }
            }
            # [ doc = "Bit 3 - Enable interrupt on CROSS event." ]
            # [ inline ( always ) ]
            pub fn cross(&mut self) -> _CrossW {
                _CrossW { w: self }
            }
        }
    }
    # [ doc = "Interrupt enable clear register." ]
    pub struct Intenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt enable clear register." ]
    pub mod intenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Intenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `READY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ReadyR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl ReadyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ReadyR::Disabled => 0,
                    ReadyR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ReadyR {
                match bits {
                    0 => ReadyR::Disabled,
                    1 => ReadyR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == ReadyR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == ReadyR::Enabled
            }
        }
        # [ doc = "Possible values of the field `DOWN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DownR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl DownR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DownR::Disabled => 0,
                    DownR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DownR {
                match bits {
                    0 => DownR::Disabled,
                    1 => DownR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == DownR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == DownR::Enabled
            }
        }
        # [ doc = "Possible values of the field `UP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum UpR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl UpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    UpR::Disabled => 0,
                    UpR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> UpR {
                match bits {
                    0 => UpR::Disabled,
                    1 => UpR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == UpR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == UpR::Enabled
            }
        }
        # [ doc = "Possible values of the field `CROSS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CrossR {
            # [ doc = "Interrupt disabled." ]
            Disabled,
            # [ doc = "Interrupt enabled." ]
            Enabled,
        }
        impl CrossR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CrossR::Disabled => 0,
                    CrossR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CrossR {
                match bits {
                    0 => CrossR::Disabled,
                    1 => CrossR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == CrossR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == CrossR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `READY`" ]
        pub enum ReadyW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl ReadyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ReadyW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReadyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReadyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ReadyW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(ReadyW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DOWN`" ]
        pub enum DownW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl DownW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DownW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DownW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DownW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DownW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(DownW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `UP`" ]
        pub enum UpW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl UpW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UpW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UpW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: UpW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(UpW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CROSS`" ]
        pub enum CrossW {
            # [ doc = "Disable interrupt on write." ]
            Clear,
        }
        impl CrossW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CrossW::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CrossW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CrossW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CrossW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable interrupt on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(CrossW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable interrupt on READY event." ]
            # [ inline ( always ) ]
            pub fn ready(&self) -> ReadyR {
                ReadyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Disable interrupt on DOWN event." ]
            # [ inline ( always ) ]
            pub fn down(&self) -> DownR {
                DownR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Disable interrupt on UP event." ]
            # [ inline ( always ) ]
            pub fn up(&self) -> UpR {
                UpR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Disable interrupt on CROSS event." ]
            # [ inline ( always ) ]
            pub fn cross(&self) -> CrossR {
                CrossR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable interrupt on READY event." ]
            # [ inline ( always ) ]
            pub fn ready(&mut self) -> _ReadyW {
                _ReadyW { w: self }
            }
            # [ doc = "Bit 1 - Disable interrupt on DOWN event." ]
            # [ inline ( always ) ]
            pub fn down(&mut self) -> _DownW {
                _DownW { w: self }
            }
            # [ doc = "Bit 2 - Disable interrupt on UP event." ]
            # [ inline ( always ) ]
            pub fn up(&mut self) -> _UpW {
                _UpW { w: self }
            }
            # [ doc = "Bit 3 - Disable interrupt on CROSS event." ]
            # [ inline ( always ) ]
            pub fn cross(&mut self) -> _CrossW {
                _CrossW { w: self }
            }
        }
    }
    # [ doc = "Result of last compare." ]
    pub struct Result {
        register: VolatileCell<u32>,
    }
    # [ doc = "Result of last compare." ]
    pub mod result {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Result {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = "Possible values of the field `RESULT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ResultR {
            # [ doc = "Input voltage is bellow the reference threshold." ]
            Bellow,
            # [ doc = "Input voltage is above the reference threshold." ]
            Above,
        }
        impl ResultR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ResultR::Bellow => 0,
                    ResultR::Above => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ResultR {
                match bits {
                    0 => ResultR::Bellow,
                    1 => ResultR::Above,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Bellow`" ]
            # [ inline ( always ) ]
            pub fn is_bellow(&self) -> bool {
                *self == ResultR::Bellow
            }
            # [ doc = "Checks if the value of the field is `Above`" ]
            # [ inline ( always ) ]
            pub fn is_above(&self) -> bool {
                *self == ResultR::Above
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Result of last compare. Decision point SAMPLE task." ]
            # [ inline ( always ) ]
            pub fn result(&self) -> ResultR {
                ResultR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
    }
    # [ doc = "Enable the LPCOMP." ]
    pub struct Enable {
        register: VolatileCell<u32>,
    }
    # [ doc = "Enable the LPCOMP." ]
    pub mod enable {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Enable {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ENABLE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EnableR {
            # [ doc = "Disabled LPCOMP." ]
            Disabled,
            # [ doc = "Enable LPCOMP." ]
            Enabled,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl EnableR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EnableR::Disabled => 0,
                    EnableR::Enabled => 1,
                    EnableR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EnableR {
                match bits {
                    0 => EnableR::Disabled,
                    1 => EnableR::Enabled,
                    i => EnableR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == EnableR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == EnableR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `ENABLE`" ]
        pub enum EnableW {
            # [ doc = "Disabled LPCOMP." ]
            Disabled,
            # [ doc = "Enable LPCOMP." ]
            Enabled,
        }
        impl EnableW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EnableW::Disabled => 0,
                    EnableW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnableW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnableW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EnableW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disabled LPCOMP." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EnableW::Disabled)
            }
            # [ doc = "Enable LPCOMP." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EnableW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - Enable or disable LPCOMP." ]
            # [ inline ( always ) ]
            pub fn enable(&self) -> EnableR {
                EnableR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - Enable or disable LPCOMP." ]
            # [ inline ( always ) ]
            pub fn enable(&mut self) -> _EnableW {
                _EnableW { w: self }
            }
        }
    }
    # [ doc = "Input pin select." ]
    pub struct Psel {
        register: VolatileCell<u32>,
    }
    # [ doc = "Input pin select." ]
    pub mod psel {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Psel {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `PSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PselR {
            # [ doc = "Use analog input 0 as analog input." ]
            AnalogInput0,
            # [ doc = "Use analog input 1 as analog input." ]
            AnalogInput1,
            # [ doc = "Use analog input 2 as analog input." ]
            AnalogInput2,
            # [ doc = "Use analog input 3 as analog input." ]
            AnalogInput3,
            # [ doc = "Use analog input 4 as analog input." ]
            AnalogInput4,
            # [ doc = "Use analog input 5 as analog input." ]
            AnalogInput5,
            # [ doc = "Use analog input 6 as analog input." ]
            AnalogInput6,
            # [ doc = "Use analog input 7 as analog input." ]
            AnalogInput7,
        }
        impl PselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PselR::AnalogInput0 => 0,
                    PselR::AnalogInput1 => 1,
                    PselR::AnalogInput2 => 2,
                    PselR::AnalogInput3 => 3,
                    PselR::AnalogInput4 => 4,
                    PselR::AnalogInput5 => 5,
                    PselR::AnalogInput6 => 6,
                    PselR::AnalogInput7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PselR {
                match bits {
                    0 => PselR::AnalogInput0,
                    1 => PselR::AnalogInput1,
                    2 => PselR::AnalogInput2,
                    3 => PselR::AnalogInput3,
                    4 => PselR::AnalogInput4,
                    5 => PselR::AnalogInput5,
                    6 => PselR::AnalogInput6,
                    7 => PselR::AnalogInput7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `AnalogInput0`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input0(&self) -> bool {
                *self == PselR::AnalogInput0
            }
            # [ doc = "Checks if the value of the field is `AnalogInput1`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input1(&self) -> bool {
                *self == PselR::AnalogInput1
            }
            # [ doc = "Checks if the value of the field is `AnalogInput2`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input2(&self) -> bool {
                *self == PselR::AnalogInput2
            }
            # [ doc = "Checks if the value of the field is `AnalogInput3`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input3(&self) -> bool {
                *self == PselR::AnalogInput3
            }
            # [ doc = "Checks if the value of the field is `AnalogInput4`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input4(&self) -> bool {
                *self == PselR::AnalogInput4
            }
            # [ doc = "Checks if the value of the field is `AnalogInput5`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input5(&self) -> bool {
                *self == PselR::AnalogInput5
            }
            # [ doc = "Checks if the value of the field is `AnalogInput6`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input6(&self) -> bool {
                *self == PselR::AnalogInput6
            }
            # [ doc = "Checks if the value of the field is `AnalogInput7`" ]
            # [ inline ( always ) ]
            pub fn is_analog_input7(&self) -> bool {
                *self == PselR::AnalogInput7
            }
        }
        # [ doc = "Values that can be written to the field `PSEL`" ]
        pub enum PselW {
            # [ doc = "Use analog input 0 as analog input." ]
            AnalogInput0,
            # [ doc = "Use analog input 1 as analog input." ]
            AnalogInput1,
            # [ doc = "Use analog input 2 as analog input." ]
            AnalogInput2,
            # [ doc = "Use analog input 3 as analog input." ]
            AnalogInput3,
            # [ doc = "Use analog input 4 as analog input." ]
            AnalogInput4,
            # [ doc = "Use analog input 5 as analog input." ]
            AnalogInput5,
            # [ doc = "Use analog input 6 as analog input." ]
            AnalogInput6,
            # [ doc = "Use analog input 7 as analog input." ]
            AnalogInput7,
        }
        impl PselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PselW::AnalogInput0 => 0,
                    PselW::AnalogInput1 => 1,
                    PselW::AnalogInput2 => 2,
                    PselW::AnalogInput3 => 3,
                    PselW::AnalogInput4 => 4,
                    PselW::AnalogInput5 => 5,
                    PselW::AnalogInput6 => 6,
                    PselW::AnalogInput7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Use analog input 0 as analog input." ]
            # [ inline ( always ) ]
            pub fn analog_input0(self) -> &'a mut W {
                self.variant(PselW::AnalogInput0)
            }
            # [ doc = "Use analog input 1 as analog input." ]
            # [ inline ( always ) ]
            pub fn analog_input1(self) -> &'a mut W {
                self.variant(PselW::AnalogInput1)
            }
            # [ doc = "Use analog input 2 as analog input." ]
            # [ inline ( always ) ]
            pub fn analog_input2(self) -> &'a mut W {
                self.variant(PselW::AnalogInput2)
            }
            # [ doc = "Use analog input 3 as analog input." ]
            # [ inline ( always ) ]
            pub fn analog_input3(self) -> &'a mut W {
                self.variant(PselW::AnalogInput3)
            }
            # [ doc = "Use analog input 4 as analog input." ]
            # [ inline ( always ) ]
            pub fn analog_input4(self) -> &'a mut W {
                self.variant(PselW::AnalogInput4)
            }
            # [ doc = "Use analog input 5 as analog input." ]
            # [ inline ( always ) ]
            pub fn analog_input5(self) -> &'a mut W {
                self.variant(PselW::AnalogInput5)
            }
            # [ doc = "Use analog input 6 as analog input." ]
            # [ inline ( always ) ]
            pub fn analog_input6(self) -> &'a mut W {
                self.variant(PselW::AnalogInput6)
            }
            # [ doc = "Use analog input 7 as analog input." ]
            # [ inline ( always ) ]
            pub fn analog_input7(self) -> &'a mut W {
                self.variant(PselW::AnalogInput7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:2 - Analog input pin select." ]
            # [ inline ( always ) ]
            pub fn psel(&self) -> PselR {
                PselR::_from(
                    {
                        const MASK: u8 = 7;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:2 - Analog input pin select." ]
            # [ inline ( always ) ]
            pub fn psel(&mut self) -> _PselW {
                _PselW { w: self }
            }
        }
    }
    # [ doc = "Reference select." ]
    pub struct Refsel {
        register: VolatileCell<u32>,
    }
    # [ doc = "Reference select." ]
    pub mod refsel {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Refsel {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `REFSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RefselR {
            # [ doc = "Use supply with a 1/8 prescaler as reference." ]
            SupplyOneEighthPrescaling,
            # [ doc = "Use supply with a 2/8 prescaler as reference." ]
            SupplyTwoEighthsPrescaling,
            # [ doc = "Use supply with a 3/8 prescaler as reference." ]
            SupplyThreeEighthsPrescaling,
            # [ doc = "Use supply with a 4/8 prescaler as reference." ]
            SupplyFourEighthsPrescaling,
            # [ doc = "Use supply with a 5/8 prescaler as reference." ]
            SupplyFiveEighthsPrescaling,
            # [ doc = "Use supply with a 6/8 prescaler as reference." ]
            SupplySixEighthsPrescaling,
            # [ doc = "Use supply with a 7/8 prescaler as reference." ]
            SupplySevenEighthsPrescaling,
            # [ doc = "Use external analog reference as reference." ]
            Aref,
        }
        impl RefselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RefselR::SupplyOneEighthPrescaling => 0,
                    RefselR::SupplyTwoEighthsPrescaling => 1,
                    RefselR::SupplyThreeEighthsPrescaling => 2,
                    RefselR::SupplyFourEighthsPrescaling => 3,
                    RefselR::SupplyFiveEighthsPrescaling => 4,
                    RefselR::SupplySixEighthsPrescaling => 5,
                    RefselR::SupplySevenEighthsPrescaling => 6,
                    RefselR::Aref => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RefselR {
                match bits {
                    0 => RefselR::SupplyOneEighthPrescaling,
                    1 => RefselR::SupplyTwoEighthsPrescaling,
                    2 => RefselR::SupplyThreeEighthsPrescaling,
                    3 => RefselR::SupplyFourEighthsPrescaling,
                    4 => RefselR::SupplyFiveEighthsPrescaling,
                    5 => RefselR::SupplySixEighthsPrescaling,
                    6 => RefselR::SupplySevenEighthsPrescaling,
                    7 => RefselR::Aref,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `SupplyOneEighthPrescaling`" ]
            # [ inline ( always ) ]
            pub fn is_supply_one_eighth_prescaling(&self) -> bool {
                *self == RefselR::SupplyOneEighthPrescaling
            }
            # [ doc = "Checks if the value of the field is `SupplyTwoEighthsPrescaling`" ]
            # [ inline ( always ) ]
            pub fn is_supply_two_eighths_prescaling(&self) -> bool {
                *self == RefselR::SupplyTwoEighthsPrescaling
            }
            # [ doc = "Checks if the value of the field is `SupplyThreeEighthsPrescaling`" ]
            # [ inline ( always ) ]
            pub fn is_supply_three_eighths_prescaling(&self) -> bool {
                *self == RefselR::SupplyThreeEighthsPrescaling
            }
            # [ doc = "Checks if the value of the field is `SupplyFourEighthsPrescaling`" ]
            # [ inline ( always ) ]
            pub fn is_supply_four_eighths_prescaling(&self) -> bool {
                *self == RefselR::SupplyFourEighthsPrescaling
            }
            # [ doc = "Checks if the value of the field is `SupplyFiveEighthsPrescaling`" ]
            # [ inline ( always ) ]
            pub fn is_supply_five_eighths_prescaling(&self) -> bool {
                *self == RefselR::SupplyFiveEighthsPrescaling
            }
            # [ doc = "Checks if the value of the field is `SupplySixEighthsPrescaling`" ]
            # [ inline ( always ) ]
            pub fn is_supply_six_eighths_prescaling(&self) -> bool {
                *self == RefselR::SupplySixEighthsPrescaling
            }
            # [ doc = "Checks if the value of the field is `SupplySevenEighthsPrescaling`" ]
            # [ inline ( always ) ]
            pub fn is_supply_seven_eighths_prescaling(&self) -> bool {
                *self == RefselR::SupplySevenEighthsPrescaling
            }
            # [ doc = "Checks if the value of the field is `Aref`" ]
            # [ inline ( always ) ]
            pub fn is_aref(&self) -> bool {
                *self == RefselR::Aref
            }
        }
        # [ doc = "Values that can be written to the field `REFSEL`" ]
        pub enum RefselW {
            # [ doc = "Use supply with a 1/8 prescaler as reference." ]
            SupplyOneEighthPrescaling,
            # [ doc = "Use supply with a 2/8 prescaler as reference." ]
            SupplyTwoEighthsPrescaling,
            # [ doc = "Use supply with a 3/8 prescaler as reference." ]
            SupplyThreeEighthsPrescaling,
            # [ doc = "Use supply with a 4/8 prescaler as reference." ]
            SupplyFourEighthsPrescaling,
            # [ doc = "Use supply with a 5/8 prescaler as reference." ]
            SupplyFiveEighthsPrescaling,
            # [ doc = "Use supply with a 6/8 prescaler as reference." ]
            SupplySixEighthsPrescaling,
            # [ doc = "Use supply with a 7/8 prescaler as reference." ]
            SupplySevenEighthsPrescaling,
            # [ doc = "Use external analog reference as reference." ]
            Aref,
        }
        impl RefselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RefselW::SupplyOneEighthPrescaling => 0,
                    RefselW::SupplyTwoEighthsPrescaling => 1,
                    RefselW::SupplyThreeEighthsPrescaling => 2,
                    RefselW::SupplyFourEighthsPrescaling => 3,
                    RefselW::SupplyFiveEighthsPrescaling => 4,
                    RefselW::SupplySixEighthsPrescaling => 5,
                    RefselW::SupplySevenEighthsPrescaling => 6,
                    RefselW::Aref => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RefselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RefselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RefselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Use supply with a 1/8 prescaler as reference." ]
            # [ inline ( always ) ]
            pub fn supply_one_eighth_prescaling(self) -> &'a mut W {
                self.variant(RefselW::SupplyOneEighthPrescaling)
            }
            # [ doc = "Use supply with a 2/8 prescaler as reference." ]
            # [ inline ( always ) ]
            pub fn supply_two_eighths_prescaling(self) -> &'a mut W {
                self.variant(RefselW::SupplyTwoEighthsPrescaling)
            }
            # [ doc = "Use supply with a 3/8 prescaler as reference." ]
            # [ inline ( always ) ]
            pub fn supply_three_eighths_prescaling(self) -> &'a mut W {
                self.variant(RefselW::SupplyThreeEighthsPrescaling)
            }
            # [ doc = "Use supply with a 4/8 prescaler as reference." ]
            # [ inline ( always ) ]
            pub fn supply_four_eighths_prescaling(self) -> &'a mut W {
                self.variant(RefselW::SupplyFourEighthsPrescaling)
            }
            # [ doc = "Use supply with a 5/8 prescaler as reference." ]
            # [ inline ( always ) ]
            pub fn supply_five_eighths_prescaling(self) -> &'a mut W {
                self.variant(RefselW::SupplyFiveEighthsPrescaling)
            }
            # [ doc = "Use supply with a 6/8 prescaler as reference." ]
            # [ inline ( always ) ]
            pub fn supply_six_eighths_prescaling(self) -> &'a mut W {
                self.variant(RefselW::SupplySixEighthsPrescaling)
            }
            # [ doc = "Use supply with a 7/8 prescaler as reference." ]
            # [ inline ( always ) ]
            pub fn supply_seven_eighths_prescaling(self) -> &'a mut W {
                self.variant(RefselW::SupplySevenEighthsPrescaling)
            }
            # [ doc = "Use external analog reference as reference." ]
            # [ inline ( always ) ]
            pub fn aref(self) -> &'a mut W {
                self.variant(RefselW::Aref)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:2 - Reference select." ]
            # [ inline ( always ) ]
            pub fn refsel(&self) -> RefselR {
                RefselR::_from(
                    {
                        const MASK: u8 = 7;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:2 - Reference select." ]
            # [ inline ( always ) ]
            pub fn refsel(&mut self) -> _RefselW {
                _RefselW { w: self }
            }
        }
    }
    # [ doc = "External reference select." ]
    pub struct Extrefsel {
        register: VolatileCell<u32>,
    }
    # [ doc = "External reference select." ]
    pub mod extrefsel {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Extrefsel {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `EXTREFSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ExtrefselR {
            # [ doc = "Use analog reference 0 as reference." ]
            AnalogReference0,
            # [ doc = "Use analog reference 1 as reference." ]
            AnalogReference1,
        }
        impl ExtrefselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ExtrefselR::AnalogReference0 => 0,
                    ExtrefselR::AnalogReference1 => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ExtrefselR {
                match bits {
                    0 => ExtrefselR::AnalogReference0,
                    1 => ExtrefselR::AnalogReference1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `AnalogReference0`" ]
            # [ inline ( always ) ]
            pub fn is_analog_reference0(&self) -> bool {
                *self == ExtrefselR::AnalogReference0
            }
            # [ doc = "Checks if the value of the field is `AnalogReference1`" ]
            # [ inline ( always ) ]
            pub fn is_analog_reference1(&self) -> bool {
                *self == ExtrefselR::AnalogReference1
            }
        }
        # [ doc = "Values that can be written to the field `EXTREFSEL`" ]
        pub enum ExtrefselW {
            # [ doc = "Use analog reference 0 as reference." ]
            AnalogReference0,
            # [ doc = "Use analog reference 1 as reference." ]
            AnalogReference1,
        }
        impl ExtrefselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ExtrefselW::AnalogReference0 => 0,
                    ExtrefselW::AnalogReference1 => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ExtrefselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ExtrefselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: ExtrefselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Use analog reference 0 as reference." ]
            # [ inline ( always ) ]
            pub fn analog_reference0(self) -> &'a mut W {
                self.variant(ExtrefselW::AnalogReference0)
            }
            # [ doc = "Use analog reference 1 as reference." ]
            # [ inline ( always ) ]
            pub fn analog_reference1(self) -> &'a mut W {
                self.variant(ExtrefselW::AnalogReference1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - External analog reference pin selection." ]
            # [ inline ( always ) ]
            pub fn extrefsel(&self) -> ExtrefselR {
                ExtrefselR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - External analog reference pin selection." ]
            # [ inline ( always ) ]
            pub fn extrefsel(&mut self) -> _ExtrefselW {
                _ExtrefselW { w: self }
            }
        }
    }
    # [ doc = "Analog detect configuration." ]
    pub struct Anadetect {
        register: VolatileCell<u32>,
    }
    # [ doc = "Analog detect configuration." ]
    pub mod anadetect {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Anadetect {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ANADETECT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum AnadetectR {
            # [ doc = "Generate ANADETEC on crossing, both upwards and downwards crossing." ]
            Cross,
            # [ doc = "Generate ANADETEC on upwards crossing only." ]
            Up,
            # [ doc = "Generate ANADETEC on downwards crossing only." ]
            Down,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl AnadetectR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    AnadetectR::Cross => 0,
                    AnadetectR::Up => 1,
                    AnadetectR::Down => 2,
                    AnadetectR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> AnadetectR {
                match bits {
                    0 => AnadetectR::Cross,
                    1 => AnadetectR::Up,
                    2 => AnadetectR::Down,
                    i => AnadetectR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Cross`" ]
            # [ inline ( always ) ]
            pub fn is_cross(&self) -> bool {
                *self == AnadetectR::Cross
            }
            # [ doc = "Checks if the value of the field is `Up`" ]
            # [ inline ( always ) ]
            pub fn is_up(&self) -> bool {
                *self == AnadetectR::Up
            }
            # [ doc = "Checks if the value of the field is `Down`" ]
            # [ inline ( always ) ]
            pub fn is_down(&self) -> bool {
                *self == AnadetectR::Down
            }
        }
        # [ doc = "Values that can be written to the field `ANADETECT`" ]
        pub enum AnadetectW {
            # [ doc = "Generate ANADETEC on crossing, both upwards and downwards crossing." ]
            Cross,
            # [ doc = "Generate ANADETEC on upwards crossing only." ]
            Up,
            # [ doc = "Generate ANADETEC on downwards crossing only." ]
            Down,
        }
        impl AnadetectW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AnadetectW::Cross => 0,
                    AnadetectW::Up => 1,
                    AnadetectW::Down => 2,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AnadetectW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AnadetectW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: AnadetectW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Generate ANADETEC on crossing, both upwards and downwards crossing." ]
            # [ inline ( always ) ]
            pub fn cross(self) -> &'a mut W {
                self.variant(AnadetectW::Cross)
            }
            # [ doc = "Generate ANADETEC on upwards crossing only." ]
            # [ inline ( always ) ]
            pub fn up(self) -> &'a mut W {
                self.variant(AnadetectW::Up)
            }
            # [ doc = "Generate ANADETEC on downwards crossing only." ]
            # [ inline ( always ) ]
            pub fn down(self) -> &'a mut W {
                self.variant(AnadetectW::Down)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - Analog detect configuration." ]
            # [ inline ( always ) ]
            pub fn anadetect(&self) -> AnadetectR {
                AnadetectR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - Analog detect configuration." ]
            # [ inline ( always ) ]
            pub fn anadetect(&mut self) -> _AnadetectW {
                _AnadetectW { w: self }
            }
        }
    }
    # [ doc = "Peripheral power control." ]
    pub struct Power {
        register: VolatileCell<u32>,
    }
    # [ doc = "Peripheral power control." ]
    pub mod power {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Power {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `POWER`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PowerR {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PowerR::Disabled => 0,
                    PowerR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PowerR {
                match bits {
                    0 => PowerR::Disabled,
                    1 => PowerR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PowerR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PowerR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `POWER`" ]
        pub enum PowerW {
            # [ doc = "Module power disabled." ]
            Disabled,
            # [ doc = "Module power enabled." ]
            Enabled,
        }
        impl PowerW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PowerW::Disabled => 0,
                    PowerW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PowerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PowerW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PowerW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Module power disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PowerW::Disabled)
            }
            # [ doc = "Module power enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PowerW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&self) -> PowerR {
                PowerR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral power control." ]
            # [ inline ( always ) ]
            pub fn power(&mut self) -> _PowerW {
                _PowerW { w: self }
            }
        }
    }
}
# [ doc = "Low power comparator." ]
pub struct Lpcomp {
    register_block: lpcomp::RegisterBlock,
}
impl Deref for Lpcomp {
    type Target = lpcomp::RegisterBlock;
    fn deref(&self) -> &lpcomp::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "SW Interrupts." ]
pub const SWI: Peripheral<Swi> = unsafe { Peripheral::new(1073823744) };
# [ doc = "SW Interrupts." ]
pub mod swi {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Unused." ]
        pub unused: Unused,
    }
    # [ doc = "Unused." ]
    pub struct Unused {
        register: VolatileCell<u32>,
    }
    # [ doc = "Unused." ]
    pub mod unused {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Unused {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
}
# [ doc = "SW Interrupts." ]
pub struct Swi {
    register_block: swi::RegisterBlock,
}
impl Deref for Swi {
    type Target = swi::RegisterBlock;
    fn deref(&self) -> &swi::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Non Volatile Memory Controller." ]
pub const NVMC: Peripheral<Nvmc> = unsafe { Peripheral::new(1073864704) };
# [ doc = "Non Volatile Memory Controller." ]
pub mod nvmc {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 1024usize],
        # [ doc = "0x400 - Ready flag." ]
        pub ready: Ready,
        _reserved1: [u8; 256usize],
        # [ doc = "0x504 - Configuration register." ]
        pub config: Config,
        # [ doc = "0x508 - Register for erasing a non-protected non-volatile memory page." ]
        pub erasepage: Erasepage,
        # [ doc = "0x50c - Register for erasing all non-volatile user memory." ]
        pub eraseall: Eraseall,
        # [ doc = "0x510 - Register for erasing a protected non-volatile memory page." ]
        pub erasepcr0: Erasepcr0,
        # [ doc = "0x514 - Register for start erasing User Information Congfiguration Registers." ]
        pub eraseuicr: Eraseuicr,
    }
    # [ doc = "Ready flag." ]
    pub struct Ready {
        register: VolatileCell<u32>,
    }
    # [ doc = "Ready flag." ]
    pub mod ready {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Ready {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = "Possible values of the field `READY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum ReadyR {
            # [ doc = "NVMC is busy (on-going write or erase operation)." ]
            Busy,
            # [ doc = "NVMC is ready." ]
            Ready,
        }
        impl ReadyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    ReadyR::Busy => 0,
                    ReadyR::Ready => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> ReadyR {
                match bits {
                    0 => ReadyR::Busy,
                    1 => ReadyR::Ready,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Busy`" ]
            # [ inline ( always ) ]
            pub fn is_busy(&self) -> bool {
                *self == ReadyR::Busy
            }
            # [ doc = "Checks if the value of the field is `Ready`" ]
            # [ inline ( always ) ]
            pub fn is_ready(&self) -> bool {
                *self == ReadyR::Ready
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - NVMC ready." ]
            # [ inline ( always ) ]
            pub fn ready(&self) -> ReadyR {
                ReadyR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
    }
    # [ doc = "Configuration register." ]
    pub struct Config {
        register: VolatileCell<u32>,
    }
    # [ doc = "Configuration register." ]
    pub mod config {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Config {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `WEN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum WenR {
            # [ doc = "Read only access." ]
            Ren,
            # [ doc = "Write enabled." ]
            Wen,
            # [ doc = "Erase enabled." ]
            Een,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl WenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    WenR::Ren => 0,
                    WenR::Wen => 1,
                    WenR::Een => 2,
                    WenR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> WenR {
                match bits {
                    0 => WenR::Ren,
                    1 => WenR::Wen,
                    2 => WenR::Een,
                    i => WenR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Ren`" ]
            # [ inline ( always ) ]
            pub fn is_ren(&self) -> bool {
                *self == WenR::Ren
            }
            # [ doc = "Checks if the value of the field is `Wen`" ]
            # [ inline ( always ) ]
            pub fn is_wen(&self) -> bool {
                *self == WenR::Wen
            }
            # [ doc = "Checks if the value of the field is `Een`" ]
            # [ inline ( always ) ]
            pub fn is_een(&self) -> bool {
                *self == WenR::Een
            }
        }
        # [ doc = "Values that can be written to the field `WEN`" ]
        pub enum WenW {
            # [ doc = "Read only access." ]
            Ren,
            # [ doc = "Write enabled." ]
            Wen,
            # [ doc = "Erase enabled." ]
            Een,
        }
        impl WenW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WenW::Ren => 0,
                    WenW::Wen => 1,
                    WenW::Een => 2,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: WenW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Read only access." ]
            # [ inline ( always ) ]
            pub fn ren(self) -> &'a mut W {
                self.variant(WenW::Ren)
            }
            # [ doc = "Write enabled." ]
            # [ inline ( always ) ]
            pub fn wen(self) -> &'a mut W {
                self.variant(WenW::Wen)
            }
            # [ doc = "Erase enabled." ]
            # [ inline ( always ) ]
            pub fn een(self) -> &'a mut W {
                self.variant(WenW::Een)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - Program write enable." ]
            # [ inline ( always ) ]
            pub fn wen(&self) -> WenR {
                WenR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - Program write enable." ]
            # [ inline ( always ) ]
            pub fn wen(&mut self) -> _WenW {
                _WenW { w: self }
            }
        }
    }
    # [ doc = "Register for erasing a non-protected non-volatile memory page." ]
    pub struct Erasepage {
        register: VolatileCell<u32>,
    }
    # [ doc = "Register for erasing a non-protected non-volatile memory page." ]
    pub mod erasepage {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Erasepage {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Register for erasing a non-protected non-volatile memory page." ]
    pub struct Erasepcr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Register for erasing a non-protected non-volatile memory page." ]
    pub mod erasepcr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Erasepcr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Register for erasing all non-volatile user memory." ]
    pub struct Eraseall {
        register: VolatileCell<u32>,
    }
    # [ doc = "Register for erasing all non-volatile user memory." ]
    pub mod eraseall {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Eraseall {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ERASEALL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EraseallR {
            # [ doc = "No operation." ]
            NoOperation,
            # [ doc = "Start chip erase." ]
            Erase,
        }
        impl EraseallR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EraseallR::NoOperation => 0,
                    EraseallR::Erase => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EraseallR {
                match bits {
                    0 => EraseallR::NoOperation,
                    1 => EraseallR::Erase,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NoOperation`" ]
            # [ inline ( always ) ]
            pub fn is_no_operation(&self) -> bool {
                *self == EraseallR::NoOperation
            }
            # [ doc = "Checks if the value of the field is `Erase`" ]
            # [ inline ( always ) ]
            pub fn is_erase(&self) -> bool {
                *self == EraseallR::Erase
            }
        }
        # [ doc = "Values that can be written to the field `ERASEALL`" ]
        pub enum EraseallW {
            # [ doc = "No operation." ]
            NoOperation,
            # [ doc = "Start chip erase." ]
            Erase,
        }
        impl EraseallW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EraseallW::NoOperation => 0,
                    EraseallW::Erase => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EraseallW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EraseallW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EraseallW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "No operation." ]
            # [ inline ( always ) ]
            pub fn no_operation(self) -> &'a mut W {
                self.variant(EraseallW::NoOperation)
            }
            # [ doc = "Start chip erase." ]
            # [ inline ( always ) ]
            pub fn erase(self) -> &'a mut W {
                self.variant(EraseallW::Erase)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Starts the erasing of all user NVM (code region 0/1 and UICR registers)." ]
            # [ inline ( always ) ]
            pub fn eraseall(&self) -> EraseallR {
                EraseallR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Starts the erasing of all user NVM (code region 0/1 and UICR registers)." ]
            # [ inline ( always ) ]
            pub fn eraseall(&mut self) -> _EraseallW {
                _EraseallW { w: self }
            }
        }
    }
    # [ doc = "Register for erasing a protected non-volatile memory page." ]
    pub struct Erasepcr0 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Register for erasing a protected non-volatile memory page." ]
    pub mod erasepcr0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Erasepcr0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Register for start erasing User Information Congfiguration Registers." ]
    pub struct Eraseuicr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Register for start erasing User Information Congfiguration Registers." ]
    pub mod eraseuicr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Eraseuicr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ERASEUICR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum EraseuicrR {
            # [ doc = "No operation." ]
            NoOperation,
            # [ doc = "Start UICR erase." ]
            Erase,
        }
        impl EraseuicrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    EraseuicrR::NoOperation => 0,
                    EraseuicrR::Erase => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> EraseuicrR {
                match bits {
                    0 => EraseuicrR::NoOperation,
                    1 => EraseuicrR::Erase,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NoOperation`" ]
            # [ inline ( always ) ]
            pub fn is_no_operation(&self) -> bool {
                *self == EraseuicrR::NoOperation
            }
            # [ doc = "Checks if the value of the field is `Erase`" ]
            # [ inline ( always ) ]
            pub fn is_erase(&self) -> bool {
                *self == EraseuicrR::Erase
            }
        }
        # [ doc = "Values that can be written to the field `ERASEUICR`" ]
        pub enum EraseuicrW {
            # [ doc = "No operation." ]
            NoOperation,
            # [ doc = "Start UICR erase." ]
            Erase,
        }
        impl EraseuicrW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EraseuicrW::NoOperation => 0,
                    EraseuicrW::Erase => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EraseuicrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EraseuicrW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: EraseuicrW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "No operation." ]
            # [ inline ( always ) ]
            pub fn no_operation(self) -> &'a mut W {
                self.variant(EraseuicrW::NoOperation)
            }
            # [ doc = "Start UICR erase." ]
            # [ inline ( always ) ]
            pub fn erase(self) -> &'a mut W {
                self.variant(EraseuicrW::Erase)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - It can only be used when all contents of code region 1 are erased." ]
            # [ inline ( always ) ]
            pub fn eraseuicr(&self) -> EraseuicrR {
                EraseuicrR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - It can only be used when all contents of code region 1 are erased." ]
            # [ inline ( always ) ]
            pub fn eraseuicr(&mut self) -> _EraseuicrW {
                _EraseuicrW { w: self }
            }
        }
    }
}
# [ doc = "Non Volatile Memory Controller." ]
pub struct Nvmc {
    register_block: nvmc::RegisterBlock,
}
impl Deref for Nvmc {
    type Target = nvmc::RegisterBlock;
    fn deref(&self) -> &nvmc::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "PPI controller." ]
pub const PPI: Peripheral<Ppi> = unsafe { Peripheral::new(1073868800) };
# [ doc = "PPI controller." ]
pub mod ppi {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 1280usize],
        # [ doc = "0x500 - Channel enable." ]
        pub chen: Chen,
        # [ doc = "0x504 - Channel enable set." ]
        pub chenset: Chenset,
        # [ doc = "0x508 - Channel enable clear." ]
        pub chenclr: Chenclr,
        _reserved1: [u8; 756usize],
        # [ doc = "0x800 - Channel group configuration." ]
        pub chg0: Chg,
        # [ doc = "0x804 - Channel group configuration." ]
        pub chg1: Chg,
        # [ doc = "0x808 - Channel group configuration." ]
        pub chg2: Chg,
        # [ doc = "0x80c - Channel group configuration." ]
        pub chg3: Chg,
    }
    # [ doc = "Channel enable." ]
    pub struct Chen {
        register: VolatileCell<u32>,
    }
    # [ doc = "Channel enable." ]
    pub mod chen {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Chen {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `CH0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch0R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch0R::Disabled => 0,
                    Ch0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch0R {
                match bits {
                    0 => Ch0R::Disabled,
                    1 => Ch0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch1R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch1R::Disabled => 0,
                    Ch1R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch1R {
                match bits {
                    0 => Ch1R::Disabled,
                    1 => Ch1R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch1R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch1R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch2R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch2R::Disabled => 0,
                    Ch2R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch2R {
                match bits {
                    0 => Ch2R::Disabled,
                    1 => Ch2R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch2R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch2R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch3R {
            # [ doc = "Channel disabled" ]
            Disabled,
            # [ doc = "Channel enabled" ]
            Enabled,
        }
        impl Ch3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch3R::Disabled => 0,
                    Ch3R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch3R {
                match bits {
                    0 => Ch3R::Disabled,
                    1 => Ch3R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch3R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch3R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH4`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch4R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch4R::Disabled => 0,
                    Ch4R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch4R {
                match bits {
                    0 => Ch4R::Disabled,
                    1 => Ch4R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch4R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch4R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH5`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch5R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch5R::Disabled => 0,
                    Ch5R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch5R {
                match bits {
                    0 => Ch5R::Disabled,
                    1 => Ch5R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch5R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch5R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH6`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch6R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch6R::Disabled => 0,
                    Ch6R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch6R {
                match bits {
                    0 => Ch6R::Disabled,
                    1 => Ch6R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch6R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch6R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH7`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch7R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch7R::Disabled => 0,
                    Ch7R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch7R {
                match bits {
                    0 => Ch7R::Disabled,
                    1 => Ch7R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch7R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch7R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH8`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch8R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch8R::Disabled => 0,
                    Ch8R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch8R {
                match bits {
                    0 => Ch8R::Disabled,
                    1 => Ch8R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch8R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch8R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH9`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch9R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch9R::Disabled => 0,
                    Ch9R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch9R {
                match bits {
                    0 => Ch9R::Disabled,
                    1 => Ch9R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch9R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch9R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH10`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch10R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch10R::Disabled => 0,
                    Ch10R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch10R {
                match bits {
                    0 => Ch10R::Disabled,
                    1 => Ch10R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch10R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch10R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH11`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch11R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch11R::Disabled => 0,
                    Ch11R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch11R {
                match bits {
                    0 => Ch11R::Disabled,
                    1 => Ch11R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch11R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch11R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH12`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch12R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch12R::Disabled => 0,
                    Ch12R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch12R {
                match bits {
                    0 => Ch12R::Disabled,
                    1 => Ch12R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch12R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch12R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH13`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch13R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch13R::Disabled => 0,
                    Ch13R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch13R {
                match bits {
                    0 => Ch13R::Disabled,
                    1 => Ch13R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch13R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch13R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH14`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch14R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch14R::Disabled => 0,
                    Ch14R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch14R {
                match bits {
                    0 => Ch14R::Disabled,
                    1 => Ch14R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch14R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch14R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH15`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch15R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch15R::Disabled => 0,
                    Ch15R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch15R {
                match bits {
                    0 => Ch15R::Disabled,
                    1 => Ch15R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch15R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch15R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH20`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch20R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch20R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch20R::Disabled => 0,
                    Ch20R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch20R {
                match bits {
                    0 => Ch20R::Disabled,
                    1 => Ch20R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch20R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch20R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH21`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch21R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch21R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch21R::Disabled => 0,
                    Ch21R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch21R {
                match bits {
                    0 => Ch21R::Disabled,
                    1 => Ch21R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch21R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch21R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH22`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch22R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch22R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch22R::Disabled => 0,
                    Ch22R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch22R {
                match bits {
                    0 => Ch22R::Disabled,
                    1 => Ch22R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch22R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch22R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH23`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch23R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch23R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch23R::Disabled => 0,
                    Ch23R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch23R {
                match bits {
                    0 => Ch23R::Disabled,
                    1 => Ch23R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch23R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch23R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH24`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch24R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch24R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch24R::Disabled => 0,
                    Ch24R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch24R {
                match bits {
                    0 => Ch24R::Disabled,
                    1 => Ch24R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch24R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch24R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH25`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch25R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch25R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch25R::Disabled => 0,
                    Ch25R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch25R {
                match bits {
                    0 => Ch25R::Disabled,
                    1 => Ch25R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch25R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch25R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH26`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch26R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch26R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch26R::Disabled => 0,
                    Ch26R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch26R {
                match bits {
                    0 => Ch26R::Disabled,
                    1 => Ch26R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch26R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch26R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH27`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch27R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch27R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch27R::Disabled => 0,
                    Ch27R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch27R {
                match bits {
                    0 => Ch27R::Disabled,
                    1 => Ch27R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch27R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch27R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH28`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch28R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch28R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch28R::Disabled => 0,
                    Ch28R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch28R {
                match bits {
                    0 => Ch28R::Disabled,
                    1 => Ch28R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch28R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch28R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH29`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch29R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch29R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch29R::Disabled => 0,
                    Ch29R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch29R {
                match bits {
                    0 => Ch29R::Disabled,
                    1 => Ch29R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch29R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch29R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH30`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch30R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch30R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch30R::Disabled => 0,
                    Ch30R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch30R {
                match bits {
                    0 => Ch30R::Disabled,
                    1 => Ch30R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch30R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch30R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH31`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch31R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch31R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch31R::Disabled => 0,
                    Ch31R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch31R {
                match bits {
                    0 => Ch31R::Disabled,
                    1 => Ch31R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch31R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch31R::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `CH0`" ]
        pub enum Ch0W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch0W::Disabled => 0,
                    Ch0W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch0W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH1`" ]
        pub enum Ch1W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch1W::Disabled => 0,
                    Ch1W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch1W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch1W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH2`" ]
        pub enum Ch2W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch2W::Disabled => 0,
                    Ch2W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch2W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch2W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH3`" ]
        pub enum Ch3W {
            # [ doc = "Channel disabled" ]
            Disabled,
            # [ doc = "Channel enabled" ]
            Enabled,
        }
        impl Ch3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch3W::Disabled => 0,
                    Ch3W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled" ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch3W::Disabled)
            }
            # [ doc = "Channel enabled" ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch3W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH4`" ]
        pub enum Ch4W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch4W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch4W::Disabled => 0,
                    Ch4W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch4W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch4W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH5`" ]
        pub enum Ch5W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch5W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch5W::Disabled => 0,
                    Ch5W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch5W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch5W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH6`" ]
        pub enum Ch6W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch6W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch6W::Disabled => 0,
                    Ch6W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch6W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch6W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH7`" ]
        pub enum Ch7W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch7W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch7W::Disabled => 0,
                    Ch7W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch7W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch7W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH8`" ]
        pub enum Ch8W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch8W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch8W::Disabled => 0,
                    Ch8W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch8W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch8W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch8W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH9`" ]
        pub enum Ch9W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch9W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch9W::Disabled => 0,
                    Ch9W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch9W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch9W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch9W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH10`" ]
        pub enum Ch10W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch10W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch10W::Disabled => 0,
                    Ch10W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch10W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch10W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch10W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH11`" ]
        pub enum Ch11W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch11W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch11W::Disabled => 0,
                    Ch11W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch11W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch11W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch11W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH12`" ]
        pub enum Ch12W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch12W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch12W::Disabled => 0,
                    Ch12W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch12W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch12W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch12W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH13`" ]
        pub enum Ch13W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch13W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch13W::Disabled => 0,
                    Ch13W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch13W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch13W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch13W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH14`" ]
        pub enum Ch14W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch14W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch14W::Disabled => 0,
                    Ch14W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch14W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch14W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch14W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH15`" ]
        pub enum Ch15W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch15W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch15W::Disabled => 0,
                    Ch15W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch15W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch15W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch15W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH20`" ]
        pub enum Ch20W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch20W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch20W::Disabled => 0,
                    Ch20W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch20W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch20W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch20W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch20W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH21`" ]
        pub enum Ch21W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch21W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch21W::Disabled => 0,
                    Ch21W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch21W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch21W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch21W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch21W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH22`" ]
        pub enum Ch22W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch22W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch22W::Disabled => 0,
                    Ch22W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch22W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch22W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch22W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch22W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH23`" ]
        pub enum Ch23W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch23W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch23W::Disabled => 0,
                    Ch23W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch23W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch23W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch23W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch23W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH24`" ]
        pub enum Ch24W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch24W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch24W::Disabled => 0,
                    Ch24W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch24W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch24W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch24W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch24W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH25`" ]
        pub enum Ch25W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch25W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch25W::Disabled => 0,
                    Ch25W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch25W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch25W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch25W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch25W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH26`" ]
        pub enum Ch26W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch26W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch26W::Disabled => 0,
                    Ch26W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch26W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch26W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch26W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch26W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH27`" ]
        pub enum Ch27W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch27W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch27W::Disabled => 0,
                    Ch27W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch27W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch27W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch27W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch27W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH28`" ]
        pub enum Ch28W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch28W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch28W::Disabled => 0,
                    Ch28W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch28W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch28W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch28W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch28W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH29`" ]
        pub enum Ch29W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch29W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch29W::Disabled => 0,
                    Ch29W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch29W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch29W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch29W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch29W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH30`" ]
        pub enum Ch30W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch30W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch30W::Disabled => 0,
                    Ch30W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch30W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch30W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch30W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch30W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH31`" ]
        pub enum Ch31W {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch31W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch31W::Disabled => 0,
                    Ch31W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch31W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch31W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Ch31W::Disabled)
            }
            # [ doc = "Channel enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Ch31W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable PPI channel 0." ]
            # [ inline ( always ) ]
            pub fn ch0(&self) -> Ch0R {
                Ch0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Enable PPI channel 1." ]
            # [ inline ( always ) ]
            pub fn ch1(&self) -> Ch1R {
                Ch1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Enable PPI channel 2." ]
            # [ inline ( always ) ]
            pub fn ch2(&self) -> Ch2R {
                Ch2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Enable PPI channel 3." ]
            # [ inline ( always ) ]
            pub fn ch3(&self) -> Ch3R {
                Ch3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Enable PPI channel 4." ]
            # [ inline ( always ) ]
            pub fn ch4(&self) -> Ch4R {
                Ch4R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Enable PPI channel 5." ]
            # [ inline ( always ) ]
            pub fn ch5(&self) -> Ch5R {
                Ch5R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Enable PPI channel 6." ]
            # [ inline ( always ) ]
            pub fn ch6(&self) -> Ch6R {
                Ch6R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Enable PPI channel 7." ]
            # [ inline ( always ) ]
            pub fn ch7(&self) -> Ch7R {
                Ch7R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Enable PPI channel 8." ]
            # [ inline ( always ) ]
            pub fn ch8(&self) -> Ch8R {
                Ch8R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Enable PPI channel 9." ]
            # [ inline ( always ) ]
            pub fn ch9(&self) -> Ch9R {
                Ch9R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Enable PPI channel 10." ]
            # [ inline ( always ) ]
            pub fn ch10(&self) -> Ch10R {
                Ch10R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 11 - Enable PPI channel 11." ]
            # [ inline ( always ) ]
            pub fn ch11(&self) -> Ch11R {
                Ch11R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 12 - Enable PPI channel 12." ]
            # [ inline ( always ) ]
            pub fn ch12(&self) -> Ch12R {
                Ch12R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 13 - Enable PPI channel 13." ]
            # [ inline ( always ) ]
            pub fn ch13(&self) -> Ch13R {
                Ch13R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 13;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 14 - Enable PPI channel 14." ]
            # [ inline ( always ) ]
            pub fn ch14(&self) -> Ch14R {
                Ch14R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 15 - Enable PPI channel 15." ]
            # [ inline ( always ) ]
            pub fn ch15(&self) -> Ch15R {
                Ch15R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 15;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 20 - Enable PPI channel 20." ]
            # [ inline ( always ) ]
            pub fn ch20(&self) -> Ch20R {
                Ch20R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 20;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 21 - Enable PPI channel 21." ]
            # [ inline ( always ) ]
            pub fn ch21(&self) -> Ch21R {
                Ch21R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 21;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 22 - Enable PPI channel 22." ]
            # [ inline ( always ) ]
            pub fn ch22(&self) -> Ch22R {
                Ch22R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 22;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 23 - Enable PPI channel 23." ]
            # [ inline ( always ) ]
            pub fn ch23(&self) -> Ch23R {
                Ch23R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 23;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 24 - Enable PPI channel 24." ]
            # [ inline ( always ) ]
            pub fn ch24(&self) -> Ch24R {
                Ch24R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 24;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 25 - Enable PPI channel 25." ]
            # [ inline ( always ) ]
            pub fn ch25(&self) -> Ch25R {
                Ch25R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 25;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 26 - Enable PPI channel 26." ]
            # [ inline ( always ) ]
            pub fn ch26(&self) -> Ch26R {
                Ch26R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 26;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 27 - Enable PPI channel 27." ]
            # [ inline ( always ) ]
            pub fn ch27(&self) -> Ch27R {
                Ch27R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 27;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 28 - Enable PPI channel 28." ]
            # [ inline ( always ) ]
            pub fn ch28(&self) -> Ch28R {
                Ch28R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 28;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 29 - Enable PPI channel 29." ]
            # [ inline ( always ) ]
            pub fn ch29(&self) -> Ch29R {
                Ch29R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 29;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 30 - Enable PPI channel 30." ]
            # [ inline ( always ) ]
            pub fn ch30(&self) -> Ch30R {
                Ch30R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 30;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 31 - Enable PPI channel 31." ]
            # [ inline ( always ) ]
            pub fn ch31(&self) -> Ch31R {
                Ch31R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable PPI channel 0." ]
            # [ inline ( always ) ]
            pub fn ch0(&mut self) -> _Ch0W {
                _Ch0W { w: self }
            }
            # [ doc = "Bit 1 - Enable PPI channel 1." ]
            # [ inline ( always ) ]
            pub fn ch1(&mut self) -> _Ch1W {
                _Ch1W { w: self }
            }
            # [ doc = "Bit 2 - Enable PPI channel 2." ]
            # [ inline ( always ) ]
            pub fn ch2(&mut self) -> _Ch2W {
                _Ch2W { w: self }
            }
            # [ doc = "Bit 3 - Enable PPI channel 3." ]
            # [ inline ( always ) ]
            pub fn ch3(&mut self) -> _Ch3W {
                _Ch3W { w: self }
            }
            # [ doc = "Bit 4 - Enable PPI channel 4." ]
            # [ inline ( always ) ]
            pub fn ch4(&mut self) -> _Ch4W {
                _Ch4W { w: self }
            }
            # [ doc = "Bit 5 - Enable PPI channel 5." ]
            # [ inline ( always ) ]
            pub fn ch5(&mut self) -> _Ch5W {
                _Ch5W { w: self }
            }
            # [ doc = "Bit 6 - Enable PPI channel 6." ]
            # [ inline ( always ) ]
            pub fn ch6(&mut self) -> _Ch6W {
                _Ch6W { w: self }
            }
            # [ doc = "Bit 7 - Enable PPI channel 7." ]
            # [ inline ( always ) ]
            pub fn ch7(&mut self) -> _Ch7W {
                _Ch7W { w: self }
            }
            # [ doc = "Bit 8 - Enable PPI channel 8." ]
            # [ inline ( always ) ]
            pub fn ch8(&mut self) -> _Ch8W {
                _Ch8W { w: self }
            }
            # [ doc = "Bit 9 - Enable PPI channel 9." ]
            # [ inline ( always ) ]
            pub fn ch9(&mut self) -> _Ch9W {
                _Ch9W { w: self }
            }
            # [ doc = "Bit 10 - Enable PPI channel 10." ]
            # [ inline ( always ) ]
            pub fn ch10(&mut self) -> _Ch10W {
                _Ch10W { w: self }
            }
            # [ doc = "Bit 11 - Enable PPI channel 11." ]
            # [ inline ( always ) ]
            pub fn ch11(&mut self) -> _Ch11W {
                _Ch11W { w: self }
            }
            # [ doc = "Bit 12 - Enable PPI channel 12." ]
            # [ inline ( always ) ]
            pub fn ch12(&mut self) -> _Ch12W {
                _Ch12W { w: self }
            }
            # [ doc = "Bit 13 - Enable PPI channel 13." ]
            # [ inline ( always ) ]
            pub fn ch13(&mut self) -> _Ch13W {
                _Ch13W { w: self }
            }
            # [ doc = "Bit 14 - Enable PPI channel 14." ]
            # [ inline ( always ) ]
            pub fn ch14(&mut self) -> _Ch14W {
                _Ch14W { w: self }
            }
            # [ doc = "Bit 15 - Enable PPI channel 15." ]
            # [ inline ( always ) ]
            pub fn ch15(&mut self) -> _Ch15W {
                _Ch15W { w: self }
            }
            # [ doc = "Bit 20 - Enable PPI channel 20." ]
            # [ inline ( always ) ]
            pub fn ch20(&mut self) -> _Ch20W {
                _Ch20W { w: self }
            }
            # [ doc = "Bit 21 - Enable PPI channel 21." ]
            # [ inline ( always ) ]
            pub fn ch21(&mut self) -> _Ch21W {
                _Ch21W { w: self }
            }
            # [ doc = "Bit 22 - Enable PPI channel 22." ]
            # [ inline ( always ) ]
            pub fn ch22(&mut self) -> _Ch22W {
                _Ch22W { w: self }
            }
            # [ doc = "Bit 23 - Enable PPI channel 23." ]
            # [ inline ( always ) ]
            pub fn ch23(&mut self) -> _Ch23W {
                _Ch23W { w: self }
            }
            # [ doc = "Bit 24 - Enable PPI channel 24." ]
            # [ inline ( always ) ]
            pub fn ch24(&mut self) -> _Ch24W {
                _Ch24W { w: self }
            }
            # [ doc = "Bit 25 - Enable PPI channel 25." ]
            # [ inline ( always ) ]
            pub fn ch25(&mut self) -> _Ch25W {
                _Ch25W { w: self }
            }
            # [ doc = "Bit 26 - Enable PPI channel 26." ]
            # [ inline ( always ) ]
            pub fn ch26(&mut self) -> _Ch26W {
                _Ch26W { w: self }
            }
            # [ doc = "Bit 27 - Enable PPI channel 27." ]
            # [ inline ( always ) ]
            pub fn ch27(&mut self) -> _Ch27W {
                _Ch27W { w: self }
            }
            # [ doc = "Bit 28 - Enable PPI channel 28." ]
            # [ inline ( always ) ]
            pub fn ch28(&mut self) -> _Ch28W {
                _Ch28W { w: self }
            }
            # [ doc = "Bit 29 - Enable PPI channel 29." ]
            # [ inline ( always ) ]
            pub fn ch29(&mut self) -> _Ch29W {
                _Ch29W { w: self }
            }
            # [ doc = "Bit 30 - Enable PPI channel 30." ]
            # [ inline ( always ) ]
            pub fn ch30(&mut self) -> _Ch30W {
                _Ch30W { w: self }
            }
            # [ doc = "Bit 31 - Enable PPI channel 31." ]
            # [ inline ( always ) ]
            pub fn ch31(&mut self) -> _Ch31W {
                _Ch31W { w: self }
            }
        }
    }
    # [ doc = "Channel enable set." ]
    pub struct Chenset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Channel enable set." ]
    pub mod chenset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Chenset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `CH0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch0R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch0R::Disabled => 0,
                    Ch0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch0R {
                match bits {
                    0 => Ch0R::Disabled,
                    1 => Ch0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch1R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch1R::Disabled => 0,
                    Ch1R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch1R {
                match bits {
                    0 => Ch1R::Disabled,
                    1 => Ch1R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch1R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch1R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch2R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch2R::Disabled => 0,
                    Ch2R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch2R {
                match bits {
                    0 => Ch2R::Disabled,
                    1 => Ch2R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch2R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch2R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch3R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch3R::Disabled => 0,
                    Ch3R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch3R {
                match bits {
                    0 => Ch3R::Disabled,
                    1 => Ch3R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch3R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch3R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH4`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch4R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch4R::Disabled => 0,
                    Ch4R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch4R {
                match bits {
                    0 => Ch4R::Disabled,
                    1 => Ch4R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch4R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch4R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH5`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch5R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch5R::Disabled => 0,
                    Ch5R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch5R {
                match bits {
                    0 => Ch5R::Disabled,
                    1 => Ch5R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch5R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch5R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH6`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch6R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch6R::Disabled => 0,
                    Ch6R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch6R {
                match bits {
                    0 => Ch6R::Disabled,
                    1 => Ch6R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch6R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch6R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH7`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch7R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch7R::Disabled => 0,
                    Ch7R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch7R {
                match bits {
                    0 => Ch7R::Disabled,
                    1 => Ch7R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch7R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch7R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH8`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch8R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch8R::Disabled => 0,
                    Ch8R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch8R {
                match bits {
                    0 => Ch8R::Disabled,
                    1 => Ch8R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch8R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch8R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH9`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch9R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch9R::Disabled => 0,
                    Ch9R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch9R {
                match bits {
                    0 => Ch9R::Disabled,
                    1 => Ch9R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch9R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch9R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH10`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch10R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch10R::Disabled => 0,
                    Ch10R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch10R {
                match bits {
                    0 => Ch10R::Disabled,
                    1 => Ch10R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch10R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch10R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH11`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch11R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch11R::Disabled => 0,
                    Ch11R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch11R {
                match bits {
                    0 => Ch11R::Disabled,
                    1 => Ch11R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch11R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch11R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH12`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch12R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch12R::Disabled => 0,
                    Ch12R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch12R {
                match bits {
                    0 => Ch12R::Disabled,
                    1 => Ch12R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch12R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch12R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH13`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch13R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch13R::Disabled => 0,
                    Ch13R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch13R {
                match bits {
                    0 => Ch13R::Disabled,
                    1 => Ch13R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch13R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch13R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH14`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch14R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch14R::Disabled => 0,
                    Ch14R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch14R {
                match bits {
                    0 => Ch14R::Disabled,
                    1 => Ch14R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch14R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch14R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH15`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch15R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch15R::Disabled => 0,
                    Ch15R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch15R {
                match bits {
                    0 => Ch15R::Disabled,
                    1 => Ch15R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch15R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch15R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH20`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch20R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch20R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch20R::Disabled => 0,
                    Ch20R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch20R {
                match bits {
                    0 => Ch20R::Disabled,
                    1 => Ch20R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch20R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch20R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH21`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch21R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch21R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch21R::Disabled => 0,
                    Ch21R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch21R {
                match bits {
                    0 => Ch21R::Disabled,
                    1 => Ch21R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch21R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch21R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH22`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch22R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch22R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch22R::Disabled => 0,
                    Ch22R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch22R {
                match bits {
                    0 => Ch22R::Disabled,
                    1 => Ch22R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch22R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch22R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH23`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch23R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch23R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch23R::Disabled => 0,
                    Ch23R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch23R {
                match bits {
                    0 => Ch23R::Disabled,
                    1 => Ch23R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch23R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch23R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH24`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch24R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch24R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch24R::Disabled => 0,
                    Ch24R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch24R {
                match bits {
                    0 => Ch24R::Disabled,
                    1 => Ch24R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch24R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch24R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH25`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch25R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch25R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch25R::Disabled => 0,
                    Ch25R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch25R {
                match bits {
                    0 => Ch25R::Disabled,
                    1 => Ch25R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch25R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch25R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH26`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch26R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch26R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch26R::Disabled => 0,
                    Ch26R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch26R {
                match bits {
                    0 => Ch26R::Disabled,
                    1 => Ch26R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch26R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch26R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH27`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch27R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch27R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch27R::Disabled => 0,
                    Ch27R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch27R {
                match bits {
                    0 => Ch27R::Disabled,
                    1 => Ch27R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch27R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch27R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH28`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch28R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch28R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch28R::Disabled => 0,
                    Ch28R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch28R {
                match bits {
                    0 => Ch28R::Disabled,
                    1 => Ch28R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch28R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch28R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH29`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch29R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch29R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch29R::Disabled => 0,
                    Ch29R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch29R {
                match bits {
                    0 => Ch29R::Disabled,
                    1 => Ch29R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch29R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch29R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH30`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch30R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch30R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch30R::Disabled => 0,
                    Ch30R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch30R {
                match bits {
                    0 => Ch30R::Disabled,
                    1 => Ch30R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch30R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch30R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH31`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch31R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch31R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch31R::Disabled => 0,
                    Ch31R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch31R {
                match bits {
                    0 => Ch31R::Disabled,
                    1 => Ch31R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch31R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch31R::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `CH0`" ]
        pub enum Ch0W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch0W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH1`" ]
        pub enum Ch1W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch1W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch1W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH2`" ]
        pub enum Ch2W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch2W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch2W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH3`" ]
        pub enum Ch3W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch3W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch3W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH4`" ]
        pub enum Ch4W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch4W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch4W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch4W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch4W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH5`" ]
        pub enum Ch5W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch5W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch5W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch5W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch5W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH6`" ]
        pub enum Ch6W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch6W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch6W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch6W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch6W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH7`" ]
        pub enum Ch7W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch7W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch7W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch7W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch7W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH8`" ]
        pub enum Ch8W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch8W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch8W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch8W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch8W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH9`" ]
        pub enum Ch9W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch9W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch9W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch9W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch9W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH10`" ]
        pub enum Ch10W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch10W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch10W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch10W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch10W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH11`" ]
        pub enum Ch11W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch11W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch11W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch11W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch11W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH12`" ]
        pub enum Ch12W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch12W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch12W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch12W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch12W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH13`" ]
        pub enum Ch13W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch13W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch13W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch13W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch13W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH14`" ]
        pub enum Ch14W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch14W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch14W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch14W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch14W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH15`" ]
        pub enum Ch15W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch15W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch15W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch15W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch15W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH20`" ]
        pub enum Ch20W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch20W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch20W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch20W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch20W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch20W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH21`" ]
        pub enum Ch21W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch21W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch21W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch21W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch21W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch21W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH22`" ]
        pub enum Ch22W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch22W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch22W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch22W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch22W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch22W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH23`" ]
        pub enum Ch23W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch23W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch23W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch23W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch23W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch23W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH24`" ]
        pub enum Ch24W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch24W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch24W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch24W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch24W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch24W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH25`" ]
        pub enum Ch25W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch25W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch25W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch25W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch25W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch25W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH26`" ]
        pub enum Ch26W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch26W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch26W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch26W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch26W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch26W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH27`" ]
        pub enum Ch27W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch27W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch27W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch27W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch27W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch27W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH28`" ]
        pub enum Ch28W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch28W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch28W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch28W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch28W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch28W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH29`" ]
        pub enum Ch29W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch29W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch29W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch29W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch29W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch29W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH30`" ]
        pub enum Ch30W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch30W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch30W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch30W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch30W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch30W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH31`" ]
        pub enum Ch31W {
            # [ doc = "Enable channel on write." ]
            Set,
        }
        impl Ch31W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch31W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch31W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch31W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Enable channel on write." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Ch31W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable PPI channel 0." ]
            # [ inline ( always ) ]
            pub fn ch0(&self) -> Ch0R {
                Ch0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Enable PPI channel 1." ]
            # [ inline ( always ) ]
            pub fn ch1(&self) -> Ch1R {
                Ch1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Enable PPI channel 2." ]
            # [ inline ( always ) ]
            pub fn ch2(&self) -> Ch2R {
                Ch2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Enable PPI channel 3." ]
            # [ inline ( always ) ]
            pub fn ch3(&self) -> Ch3R {
                Ch3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Enable PPI channel 4." ]
            # [ inline ( always ) ]
            pub fn ch4(&self) -> Ch4R {
                Ch4R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Enable PPI channel 5." ]
            # [ inline ( always ) ]
            pub fn ch5(&self) -> Ch5R {
                Ch5R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Enable PPI channel 6." ]
            # [ inline ( always ) ]
            pub fn ch6(&self) -> Ch6R {
                Ch6R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Enable PPI channel 7." ]
            # [ inline ( always ) ]
            pub fn ch7(&self) -> Ch7R {
                Ch7R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Enable PPI channel 8." ]
            # [ inline ( always ) ]
            pub fn ch8(&self) -> Ch8R {
                Ch8R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Enable PPI channel 9." ]
            # [ inline ( always ) ]
            pub fn ch9(&self) -> Ch9R {
                Ch9R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Enable PPI channel 10." ]
            # [ inline ( always ) ]
            pub fn ch10(&self) -> Ch10R {
                Ch10R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 11 - Enable PPI channel 11." ]
            # [ inline ( always ) ]
            pub fn ch11(&self) -> Ch11R {
                Ch11R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 12 - Enable PPI channel 12." ]
            # [ inline ( always ) ]
            pub fn ch12(&self) -> Ch12R {
                Ch12R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 13 - Enable PPI channel 13." ]
            # [ inline ( always ) ]
            pub fn ch13(&self) -> Ch13R {
                Ch13R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 13;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 14 - Enable PPI channel 14." ]
            # [ inline ( always ) ]
            pub fn ch14(&self) -> Ch14R {
                Ch14R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 15 - Enable PPI channel 15." ]
            # [ inline ( always ) ]
            pub fn ch15(&self) -> Ch15R {
                Ch15R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 15;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 20 - Enable PPI channel 20." ]
            # [ inline ( always ) ]
            pub fn ch20(&self) -> Ch20R {
                Ch20R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 20;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 21 - Enable PPI channel 21." ]
            # [ inline ( always ) ]
            pub fn ch21(&self) -> Ch21R {
                Ch21R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 21;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 22 - Enable PPI channel 22." ]
            # [ inline ( always ) ]
            pub fn ch22(&self) -> Ch22R {
                Ch22R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 22;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 23 - Enable PPI channel 23." ]
            # [ inline ( always ) ]
            pub fn ch23(&self) -> Ch23R {
                Ch23R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 23;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 24 - Enable PPI channel 24." ]
            # [ inline ( always ) ]
            pub fn ch24(&self) -> Ch24R {
                Ch24R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 24;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 25 - Enable PPI channel 25." ]
            # [ inline ( always ) ]
            pub fn ch25(&self) -> Ch25R {
                Ch25R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 25;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 26 - Enable PPI channel 26." ]
            # [ inline ( always ) ]
            pub fn ch26(&self) -> Ch26R {
                Ch26R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 26;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 27 - Enable PPI channel 27." ]
            # [ inline ( always ) ]
            pub fn ch27(&self) -> Ch27R {
                Ch27R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 27;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 28 - Enable PPI channel 28." ]
            # [ inline ( always ) ]
            pub fn ch28(&self) -> Ch28R {
                Ch28R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 28;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 29 - Enable PPI channel 29." ]
            # [ inline ( always ) ]
            pub fn ch29(&self) -> Ch29R {
                Ch29R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 29;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 30 - Enable PPI channel 30." ]
            # [ inline ( always ) ]
            pub fn ch30(&self) -> Ch30R {
                Ch30R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 30;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 31 - Enable PPI channel 31." ]
            # [ inline ( always ) ]
            pub fn ch31(&self) -> Ch31R {
                Ch31R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable PPI channel 0." ]
            # [ inline ( always ) ]
            pub fn ch0(&mut self) -> _Ch0W {
                _Ch0W { w: self }
            }
            # [ doc = "Bit 1 - Enable PPI channel 1." ]
            # [ inline ( always ) ]
            pub fn ch1(&mut self) -> _Ch1W {
                _Ch1W { w: self }
            }
            # [ doc = "Bit 2 - Enable PPI channel 2." ]
            # [ inline ( always ) ]
            pub fn ch2(&mut self) -> _Ch2W {
                _Ch2W { w: self }
            }
            # [ doc = "Bit 3 - Enable PPI channel 3." ]
            # [ inline ( always ) ]
            pub fn ch3(&mut self) -> _Ch3W {
                _Ch3W { w: self }
            }
            # [ doc = "Bit 4 - Enable PPI channel 4." ]
            # [ inline ( always ) ]
            pub fn ch4(&mut self) -> _Ch4W {
                _Ch4W { w: self }
            }
            # [ doc = "Bit 5 - Enable PPI channel 5." ]
            # [ inline ( always ) ]
            pub fn ch5(&mut self) -> _Ch5W {
                _Ch5W { w: self }
            }
            # [ doc = "Bit 6 - Enable PPI channel 6." ]
            # [ inline ( always ) ]
            pub fn ch6(&mut self) -> _Ch6W {
                _Ch6W { w: self }
            }
            # [ doc = "Bit 7 - Enable PPI channel 7." ]
            # [ inline ( always ) ]
            pub fn ch7(&mut self) -> _Ch7W {
                _Ch7W { w: self }
            }
            # [ doc = "Bit 8 - Enable PPI channel 8." ]
            # [ inline ( always ) ]
            pub fn ch8(&mut self) -> _Ch8W {
                _Ch8W { w: self }
            }
            # [ doc = "Bit 9 - Enable PPI channel 9." ]
            # [ inline ( always ) ]
            pub fn ch9(&mut self) -> _Ch9W {
                _Ch9W { w: self }
            }
            # [ doc = "Bit 10 - Enable PPI channel 10." ]
            # [ inline ( always ) ]
            pub fn ch10(&mut self) -> _Ch10W {
                _Ch10W { w: self }
            }
            # [ doc = "Bit 11 - Enable PPI channel 11." ]
            # [ inline ( always ) ]
            pub fn ch11(&mut self) -> _Ch11W {
                _Ch11W { w: self }
            }
            # [ doc = "Bit 12 - Enable PPI channel 12." ]
            # [ inline ( always ) ]
            pub fn ch12(&mut self) -> _Ch12W {
                _Ch12W { w: self }
            }
            # [ doc = "Bit 13 - Enable PPI channel 13." ]
            # [ inline ( always ) ]
            pub fn ch13(&mut self) -> _Ch13W {
                _Ch13W { w: self }
            }
            # [ doc = "Bit 14 - Enable PPI channel 14." ]
            # [ inline ( always ) ]
            pub fn ch14(&mut self) -> _Ch14W {
                _Ch14W { w: self }
            }
            # [ doc = "Bit 15 - Enable PPI channel 15." ]
            # [ inline ( always ) ]
            pub fn ch15(&mut self) -> _Ch15W {
                _Ch15W { w: self }
            }
            # [ doc = "Bit 20 - Enable PPI channel 20." ]
            # [ inline ( always ) ]
            pub fn ch20(&mut self) -> _Ch20W {
                _Ch20W { w: self }
            }
            # [ doc = "Bit 21 - Enable PPI channel 21." ]
            # [ inline ( always ) ]
            pub fn ch21(&mut self) -> _Ch21W {
                _Ch21W { w: self }
            }
            # [ doc = "Bit 22 - Enable PPI channel 22." ]
            # [ inline ( always ) ]
            pub fn ch22(&mut self) -> _Ch22W {
                _Ch22W { w: self }
            }
            # [ doc = "Bit 23 - Enable PPI channel 23." ]
            # [ inline ( always ) ]
            pub fn ch23(&mut self) -> _Ch23W {
                _Ch23W { w: self }
            }
            # [ doc = "Bit 24 - Enable PPI channel 24." ]
            # [ inline ( always ) ]
            pub fn ch24(&mut self) -> _Ch24W {
                _Ch24W { w: self }
            }
            # [ doc = "Bit 25 - Enable PPI channel 25." ]
            # [ inline ( always ) ]
            pub fn ch25(&mut self) -> _Ch25W {
                _Ch25W { w: self }
            }
            # [ doc = "Bit 26 - Enable PPI channel 26." ]
            # [ inline ( always ) ]
            pub fn ch26(&mut self) -> _Ch26W {
                _Ch26W { w: self }
            }
            # [ doc = "Bit 27 - Enable PPI channel 27." ]
            # [ inline ( always ) ]
            pub fn ch27(&mut self) -> _Ch27W {
                _Ch27W { w: self }
            }
            # [ doc = "Bit 28 - Enable PPI channel 28." ]
            # [ inline ( always ) ]
            pub fn ch28(&mut self) -> _Ch28W {
                _Ch28W { w: self }
            }
            # [ doc = "Bit 29 - Enable PPI channel 29." ]
            # [ inline ( always ) ]
            pub fn ch29(&mut self) -> _Ch29W {
                _Ch29W { w: self }
            }
            # [ doc = "Bit 30 - Enable PPI channel 30." ]
            # [ inline ( always ) ]
            pub fn ch30(&mut self) -> _Ch30W {
                _Ch30W { w: self }
            }
            # [ doc = "Bit 31 - Enable PPI channel 31." ]
            # [ inline ( always ) ]
            pub fn ch31(&mut self) -> _Ch31W {
                _Ch31W { w: self }
            }
        }
    }
    # [ doc = "Channel enable clear." ]
    pub struct Chenclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Channel enable clear." ]
    pub mod chenclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Chenclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `CH0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch0R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch0R::Disabled => 0,
                    Ch0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch0R {
                match bits {
                    0 => Ch0R::Disabled,
                    1 => Ch0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch1R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch1R::Disabled => 0,
                    Ch1R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch1R {
                match bits {
                    0 => Ch1R::Disabled,
                    1 => Ch1R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch1R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch1R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch2R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch2R::Disabled => 0,
                    Ch2R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch2R {
                match bits {
                    0 => Ch2R::Disabled,
                    1 => Ch2R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch2R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch2R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch3R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch3R::Disabled => 0,
                    Ch3R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch3R {
                match bits {
                    0 => Ch3R::Disabled,
                    1 => Ch3R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch3R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch3R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH4`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch4R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch4R::Disabled => 0,
                    Ch4R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch4R {
                match bits {
                    0 => Ch4R::Disabled,
                    1 => Ch4R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch4R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch4R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH5`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch5R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch5R::Disabled => 0,
                    Ch5R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch5R {
                match bits {
                    0 => Ch5R::Disabled,
                    1 => Ch5R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch5R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch5R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH6`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch6R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch6R::Disabled => 0,
                    Ch6R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch6R {
                match bits {
                    0 => Ch6R::Disabled,
                    1 => Ch6R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch6R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch6R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH7`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch7R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch7R::Disabled => 0,
                    Ch7R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch7R {
                match bits {
                    0 => Ch7R::Disabled,
                    1 => Ch7R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch7R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch7R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH8`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch8R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch8R::Disabled => 0,
                    Ch8R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch8R {
                match bits {
                    0 => Ch8R::Disabled,
                    1 => Ch8R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch8R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch8R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH9`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch9R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch9R::Disabled => 0,
                    Ch9R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch9R {
                match bits {
                    0 => Ch9R::Disabled,
                    1 => Ch9R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch9R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch9R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH10`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch10R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch10R::Disabled => 0,
                    Ch10R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch10R {
                match bits {
                    0 => Ch10R::Disabled,
                    1 => Ch10R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch10R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch10R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH11`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch11R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch11R::Disabled => 0,
                    Ch11R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch11R {
                match bits {
                    0 => Ch11R::Disabled,
                    1 => Ch11R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch11R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch11R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH12`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch12R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch12R::Disabled => 0,
                    Ch12R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch12R {
                match bits {
                    0 => Ch12R::Disabled,
                    1 => Ch12R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch12R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch12R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH13`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch13R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch13R::Disabled => 0,
                    Ch13R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch13R {
                match bits {
                    0 => Ch13R::Disabled,
                    1 => Ch13R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch13R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch13R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH14`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch14R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch14R::Disabled => 0,
                    Ch14R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch14R {
                match bits {
                    0 => Ch14R::Disabled,
                    1 => Ch14R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch14R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch14R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH15`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch15R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch15R::Disabled => 0,
                    Ch15R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch15R {
                match bits {
                    0 => Ch15R::Disabled,
                    1 => Ch15R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch15R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch15R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH20`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch20R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch20R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch20R::Disabled => 0,
                    Ch20R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch20R {
                match bits {
                    0 => Ch20R::Disabled,
                    1 => Ch20R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch20R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch20R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH21`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch21R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch21R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch21R::Disabled => 0,
                    Ch21R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch21R {
                match bits {
                    0 => Ch21R::Disabled,
                    1 => Ch21R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch21R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch21R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH22`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch22R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch22R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch22R::Disabled => 0,
                    Ch22R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch22R {
                match bits {
                    0 => Ch22R::Disabled,
                    1 => Ch22R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch22R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch22R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH23`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch23R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch23R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch23R::Disabled => 0,
                    Ch23R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch23R {
                match bits {
                    0 => Ch23R::Disabled,
                    1 => Ch23R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch23R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch23R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH24`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch24R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch24R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch24R::Disabled => 0,
                    Ch24R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch24R {
                match bits {
                    0 => Ch24R::Disabled,
                    1 => Ch24R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch24R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch24R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH25`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch25R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch25R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch25R::Disabled => 0,
                    Ch25R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch25R {
                match bits {
                    0 => Ch25R::Disabled,
                    1 => Ch25R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch25R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch25R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH26`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch26R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch26R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch26R::Disabled => 0,
                    Ch26R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch26R {
                match bits {
                    0 => Ch26R::Disabled,
                    1 => Ch26R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch26R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch26R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH27`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch27R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch27R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch27R::Disabled => 0,
                    Ch27R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch27R {
                match bits {
                    0 => Ch27R::Disabled,
                    1 => Ch27R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch27R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch27R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH28`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch28R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch28R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch28R::Disabled => 0,
                    Ch28R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch28R {
                match bits {
                    0 => Ch28R::Disabled,
                    1 => Ch28R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch28R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch28R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH29`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch29R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch29R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch29R::Disabled => 0,
                    Ch29R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch29R {
                match bits {
                    0 => Ch29R::Disabled,
                    1 => Ch29R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch29R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch29R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH30`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch30R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch30R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch30R::Disabled => 0,
                    Ch30R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch30R {
                match bits {
                    0 => Ch30R::Disabled,
                    1 => Ch30R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch30R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch30R::Enabled
            }
        }
        # [ doc = "Possible values of the field `CH31`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch31R {
            # [ doc = "Channel disabled." ]
            Disabled,
            # [ doc = "Channel enabled." ]
            Enabled,
        }
        impl Ch31R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch31R::Disabled => 0,
                    Ch31R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch31R {
                match bits {
                    0 => Ch31R::Disabled,
                    1 => Ch31R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Ch31R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Ch31R::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `CH0`" ]
        pub enum Ch0W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch0W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch0W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH1`" ]
        pub enum Ch1W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch1W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch1W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH2`" ]
        pub enum Ch2W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch2W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch2W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH3`" ]
        pub enum Ch3W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch3W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch3W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH4`" ]
        pub enum Ch4W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch4W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch4W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch4W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch4W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH5`" ]
        pub enum Ch5W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch5W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch5W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch5W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch5W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH6`" ]
        pub enum Ch6W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch6W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch6W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch6W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch6W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH7`" ]
        pub enum Ch7W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch7W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch7W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch7W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch7W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH8`" ]
        pub enum Ch8W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch8W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch8W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch8W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch8W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH9`" ]
        pub enum Ch9W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch9W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch9W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch9W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch9W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH10`" ]
        pub enum Ch10W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch10W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch10W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch10W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch10W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH11`" ]
        pub enum Ch11W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch11W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch11W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch11W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch11W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH12`" ]
        pub enum Ch12W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch12W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch12W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch12W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch12W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH13`" ]
        pub enum Ch13W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch13W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch13W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch13W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch13W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH14`" ]
        pub enum Ch14W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch14W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch14W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch14W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch14W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH15`" ]
        pub enum Ch15W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch15W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch15W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch15W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch15W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH20`" ]
        pub enum Ch20W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch20W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch20W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch20W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch20W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch20W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH21`" ]
        pub enum Ch21W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch21W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch21W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch21W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch21W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch21W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH22`" ]
        pub enum Ch22W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch22W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch22W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch22W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch22W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch22W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH23`" ]
        pub enum Ch23W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch23W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch23W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch23W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch23W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch23W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH24`" ]
        pub enum Ch24W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch24W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch24W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch24W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch24W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch24W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH25`" ]
        pub enum Ch25W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch25W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch25W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch25W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch25W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch25W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH26`" ]
        pub enum Ch26W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch26W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch26W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch26W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch26W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch26W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH27`" ]
        pub enum Ch27W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch27W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch27W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch27W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch27W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch27W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH28`" ]
        pub enum Ch28W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch28W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch28W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch28W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch28W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch28W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH29`" ]
        pub enum Ch29W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch29W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch29W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch29W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch29W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch29W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH30`" ]
        pub enum Ch30W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch30W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch30W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch30W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch30W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch30W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH31`" ]
        pub enum Ch31W {
            # [ doc = "Disable channel on write." ]
            Clear,
        }
        impl Ch31W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch31W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch31W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch31W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disable channel on write." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Ch31W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable PPI channel 0." ]
            # [ inline ( always ) ]
            pub fn ch0(&self) -> Ch0R {
                Ch0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Disable PPI channel 1." ]
            # [ inline ( always ) ]
            pub fn ch1(&self) -> Ch1R {
                Ch1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Disable PPI channel 2." ]
            # [ inline ( always ) ]
            pub fn ch2(&self) -> Ch2R {
                Ch2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Disable PPI channel 3." ]
            # [ inline ( always ) ]
            pub fn ch3(&self) -> Ch3R {
                Ch3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Disable PPI channel 4." ]
            # [ inline ( always ) ]
            pub fn ch4(&self) -> Ch4R {
                Ch4R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Disable PPI channel 5." ]
            # [ inline ( always ) ]
            pub fn ch5(&self) -> Ch5R {
                Ch5R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Disable PPI channel 6." ]
            # [ inline ( always ) ]
            pub fn ch6(&self) -> Ch6R {
                Ch6R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Disable PPI channel 7." ]
            # [ inline ( always ) ]
            pub fn ch7(&self) -> Ch7R {
                Ch7R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Disable PPI channel 8." ]
            # [ inline ( always ) ]
            pub fn ch8(&self) -> Ch8R {
                Ch8R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Disable PPI channel 9." ]
            # [ inline ( always ) ]
            pub fn ch9(&self) -> Ch9R {
                Ch9R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Disable PPI channel 10." ]
            # [ inline ( always ) ]
            pub fn ch10(&self) -> Ch10R {
                Ch10R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 11 - Disable PPI channel 11." ]
            # [ inline ( always ) ]
            pub fn ch11(&self) -> Ch11R {
                Ch11R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 12 - Disable PPI channel 12." ]
            # [ inline ( always ) ]
            pub fn ch12(&self) -> Ch12R {
                Ch12R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 13 - Disable PPI channel 13." ]
            # [ inline ( always ) ]
            pub fn ch13(&self) -> Ch13R {
                Ch13R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 13;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 14 - Disable PPI channel 14." ]
            # [ inline ( always ) ]
            pub fn ch14(&self) -> Ch14R {
                Ch14R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 15 - Disable PPI channel 15." ]
            # [ inline ( always ) ]
            pub fn ch15(&self) -> Ch15R {
                Ch15R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 15;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 20 - Disable PPI channel 20." ]
            # [ inline ( always ) ]
            pub fn ch20(&self) -> Ch20R {
                Ch20R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 20;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 21 - Disable PPI channel 21." ]
            # [ inline ( always ) ]
            pub fn ch21(&self) -> Ch21R {
                Ch21R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 21;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 22 - Disable PPI channel 22." ]
            # [ inline ( always ) ]
            pub fn ch22(&self) -> Ch22R {
                Ch22R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 22;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 23 - Disable PPI channel 23." ]
            # [ inline ( always ) ]
            pub fn ch23(&self) -> Ch23R {
                Ch23R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 23;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 24 - Disable PPI channel 24." ]
            # [ inline ( always ) ]
            pub fn ch24(&self) -> Ch24R {
                Ch24R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 24;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 25 - Disable PPI channel 25." ]
            # [ inline ( always ) ]
            pub fn ch25(&self) -> Ch25R {
                Ch25R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 25;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 26 - Disable PPI channel 26." ]
            # [ inline ( always ) ]
            pub fn ch26(&self) -> Ch26R {
                Ch26R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 26;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 27 - Disable PPI channel 27." ]
            # [ inline ( always ) ]
            pub fn ch27(&self) -> Ch27R {
                Ch27R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 27;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 28 - Disable PPI channel 28." ]
            # [ inline ( always ) ]
            pub fn ch28(&self) -> Ch28R {
                Ch28R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 28;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 29 - Disable PPI channel 29." ]
            # [ inline ( always ) ]
            pub fn ch29(&self) -> Ch29R {
                Ch29R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 29;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 30 - Disable PPI channel 30." ]
            # [ inline ( always ) ]
            pub fn ch30(&self) -> Ch30R {
                Ch30R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 30;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 31 - Disable PPI channel 31." ]
            # [ inline ( always ) ]
            pub fn ch31(&self) -> Ch31R {
                Ch31R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable PPI channel 0." ]
            # [ inline ( always ) ]
            pub fn ch0(&mut self) -> _Ch0W {
                _Ch0W { w: self }
            }
            # [ doc = "Bit 1 - Disable PPI channel 1." ]
            # [ inline ( always ) ]
            pub fn ch1(&mut self) -> _Ch1W {
                _Ch1W { w: self }
            }
            # [ doc = "Bit 2 - Disable PPI channel 2." ]
            # [ inline ( always ) ]
            pub fn ch2(&mut self) -> _Ch2W {
                _Ch2W { w: self }
            }
            # [ doc = "Bit 3 - Disable PPI channel 3." ]
            # [ inline ( always ) ]
            pub fn ch3(&mut self) -> _Ch3W {
                _Ch3W { w: self }
            }
            # [ doc = "Bit 4 - Disable PPI channel 4." ]
            # [ inline ( always ) ]
            pub fn ch4(&mut self) -> _Ch4W {
                _Ch4W { w: self }
            }
            # [ doc = "Bit 5 - Disable PPI channel 5." ]
            # [ inline ( always ) ]
            pub fn ch5(&mut self) -> _Ch5W {
                _Ch5W { w: self }
            }
            # [ doc = "Bit 6 - Disable PPI channel 6." ]
            # [ inline ( always ) ]
            pub fn ch6(&mut self) -> _Ch6W {
                _Ch6W { w: self }
            }
            # [ doc = "Bit 7 - Disable PPI channel 7." ]
            # [ inline ( always ) ]
            pub fn ch7(&mut self) -> _Ch7W {
                _Ch7W { w: self }
            }
            # [ doc = "Bit 8 - Disable PPI channel 8." ]
            # [ inline ( always ) ]
            pub fn ch8(&mut self) -> _Ch8W {
                _Ch8W { w: self }
            }
            # [ doc = "Bit 9 - Disable PPI channel 9." ]
            # [ inline ( always ) ]
            pub fn ch9(&mut self) -> _Ch9W {
                _Ch9W { w: self }
            }
            # [ doc = "Bit 10 - Disable PPI channel 10." ]
            # [ inline ( always ) ]
            pub fn ch10(&mut self) -> _Ch10W {
                _Ch10W { w: self }
            }
            # [ doc = "Bit 11 - Disable PPI channel 11." ]
            # [ inline ( always ) ]
            pub fn ch11(&mut self) -> _Ch11W {
                _Ch11W { w: self }
            }
            # [ doc = "Bit 12 - Disable PPI channel 12." ]
            # [ inline ( always ) ]
            pub fn ch12(&mut self) -> _Ch12W {
                _Ch12W { w: self }
            }
            # [ doc = "Bit 13 - Disable PPI channel 13." ]
            # [ inline ( always ) ]
            pub fn ch13(&mut self) -> _Ch13W {
                _Ch13W { w: self }
            }
            # [ doc = "Bit 14 - Disable PPI channel 14." ]
            # [ inline ( always ) ]
            pub fn ch14(&mut self) -> _Ch14W {
                _Ch14W { w: self }
            }
            # [ doc = "Bit 15 - Disable PPI channel 15." ]
            # [ inline ( always ) ]
            pub fn ch15(&mut self) -> _Ch15W {
                _Ch15W { w: self }
            }
            # [ doc = "Bit 20 - Disable PPI channel 20." ]
            # [ inline ( always ) ]
            pub fn ch20(&mut self) -> _Ch20W {
                _Ch20W { w: self }
            }
            # [ doc = "Bit 21 - Disable PPI channel 21." ]
            # [ inline ( always ) ]
            pub fn ch21(&mut self) -> _Ch21W {
                _Ch21W { w: self }
            }
            # [ doc = "Bit 22 - Disable PPI channel 22." ]
            # [ inline ( always ) ]
            pub fn ch22(&mut self) -> _Ch22W {
                _Ch22W { w: self }
            }
            # [ doc = "Bit 23 - Disable PPI channel 23." ]
            # [ inline ( always ) ]
            pub fn ch23(&mut self) -> _Ch23W {
                _Ch23W { w: self }
            }
            # [ doc = "Bit 24 - Disable PPI channel 24." ]
            # [ inline ( always ) ]
            pub fn ch24(&mut self) -> _Ch24W {
                _Ch24W { w: self }
            }
            # [ doc = "Bit 25 - Disable PPI channel 25." ]
            # [ inline ( always ) ]
            pub fn ch25(&mut self) -> _Ch25W {
                _Ch25W { w: self }
            }
            # [ doc = "Bit 26 - Disable PPI channel 26." ]
            # [ inline ( always ) ]
            pub fn ch26(&mut self) -> _Ch26W {
                _Ch26W { w: self }
            }
            # [ doc = "Bit 27 - Disable PPI channel 27." ]
            # [ inline ( always ) ]
            pub fn ch27(&mut self) -> _Ch27W {
                _Ch27W { w: self }
            }
            # [ doc = "Bit 28 - Disable PPI channel 28." ]
            # [ inline ( always ) ]
            pub fn ch28(&mut self) -> _Ch28W {
                _Ch28W { w: self }
            }
            # [ doc = "Bit 29 - Disable PPI channel 29." ]
            # [ inline ( always ) ]
            pub fn ch29(&mut self) -> _Ch29W {
                _Ch29W { w: self }
            }
            # [ doc = "Bit 30 - Disable PPI channel 30." ]
            # [ inline ( always ) ]
            pub fn ch30(&mut self) -> _Ch30W {
                _Ch30W { w: self }
            }
            # [ doc = "Bit 31 - Disable PPI channel 31." ]
            # [ inline ( always ) ]
            pub fn ch31(&mut self) -> _Ch31W {
                _Ch31W { w: self }
            }
        }
    }
    # [ doc = "Channel group configuration." ]
    pub struct Chg {
        register: VolatileCell<u32>,
    }
    # [ doc = "Channel group configuration." ]
    pub mod chg {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Chg {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `CH0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch0R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch0R::Excluded => 0,
                    Ch0R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch0R {
                match bits {
                    0 => Ch0R::Excluded,
                    1 => Ch0R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch0R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch0R::Included
            }
        }
        # [ doc = "Possible values of the field `CH1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch1R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch1R::Excluded => 0,
                    Ch1R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch1R {
                match bits {
                    0 => Ch1R::Excluded,
                    1 => Ch1R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch1R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch1R::Included
            }
        }
        # [ doc = "Possible values of the field `CH2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch2R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch2R::Excluded => 0,
                    Ch2R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch2R {
                match bits {
                    0 => Ch2R::Excluded,
                    1 => Ch2R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch2R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch2R::Included
            }
        }
        # [ doc = "Possible values of the field `CH3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch3R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch3R::Excluded => 0,
                    Ch3R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch3R {
                match bits {
                    0 => Ch3R::Excluded,
                    1 => Ch3R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch3R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch3R::Included
            }
        }
        # [ doc = "Possible values of the field `CH4`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch4R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch4R::Excluded => 0,
                    Ch4R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch4R {
                match bits {
                    0 => Ch4R::Excluded,
                    1 => Ch4R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch4R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch4R::Included
            }
        }
        # [ doc = "Possible values of the field `CH5`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch5R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch5R::Excluded => 0,
                    Ch5R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch5R {
                match bits {
                    0 => Ch5R::Excluded,
                    1 => Ch5R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch5R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch5R::Included
            }
        }
        # [ doc = "Possible values of the field `CH6`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch6R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch6R::Excluded => 0,
                    Ch6R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch6R {
                match bits {
                    0 => Ch6R::Excluded,
                    1 => Ch6R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch6R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch6R::Included
            }
        }
        # [ doc = "Possible values of the field `CH7`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch7R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch7R::Excluded => 0,
                    Ch7R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch7R {
                match bits {
                    0 => Ch7R::Excluded,
                    1 => Ch7R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch7R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch7R::Included
            }
        }
        # [ doc = "Possible values of the field `CH8`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch8R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch8R::Excluded => 0,
                    Ch8R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch8R {
                match bits {
                    0 => Ch8R::Excluded,
                    1 => Ch8R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch8R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch8R::Included
            }
        }
        # [ doc = "Possible values of the field `CH9`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch9R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch9R::Excluded => 0,
                    Ch9R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch9R {
                match bits {
                    0 => Ch9R::Excluded,
                    1 => Ch9R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch9R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch9R::Included
            }
        }
        # [ doc = "Possible values of the field `CH10`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch10R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch10R::Excluded => 0,
                    Ch10R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch10R {
                match bits {
                    0 => Ch10R::Excluded,
                    1 => Ch10R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch10R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch10R::Included
            }
        }
        # [ doc = "Possible values of the field `CH11`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch11R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch11R::Excluded => 0,
                    Ch11R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch11R {
                match bits {
                    0 => Ch11R::Excluded,
                    1 => Ch11R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch11R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch11R::Included
            }
        }
        # [ doc = "Possible values of the field `CH12`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch12R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch12R::Excluded => 0,
                    Ch12R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch12R {
                match bits {
                    0 => Ch12R::Excluded,
                    1 => Ch12R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch12R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch12R::Included
            }
        }
        # [ doc = "Possible values of the field `CH13`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch13R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch13R::Excluded => 0,
                    Ch13R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch13R {
                match bits {
                    0 => Ch13R::Excluded,
                    1 => Ch13R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch13R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch13R::Included
            }
        }
        # [ doc = "Possible values of the field `CH14`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch14R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch14R::Excluded => 0,
                    Ch14R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch14R {
                match bits {
                    0 => Ch14R::Excluded,
                    1 => Ch14R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch14R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch14R::Included
            }
        }
        # [ doc = "Possible values of the field `CH15`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch15R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch15R::Excluded => 0,
                    Ch15R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch15R {
                match bits {
                    0 => Ch15R::Excluded,
                    1 => Ch15R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch15R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch15R::Included
            }
        }
        # [ doc = "Possible values of the field `CH20`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch20R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch20R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch20R::Excluded => 0,
                    Ch20R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch20R {
                match bits {
                    0 => Ch20R::Excluded,
                    1 => Ch20R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch20R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch20R::Included
            }
        }
        # [ doc = "Possible values of the field `CH21`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch21R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch21R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch21R::Excluded => 0,
                    Ch21R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch21R {
                match bits {
                    0 => Ch21R::Excluded,
                    1 => Ch21R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch21R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch21R::Included
            }
        }
        # [ doc = "Possible values of the field `CH22`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch22R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch22R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch22R::Excluded => 0,
                    Ch22R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch22R {
                match bits {
                    0 => Ch22R::Excluded,
                    1 => Ch22R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch22R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch22R::Included
            }
        }
        # [ doc = "Possible values of the field `CH23`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch23R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch23R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch23R::Excluded => 0,
                    Ch23R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch23R {
                match bits {
                    0 => Ch23R::Excluded,
                    1 => Ch23R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch23R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch23R::Included
            }
        }
        # [ doc = "Possible values of the field `CH24`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch24R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch24R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch24R::Excluded => 0,
                    Ch24R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch24R {
                match bits {
                    0 => Ch24R::Excluded,
                    1 => Ch24R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch24R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch24R::Included
            }
        }
        # [ doc = "Possible values of the field `CH25`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch25R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch25R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch25R::Excluded => 0,
                    Ch25R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch25R {
                match bits {
                    0 => Ch25R::Excluded,
                    1 => Ch25R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch25R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch25R::Included
            }
        }
        # [ doc = "Possible values of the field `CH26`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch26R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch26R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch26R::Excluded => 0,
                    Ch26R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch26R {
                match bits {
                    0 => Ch26R::Excluded,
                    1 => Ch26R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch26R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch26R::Included
            }
        }
        # [ doc = "Possible values of the field `CH27`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch27R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch27R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch27R::Excluded => 0,
                    Ch27R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch27R {
                match bits {
                    0 => Ch27R::Excluded,
                    1 => Ch27R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch27R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch27R::Included
            }
        }
        # [ doc = "Possible values of the field `CH28`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch28R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch28R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch28R::Excluded => 0,
                    Ch28R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch28R {
                match bits {
                    0 => Ch28R::Excluded,
                    1 => Ch28R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch28R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch28R::Included
            }
        }
        # [ doc = "Possible values of the field `CH29`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch29R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch29R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch29R::Excluded => 0,
                    Ch29R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch29R {
                match bits {
                    0 => Ch29R::Excluded,
                    1 => Ch29R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch29R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch29R::Included
            }
        }
        # [ doc = "Possible values of the field `CH30`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch30R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch30R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch30R::Excluded => 0,
                    Ch30R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch30R {
                match bits {
                    0 => Ch30R::Excluded,
                    1 => Ch30R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch30R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch30R::Included
            }
        }
        # [ doc = "Possible values of the field `CH31`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ch31R {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch31R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ch31R::Excluded => 0,
                    Ch31R::Included => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ch31R {
                match bits {
                    0 => Ch31R::Excluded,
                    1 => Ch31R::Included,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Excluded`" ]
            # [ inline ( always ) ]
            pub fn is_excluded(&self) -> bool {
                *self == Ch31R::Excluded
            }
            # [ doc = "Checks if the value of the field is `Included`" ]
            # [ inline ( always ) ]
            pub fn is_included(&self) -> bool {
                *self == Ch31R::Included
            }
        }
        # [ doc = "Values that can be written to the field `CH0`" ]
        pub enum Ch0W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch0W::Excluded => 0,
                    Ch0W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch0W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch0W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH1`" ]
        pub enum Ch1W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch1W::Excluded => 0,
                    Ch1W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch1W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch1W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH2`" ]
        pub enum Ch2W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch2W::Excluded => 0,
                    Ch2W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch2W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch2W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH3`" ]
        pub enum Ch3W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch3W::Excluded => 0,
                    Ch3W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch3W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch3W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH4`" ]
        pub enum Ch4W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch4W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch4W::Excluded => 0,
                    Ch4W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch4W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch4W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH5`" ]
        pub enum Ch5W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch5W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch5W::Excluded => 0,
                    Ch5W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch5W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch5W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH6`" ]
        pub enum Ch6W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch6W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch6W::Excluded => 0,
                    Ch6W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch6W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch6W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH7`" ]
        pub enum Ch7W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch7W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch7W::Excluded => 0,
                    Ch7W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch7W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch7W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH8`" ]
        pub enum Ch8W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch8W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch8W::Excluded => 0,
                    Ch8W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch8W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch8W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch8W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH9`" ]
        pub enum Ch9W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch9W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch9W::Excluded => 0,
                    Ch9W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch9W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch9W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch9W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH10`" ]
        pub enum Ch10W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch10W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch10W::Excluded => 0,
                    Ch10W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch10W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch10W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch10W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH11`" ]
        pub enum Ch11W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch11W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch11W::Excluded => 0,
                    Ch11W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch11W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch11W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch11W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH12`" ]
        pub enum Ch12W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch12W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch12W::Excluded => 0,
                    Ch12W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch12W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch12W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch12W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH13`" ]
        pub enum Ch13W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch13W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch13W::Excluded => 0,
                    Ch13W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch13W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch13W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch13W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH14`" ]
        pub enum Ch14W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch14W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch14W::Excluded => 0,
                    Ch14W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch14W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch14W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch14W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH15`" ]
        pub enum Ch15W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch15W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch15W::Excluded => 0,
                    Ch15W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch15W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch15W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch15W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH20`" ]
        pub enum Ch20W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch20W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch20W::Excluded => 0,
                    Ch20W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch20W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch20W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch20W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch20W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH21`" ]
        pub enum Ch21W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch21W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch21W::Excluded => 0,
                    Ch21W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch21W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch21W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch21W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch21W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH22`" ]
        pub enum Ch22W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch22W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch22W::Excluded => 0,
                    Ch22W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch22W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch22W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch22W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch22W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH23`" ]
        pub enum Ch23W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch23W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch23W::Excluded => 0,
                    Ch23W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch23W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch23W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch23W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch23W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH24`" ]
        pub enum Ch24W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch24W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch24W::Excluded => 0,
                    Ch24W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch24W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch24W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch24W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch24W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH25`" ]
        pub enum Ch25W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch25W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch25W::Excluded => 0,
                    Ch25W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch25W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch25W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch25W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch25W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH26`" ]
        pub enum Ch26W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch26W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch26W::Excluded => 0,
                    Ch26W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch26W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch26W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch26W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch26W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH27`" ]
        pub enum Ch27W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch27W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch27W::Excluded => 0,
                    Ch27W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch27W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch27W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch27W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch27W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH28`" ]
        pub enum Ch28W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch28W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch28W::Excluded => 0,
                    Ch28W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch28W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch28W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch28W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch28W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH29`" ]
        pub enum Ch29W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch29W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch29W::Excluded => 0,
                    Ch29W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch29W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch29W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch29W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch29W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH30`" ]
        pub enum Ch30W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch30W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch30W::Excluded => 0,
                    Ch30W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch30W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch30W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch30W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch30W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CH31`" ]
        pub enum Ch31W {
            # [ doc = "Channel excluded." ]
            Excluded,
            # [ doc = "Channel included." ]
            Included,
        }
        impl Ch31W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ch31W::Excluded => 0,
                    Ch31W::Included => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ch31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ch31W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ch31W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Channel excluded." ]
            # [ inline ( always ) ]
            pub fn excluded(self) -> &'a mut W {
                self.variant(Ch31W::Excluded)
            }
            # [ doc = "Channel included." ]
            # [ inline ( always ) ]
            pub fn included(self) -> &'a mut W {
                self.variant(Ch31W::Included)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Include CH0 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch0(&self) -> Ch0R {
                Ch0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Include CH1 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch1(&self) -> Ch1R {
                Ch1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Include CH2 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch2(&self) -> Ch2R {
                Ch2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Include CH3 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch3(&self) -> Ch3R {
                Ch3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Include CH4 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch4(&self) -> Ch4R {
                Ch4R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Include CH5 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch5(&self) -> Ch5R {
                Ch5R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Include CH6 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch6(&self) -> Ch6R {
                Ch6R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Include CH7 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch7(&self) -> Ch7R {
                Ch7R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Include CH8 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch8(&self) -> Ch8R {
                Ch8R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Include CH9 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch9(&self) -> Ch9R {
                Ch9R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Include CH10 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch10(&self) -> Ch10R {
                Ch10R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 11 - Include CH11 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch11(&self) -> Ch11R {
                Ch11R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 12 - Include CH12 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch12(&self) -> Ch12R {
                Ch12R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 13 - Include CH13 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch13(&self) -> Ch13R {
                Ch13R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 13;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 14 - Include CH14 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch14(&self) -> Ch14R {
                Ch14R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 15 - Include CH15 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch15(&self) -> Ch15R {
                Ch15R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 15;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 20 - Include CH20 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch20(&self) -> Ch20R {
                Ch20R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 20;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 21 - Include CH21 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch21(&self) -> Ch21R {
                Ch21R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 21;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 22 - Include CH22 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch22(&self) -> Ch22R {
                Ch22R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 22;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 23 - Include CH23 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch23(&self) -> Ch23R {
                Ch23R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 23;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 24 - Include CH24 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch24(&self) -> Ch24R {
                Ch24R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 24;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 25 - Include CH25 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch25(&self) -> Ch25R {
                Ch25R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 25;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 26 - Include CH26 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch26(&self) -> Ch26R {
                Ch26R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 26;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 27 - Include CH27 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch27(&self) -> Ch27R {
                Ch27R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 27;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 28 - Include CH28 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch28(&self) -> Ch28R {
                Ch28R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 28;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 29 - Include CH29 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch29(&self) -> Ch29R {
                Ch29R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 29;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 30 - Include CH30 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch30(&self) -> Ch30R {
                Ch30R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 30;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 31 - Include CH31 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch31(&self) -> Ch31R {
                Ch31R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Include CH0 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch0(&mut self) -> _Ch0W {
                _Ch0W { w: self }
            }
            # [ doc = "Bit 1 - Include CH1 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch1(&mut self) -> _Ch1W {
                _Ch1W { w: self }
            }
            # [ doc = "Bit 2 - Include CH2 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch2(&mut self) -> _Ch2W {
                _Ch2W { w: self }
            }
            # [ doc = "Bit 3 - Include CH3 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch3(&mut self) -> _Ch3W {
                _Ch3W { w: self }
            }
            # [ doc = "Bit 4 - Include CH4 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch4(&mut self) -> _Ch4W {
                _Ch4W { w: self }
            }
            # [ doc = "Bit 5 - Include CH5 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch5(&mut self) -> _Ch5W {
                _Ch5W { w: self }
            }
            # [ doc = "Bit 6 - Include CH6 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch6(&mut self) -> _Ch6W {
                _Ch6W { w: self }
            }
            # [ doc = "Bit 7 - Include CH7 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch7(&mut self) -> _Ch7W {
                _Ch7W { w: self }
            }
            # [ doc = "Bit 8 - Include CH8 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch8(&mut self) -> _Ch8W {
                _Ch8W { w: self }
            }
            # [ doc = "Bit 9 - Include CH9 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch9(&mut self) -> _Ch9W {
                _Ch9W { w: self }
            }
            # [ doc = "Bit 10 - Include CH10 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch10(&mut self) -> _Ch10W {
                _Ch10W { w: self }
            }
            # [ doc = "Bit 11 - Include CH11 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch11(&mut self) -> _Ch11W {
                _Ch11W { w: self }
            }
            # [ doc = "Bit 12 - Include CH12 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch12(&mut self) -> _Ch12W {
                _Ch12W { w: self }
            }
            # [ doc = "Bit 13 - Include CH13 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch13(&mut self) -> _Ch13W {
                _Ch13W { w: self }
            }
            # [ doc = "Bit 14 - Include CH14 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch14(&mut self) -> _Ch14W {
                _Ch14W { w: self }
            }
            # [ doc = "Bit 15 - Include CH15 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch15(&mut self) -> _Ch15W {
                _Ch15W { w: self }
            }
            # [ doc = "Bit 20 - Include CH20 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch20(&mut self) -> _Ch20W {
                _Ch20W { w: self }
            }
            # [ doc = "Bit 21 - Include CH21 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch21(&mut self) -> _Ch21W {
                _Ch21W { w: self }
            }
            # [ doc = "Bit 22 - Include CH22 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch22(&mut self) -> _Ch22W {
                _Ch22W { w: self }
            }
            # [ doc = "Bit 23 - Include CH23 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch23(&mut self) -> _Ch23W {
                _Ch23W { w: self }
            }
            # [ doc = "Bit 24 - Include CH24 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch24(&mut self) -> _Ch24W {
                _Ch24W { w: self }
            }
            # [ doc = "Bit 25 - Include CH25 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch25(&mut self) -> _Ch25W {
                _Ch25W { w: self }
            }
            # [ doc = "Bit 26 - Include CH26 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch26(&mut self) -> _Ch26W {
                _Ch26W { w: self }
            }
            # [ doc = "Bit 27 - Include CH27 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch27(&mut self) -> _Ch27W {
                _Ch27W { w: self }
            }
            # [ doc = "Bit 28 - Include CH28 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch28(&mut self) -> _Ch28W {
                _Ch28W { w: self }
            }
            # [ doc = "Bit 29 - Include CH29 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch29(&mut self) -> _Ch29W {
                _Ch29W { w: self }
            }
            # [ doc = "Bit 30 - Include CH30 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch30(&mut self) -> _Ch30W {
                _Ch30W { w: self }
            }
            # [ doc = "Bit 31 - Include CH31 in channel group." ]
            # [ inline ( always ) ]
            pub fn ch31(&mut self) -> _Ch31W {
                _Ch31W { w: self }
            }
        }
    }
}
# [ doc = "PPI controller." ]
pub struct Ppi {
    register_block: ppi::RegisterBlock,
}
impl Deref for Ppi {
    type Target = ppi::RegisterBlock;
    fn deref(&self) -> &ppi::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Factory Information Configuration." ]
pub const FICR: Peripheral<Ficr> = unsafe { Peripheral::new(268435456) };
# [ doc = "Factory Information Configuration." ]
pub mod ficr {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 16usize],
        # [ doc = "0x10 - Code memory page size in bytes." ]
        pub codepagesize: Codepagesize,
        # [ doc = "0x14 - Code memory size in pages." ]
        pub codesize: Codesize,
        _reserved1: [u8; 16usize],
        # [ doc = "0x28 - Length of code region 0 in bytes." ]
        pub clenr0: Clenr0,
        # [ doc = "0x2c - Pre-programmed factory code present." ]
        pub ppfc: Ppfc,
        _reserved2: [u8; 4usize],
        # [ doc = "0x34 - Number of individualy controllable RAM blocks." ]
        pub numramblock: Numramblock,
        # [ doc = "0x38 - Size of RAM blocks in bytes." ]
        pub sizeramblocks: Sizeramblocks,
        # [ doc = "0x3c - Deprecated array of size of RAM block in bytes. This name is kept for backward compatinility purposes. Use SIZERAMBLOCKS instead." ]
        pub sizeramblock1: Sizeramblock,
        # [ doc = "0x40 - Deprecated array of size of RAM block in bytes. This name is kept for backward compatinility purposes. Use SIZERAMBLOCKS instead." ]
        pub sizeramblock2: Sizeramblock,
        # [ doc = "0x44 - Deprecated array of size of RAM block in bytes. This name is kept for backward compatinility purposes. Use SIZERAMBLOCKS instead." ]
        pub sizeramblock3: Sizeramblock,
        _reserved3: [u8; 20usize],
        # [ doc = "0x5c - Configuration identifier." ]
        pub configid: Configid,
        # [ doc = "0x60 - Device identifier." ]
        pub deviceid0: Deviceid,
        # [ doc = "0x64 - Device identifier." ]
        pub deviceid1: Deviceid,
        _reserved4: [u8; 24usize],
        # [ doc = "0x80 - Encryption root." ]
        pub er0: Er,
        # [ doc = "0x84 - Encryption root." ]
        pub er1: Er,
        # [ doc = "0x88 - Encryption root." ]
        pub er2: Er,
        # [ doc = "0x8c - Encryption root." ]
        pub er3: Er,
        # [ doc = "0x90 - Identity root." ]
        pub ir0: Ir,
        # [ doc = "0x94 - Identity root." ]
        pub ir1: Ir,
        # [ doc = "0x98 - Identity root." ]
        pub ir2: Ir,
        # [ doc = "0x9c - Identity root." ]
        pub ir3: Ir,
        # [ doc = "0xa0 - Device address type." ]
        pub deviceaddrtype: Deviceaddrtype,
        # [ doc = "0xa4 - Device address." ]
        pub deviceaddr0: Deviceaddr,
        # [ doc = "0xa8 - Device address." ]
        pub deviceaddr1: Deviceaddr,
        # [ doc = "0xac - Radio calibration override enable." ]
        pub overrideen: Overrideen,
        # [ doc = "0xb0 - Override values for the OVERRIDEn registers in RADIO for NRF_1Mbit mode." ]
        pub nrf_1mbit0: Nrf1mbit,
        # [ doc = "0xb4 - Override values for the OVERRIDEn registers in RADIO for NRF_1Mbit mode." ]
        pub nrf_1mbit1: Nrf1mbit,
        # [ doc = "0xb8 - Override values for the OVERRIDEn registers in RADIO for NRF_1Mbit mode." ]
        pub nrf_1mbit2: Nrf1mbit,
        # [ doc = "0xbc - Override values for the OVERRIDEn registers in RADIO for NRF_1Mbit mode." ]
        pub nrf_1mbit3: Nrf1mbit,
        # [ doc = "0xc0 - Override values for the OVERRIDEn registers in RADIO for NRF_1Mbit mode." ]
        pub nrf_1mbit4: Nrf1mbit,
        _reserved5: [u8; 40usize],
        # [ doc = "0xec - Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit mode." ]
        pub ble_1mbit0: Ble1mbit,
        # [ doc = "0xf0 - Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit mode." ]
        pub ble_1mbit1: Ble1mbit,
        # [ doc = "0xf4 - Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit mode." ]
        pub ble_1mbit2: Ble1mbit,
        # [ doc = "0xf8 - Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit mode." ]
        pub ble_1mbit3: Ble1mbit,
        # [ doc = "0xfc - Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit mode." ]
        pub ble_1mbit4: Ble1mbit,
    }
    # [ doc = "Code memory page size in bytes." ]
    pub struct Codepagesize {
        register: VolatileCell<u32>,
    }
    # [ doc = "Code memory page size in bytes." ]
    pub mod codepagesize {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Codepagesize {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Code memory size in pages." ]
    pub struct Codesize {
        register: VolatileCell<u32>,
    }
    # [ doc = "Code memory size in pages." ]
    pub mod codesize {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Codesize {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Length of code region 0 in bytes." ]
    pub struct Clenr0 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Length of code region 0 in bytes." ]
    pub mod clenr0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Clenr0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Pre-programmed factory code present." ]
    pub struct Ppfc {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pre-programmed factory code present." ]
    pub mod ppfc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ppfc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `PPFC`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PpfcR {
            # [ doc = "Not present." ]
            NotPresent,
            # [ doc = "Present." ]
            Present,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl PpfcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PpfcR::NotPresent => 255,
                    PpfcR::Present => 0,
                    PpfcR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PpfcR {
                match bits {
                    255 => PpfcR::NotPresent,
                    0 => PpfcR::Present,
                    i => PpfcR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `NotPresent`" ]
            # [ inline ( always ) ]
            pub fn is_not_present(&self) -> bool {
                *self == PpfcR::NotPresent
            }
            # [ doc = "Checks if the value of the field is `Present`" ]
            # [ inline ( always ) ]
            pub fn is_present(&self) -> bool {
                *self == PpfcR::Present
            }
        }
        # [ doc = "Values that can be written to the field `PPFC`" ]
        pub enum PpfcW {
            # [ doc = "Not present." ]
            NotPresent,
            # [ doc = "Present." ]
            Present,
        }
        impl PpfcW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PpfcW::NotPresent => 255,
                    PpfcW::Present => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PpfcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PpfcW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PpfcW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Not present." ]
            # [ inline ( always ) ]
            pub fn not_present(self) -> &'a mut W {
                self.variant(PpfcW::NotPresent)
            }
            # [ doc = "Present." ]
            # [ inline ( always ) ]
            pub fn present(self) -> &'a mut W {
                self.variant(PpfcW::Present)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Pre-programmed factory code present." ]
            # [ inline ( always ) ]
            pub fn ppfc(&self) -> PpfcR {
                PpfcR::_from(
                    {
                        const MASK: u8 = 255;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Pre-programmed factory code present." ]
            # [ inline ( always ) ]
            pub fn ppfc(&mut self) -> _PpfcW {
                _PpfcW { w: self }
            }
        }
    }
    # [ doc = "Number of individualy controllable RAM blocks." ]
    pub struct Numramblock {
        register: VolatileCell<u32>,
    }
    # [ doc = "Number of individualy controllable RAM blocks." ]
    pub mod numramblock {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Numramblock {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Size of RAM blocks in bytes." ]
    pub struct Sizeramblocks {
        register: VolatileCell<u32>,
    }
    # [ doc = "Size of RAM blocks in bytes." ]
    pub mod sizeramblocks {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sizeramblocks {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Deprecated array of size of RAM block in bytes. This name is kept for backward compatinility purposes. Use SIZERAMBLOCKS instead." ]
    pub struct Sizeramblock {
        register: VolatileCell<u32>,
    }
    # [ doc = "Deprecated array of size of RAM block in bytes. This name is kept for backward compatinility purposes. Use SIZERAMBLOCKS instead." ]
    pub mod sizeramblock {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sizeramblock {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Configuration identifier." ]
    pub struct Configid {
        register: VolatileCell<u32>,
    }
    # [ doc = "Configuration identifier." ]
    pub mod configid {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Configid {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HwidR {
            bits: u16,
        }
        impl HwidR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct FwidR {
            bits: u16,
        }
        impl FwidR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HwidW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HwidW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FwidW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FwidW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Hardware Identification Number." ]
            # [ inline ( always ) ]
            pub fn hwid(&self) -> HwidR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                HwidR { bits }
            }
            # [ doc = "Bits 16:31 - Firmware Identification Number pre-loaded into the flash." ]
            # [ inline ( always ) ]
            pub fn fwid(&self) -> FwidR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                FwidR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Hardware Identification Number." ]
            # [ inline ( always ) ]
            pub fn hwid(&mut self) -> _HwidW {
                _HwidW { w: self }
            }
            # [ doc = "Bits 16:31 - Firmware Identification Number pre-loaded into the flash." ]
            # [ inline ( always ) ]
            pub fn fwid(&mut self) -> _FwidW {
                _FwidW { w: self }
            }
        }
    }
    # [ doc = "Device identifier." ]
    pub struct Deviceid {
        register: VolatileCell<u32>,
    }
    # [ doc = "Device identifier." ]
    pub mod deviceid {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Deviceid {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Encryption root." ]
    pub struct Er {
        register: VolatileCell<u32>,
    }
    # [ doc = "Encryption root." ]
    pub mod er {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Er {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Identity root." ]
    pub struct Ir {
        register: VolatileCell<u32>,
    }
    # [ doc = "Identity root." ]
    pub mod ir {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ir {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Device address type." ]
    pub struct Deviceaddrtype {
        register: VolatileCell<u32>,
    }
    # [ doc = "Device address type." ]
    pub mod deviceaddrtype {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Deviceaddrtype {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `DEVICEADDRTYPE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DeviceaddrtypeR {
            # [ doc = "Public address." ]
            Public,
            # [ doc = "Random address." ]
            Random,
        }
        impl DeviceaddrtypeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DeviceaddrtypeR::Public => 0,
                    DeviceaddrtypeR::Random => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DeviceaddrtypeR {
                match bits {
                    0 => DeviceaddrtypeR::Public,
                    1 => DeviceaddrtypeR::Random,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Public`" ]
            # [ inline ( always ) ]
            pub fn is_public(&self) -> bool {
                *self == DeviceaddrtypeR::Public
            }
            # [ doc = "Checks if the value of the field is `Random`" ]
            # [ inline ( always ) ]
            pub fn is_random(&self) -> bool {
                *self == DeviceaddrtypeR::Random
            }
        }
        # [ doc = "Values that can be written to the field `DEVICEADDRTYPE`" ]
        pub enum DeviceaddrtypeW {
            # [ doc = "Public address." ]
            Public,
            # [ doc = "Random address." ]
            Random,
        }
        impl DeviceaddrtypeW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DeviceaddrtypeW::Public => 0,
                    DeviceaddrtypeW::Random => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DeviceaddrtypeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DeviceaddrtypeW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DeviceaddrtypeW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Public address." ]
            # [ inline ( always ) ]
            pub fn public(self) -> &'a mut W {
                self.variant(DeviceaddrtypeW::Public)
            }
            # [ doc = "Random address." ]
            # [ inline ( always ) ]
            pub fn random(self) -> &'a mut W {
                self.variant(DeviceaddrtypeW::Random)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Device address type." ]
            # [ inline ( always ) ]
            pub fn deviceaddrtype(&self) -> DeviceaddrtypeR {
                DeviceaddrtypeR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Device address type." ]
            # [ inline ( always ) ]
            pub fn deviceaddrtype(&mut self) -> _DeviceaddrtypeW {
                _DeviceaddrtypeW { w: self }
            }
        }
    }
    # [ doc = "Device address." ]
    pub struct Deviceaddr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Device address." ]
    pub mod deviceaddr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Deviceaddr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio calibration override enable." ]
    pub struct Overrideen {
        register: VolatileCell<u32>,
    }
    # [ doc = "Radio calibration override enable." ]
    pub mod overrideen {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Overrideen {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `NRF_1MBIT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Nrf1mbitR {
            # [ doc = "Override the default values for NRF_1Mbit mode." ]
            Override,
            # [ doc = "Do not override the default values for NRF_1Mbit mode." ]
            NotOverride,
        }
        impl Nrf1mbitR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Nrf1mbitR::Override => 0,
                    Nrf1mbitR::NotOverride => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Nrf1mbitR {
                match bits {
                    0 => Nrf1mbitR::Override,
                    1 => Nrf1mbitR::NotOverride,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Override`" ]
            # [ inline ( always ) ]
            pub fn is_override_(&self) -> bool {
                *self == Nrf1mbitR::Override
            }
            # [ doc = "Checks if the value of the field is `NotOverride`" ]
            # [ inline ( always ) ]
            pub fn is_not_override(&self) -> bool {
                *self == Nrf1mbitR::NotOverride
            }
        }
        # [ doc = "Possible values of the field `BLE_1MBIT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Ble1mbitR {
            # [ doc = "Override the default values for BLE_1Mbit mode." ]
            Override,
            # [ doc = "Do not override the default values for BLE_1Mbit mode." ]
            NotOverride,
        }
        impl Ble1mbitR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Ble1mbitR::Override => 0,
                    Ble1mbitR::NotOverride => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Ble1mbitR {
                match bits {
                    0 => Ble1mbitR::Override,
                    1 => Ble1mbitR::NotOverride,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Override`" ]
            # [ inline ( always ) ]
            pub fn is_override_(&self) -> bool {
                *self == Ble1mbitR::Override
            }
            # [ doc = "Checks if the value of the field is `NotOverride`" ]
            # [ inline ( always ) ]
            pub fn is_not_override(&self) -> bool {
                *self == Ble1mbitR::NotOverride
            }
        }
        # [ doc = "Values that can be written to the field `NRF_1MBIT`" ]
        pub enum Nrf1mbitW {
            # [ doc = "Override the default values for NRF_1Mbit mode." ]
            Override,
            # [ doc = "Do not override the default values for NRF_1Mbit mode." ]
            NotOverride,
        }
        impl Nrf1mbitW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Nrf1mbitW::Override => 0,
                    Nrf1mbitW::NotOverride => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Nrf1mbitW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Nrf1mbitW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Nrf1mbitW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Override the default values for NRF_1Mbit mode." ]
            # [ inline ( always ) ]
            pub fn override_(self) -> &'a mut W {
                self.variant(Nrf1mbitW::Override)
            }
            # [ doc = "Do not override the default values for NRF_1Mbit mode." ]
            # [ inline ( always ) ]
            pub fn not_override(self) -> &'a mut W {
                self.variant(Nrf1mbitW::NotOverride)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BLE_1MBIT`" ]
        pub enum Ble1mbitW {
            # [ doc = "Override the default values for BLE_1Mbit mode." ]
            Override,
            # [ doc = "Do not override the default values for BLE_1Mbit mode." ]
            NotOverride,
        }
        impl Ble1mbitW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Ble1mbitW::Override => 0,
                    Ble1mbitW::NotOverride => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ble1mbitW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ble1mbitW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Ble1mbitW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Override the default values for BLE_1Mbit mode." ]
            # [ inline ( always ) ]
            pub fn override_(self) -> &'a mut W {
                self.variant(Ble1mbitW::Override)
            }
            # [ doc = "Do not override the default values for BLE_1Mbit mode." ]
            # [ inline ( always ) ]
            pub fn not_override(self) -> &'a mut W {
                self.variant(Ble1mbitW::NotOverride)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Override default values for NRF_1Mbit mode." ]
            # [ inline ( always ) ]
            pub fn nrf_1mbit(&self) -> Nrf1mbitR {
                Nrf1mbitR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Override default values for BLE_1Mbit mode." ]
            # [ inline ( always ) ]
            pub fn ble_1mbit(&self) -> Ble1mbitR {
                Ble1mbitR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Override default values for NRF_1Mbit mode." ]
            # [ inline ( always ) ]
            pub fn nrf_1mbit(&mut self) -> _Nrf1mbitW {
                _Nrf1mbitW { w: self }
            }
            # [ doc = "Bit 3 - Override default values for BLE_1Mbit mode." ]
            # [ inline ( always ) ]
            pub fn ble_1mbit(&mut self) -> _Ble1mbitW {
                _Ble1mbitW { w: self }
            }
        }
    }
    # [ doc = "Override values for the OVERRIDEn registers in RADIO for NRF_1Mbit mode." ]
    pub struct Nrf1mbit {
        register: VolatileCell<u32>,
    }
    # [ doc = "Override values for the OVERRIDEn registers in RADIO for NRF_1Mbit mode." ]
    pub mod nrf_1mbit {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Nrf1mbit {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit mode." ]
    pub struct Ble1mbit {
        register: VolatileCell<u32>,
    }
    # [ doc = "Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit mode." ]
    pub mod ble_1mbit {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ble1mbit {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
# [ doc = "Factory Information Configuration." ]
pub struct Ficr {
    register_block: ficr::RegisterBlock,
}
impl Deref for Ficr {
    type Target = ficr::RegisterBlock;
    fn deref(&self) -> &ficr::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "User Information Configuration." ]
pub const UICR: Peripheral<Uicr> = unsafe { Peripheral::new(268439552) };
# [ doc = "User Information Configuration." ]
pub mod uicr {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Length of code region 0." ]
        pub clenr0: Clenr0,
        # [ doc = "0x04 - Readback protection configuration." ]
        pub rbpconf: Rbpconf,
        # [ doc = "0x08 - Reset value for CLOCK XTALFREQ register." ]
        pub xtalfreq: Xtalfreq,
        _reserved0: [u8; 4usize],
        # [ doc = "0x10 - Firmware ID." ]
        pub fwid: Fwid,
        # [ doc = "0x14 - Bootloader start address." ]
        pub bootloaderaddr: Bootloaderaddr,
        # [ doc = "0x18 - Reserved for Nordic firmware design." ]
        pub nrffw1: Nrffw,
        # [ doc = "0x1c - Reserved for Nordic firmware design." ]
        pub nrffw2: Nrffw,
        # [ doc = "0x20 - Reserved for Nordic firmware design." ]
        pub nrffw3: Nrffw,
        # [ doc = "0x24 - Reserved for Nordic firmware design." ]
        pub nrffw4: Nrffw,
        # [ doc = "0x28 - Reserved for Nordic firmware design." ]
        pub nrffw5: Nrffw,
        # [ doc = "0x2c - Reserved for Nordic firmware design." ]
        pub nrffw6: Nrffw,
        # [ doc = "0x30 - Reserved for Nordic firmware design." ]
        pub nrffw7: Nrffw,
        # [ doc = "0x34 - Reserved for Nordic firmware design." ]
        pub nrffw8: Nrffw,
        # [ doc = "0x38 - Reserved for Nordic firmware design." ]
        pub nrffw9: Nrffw,
        # [ doc = "0x3c - Reserved for Nordic firmware design." ]
        pub nrffw10: Nrffw,
        # [ doc = "0x40 - Reserved for Nordic firmware design." ]
        pub nrffw11: Nrffw,
        # [ doc = "0x44 - Reserved for Nordic firmware design." ]
        pub nrffw12: Nrffw,
        # [ doc = "0x48 - Reserved for Nordic firmware design." ]
        pub nrffw13: Nrffw,
        # [ doc = "0x4c - Reserved for Nordic firmware design." ]
        pub nrffw14: Nrffw,
        # [ doc = "0x50 - Reserved for Nordic hardware design." ]
        pub nrfhw0: Nrfhw,
        # [ doc = "0x54 - Reserved for Nordic hardware design." ]
        pub nrfhw1: Nrfhw,
        # [ doc = "0x58 - Reserved for Nordic hardware design." ]
        pub nrfhw2: Nrfhw,
        # [ doc = "0x5c - Reserved for Nordic hardware design." ]
        pub nrfhw3: Nrfhw,
        # [ doc = "0x60 - Reserved for Nordic hardware design." ]
        pub nrfhw4: Nrfhw,
        # [ doc = "0x64 - Reserved for Nordic hardware design." ]
        pub nrfhw5: Nrfhw,
        # [ doc = "0x68 - Reserved for Nordic hardware design." ]
        pub nrfhw6: Nrfhw,
        # [ doc = "0x6c - Reserved for Nordic hardware design." ]
        pub nrfhw7: Nrfhw,
        # [ doc = "0x70 - Reserved for Nordic hardware design." ]
        pub nrfhw8: Nrfhw,
        # [ doc = "0x74 - Reserved for Nordic hardware design." ]
        pub nrfhw9: Nrfhw,
        # [ doc = "0x78 - Reserved for Nordic hardware design." ]
        pub nrfhw10: Nrfhw,
        # [ doc = "0x7c - Reserved for Nordic hardware design." ]
        pub nrfhw11: Nrfhw,
        # [ doc = "0x80 - Reserved for customer." ]
        pub customer0: Customer,
        # [ doc = "0x84 - Reserved for customer." ]
        pub customer1: Customer,
        # [ doc = "0x88 - Reserved for customer." ]
        pub customer2: Customer,
        # [ doc = "0x8c - Reserved for customer." ]
        pub customer3: Customer,
        # [ doc = "0x90 - Reserved for customer." ]
        pub customer4: Customer,
        # [ doc = "0x94 - Reserved for customer." ]
        pub customer5: Customer,
        # [ doc = "0x98 - Reserved for customer." ]
        pub customer6: Customer,
        # [ doc = "0x9c - Reserved for customer." ]
        pub customer7: Customer,
        # [ doc = "0xa0 - Reserved for customer." ]
        pub customer8: Customer,
        # [ doc = "0xa4 - Reserved for customer." ]
        pub customer9: Customer,
        # [ doc = "0xa8 - Reserved for customer." ]
        pub customer10: Customer,
        # [ doc = "0xac - Reserved for customer." ]
        pub customer11: Customer,
        # [ doc = "0xb0 - Reserved for customer." ]
        pub customer12: Customer,
        # [ doc = "0xb4 - Reserved for customer." ]
        pub customer13: Customer,
        # [ doc = "0xb8 - Reserved for customer." ]
        pub customer14: Customer,
        # [ doc = "0xbc - Reserved for customer." ]
        pub customer15: Customer,
        # [ doc = "0xc0 - Reserved for customer." ]
        pub customer16: Customer,
        # [ doc = "0xc4 - Reserved for customer." ]
        pub customer17: Customer,
        # [ doc = "0xc8 - Reserved for customer." ]
        pub customer18: Customer,
        # [ doc = "0xcc - Reserved for customer." ]
        pub customer19: Customer,
        # [ doc = "0xd0 - Reserved for customer." ]
        pub customer20: Customer,
        # [ doc = "0xd4 - Reserved for customer." ]
        pub customer21: Customer,
        # [ doc = "0xd8 - Reserved for customer." ]
        pub customer22: Customer,
        # [ doc = "0xdc - Reserved for customer." ]
        pub customer23: Customer,
        # [ doc = "0xe0 - Reserved for customer." ]
        pub customer24: Customer,
        # [ doc = "0xe4 - Reserved for customer." ]
        pub customer25: Customer,
        # [ doc = "0xe8 - Reserved for customer." ]
        pub customer26: Customer,
        # [ doc = "0xec - Reserved for customer." ]
        pub customer27: Customer,
        # [ doc = "0xf0 - Reserved for customer." ]
        pub customer28: Customer,
        # [ doc = "0xf4 - Reserved for customer." ]
        pub customer29: Customer,
        # [ doc = "0xf8 - Reserved for customer." ]
        pub customer30: Customer,
        # [ doc = "0xfc - Reserved for customer." ]
        pub customer31: Customer,
    }
    # [ doc = "Length of code region 0." ]
    pub struct Clenr0 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Length of code region 0." ]
    pub mod clenr0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Clenr0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Readback protection configuration." ]
    pub struct Rbpconf {
        register: VolatileCell<u32>,
    }
    # [ doc = "Readback protection configuration." ]
    pub mod rbpconf {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Rbpconf {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `PR0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pr0R {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl Pr0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pr0R::Disabled => 255,
                    Pr0R::Enabled => 0,
                    Pr0R::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pr0R {
                match bits {
                    255 => Pr0R::Disabled,
                    0 => Pr0R::Enabled,
                    i => Pr0R::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Pr0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Pr0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `PALL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PallR {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl PallR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PallR::Disabled => 255,
                    PallR::Enabled => 0,
                    PallR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PallR {
                match bits {
                    255 => PallR::Disabled,
                    0 => PallR::Enabled,
                    i => PallR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PallR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == PallR::Enabled
            }
        }
        # [ doc = "Values that can be written to the field `PR0`" ]
        pub enum Pr0W {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Pr0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pr0W::Disabled => 255,
                    Pr0W::Enabled => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pr0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Pr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Pr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PALL`" ]
        pub enum PallW {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl PallW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PallW::Disabled => 255,
                    PallW::Enabled => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PallW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PallW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PallW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PallW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PallW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Readback protect region 0. Will be ignored if pre-programmed factory code is present on the chip." ]
            # [ inline ( always ) ]
            pub fn pr0(&self) -> Pr0R {
                Pr0R::_from(
                    {
                        const MASK: u8 = 255;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bits 8:15 - Readback protect all code in the device." ]
            # [ inline ( always ) ]
            pub fn pall(&self) -> PallR {
                PallR::_from(
                    {
                        const MASK: u8 = 255;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Readback protect region 0. Will be ignored if pre-programmed factory code is present on the chip." ]
            # [ inline ( always ) ]
            pub fn pr0(&mut self) -> _Pr0W {
                _Pr0W { w: self }
            }
            # [ doc = "Bits 8:15 - Readback protect all code in the device." ]
            # [ inline ( always ) ]
            pub fn pall(&mut self) -> _PallW {
                _PallW { w: self }
            }
        }
    }
    # [ doc = "Reset value for CLOCK XTALFREQ register." ]
    pub struct Xtalfreq {
        register: VolatileCell<u32>,
    }
    # [ doc = "Reset value for CLOCK XTALFREQ register." ]
    pub mod xtalfreq {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Xtalfreq {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `XTALFREQ`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum XtalfreqR {
            # [ doc = "16MHz Xtal is used." ]
            _16mhz,
            # [ doc = "32MHz Xtal is used." ]
            _32mhz,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl XtalfreqR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    XtalfreqR::_16mhz => 255,
                    XtalfreqR::_32mhz => 0,
                    XtalfreqR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> XtalfreqR {
                match bits {
                    255 => XtalfreqR::_16mhz,
                    0 => XtalfreqR::_32mhz,
                    i => XtalfreqR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `_16mhz`" ]
            # [ inline ( always ) ]
            pub fn is_16mhz(&self) -> bool {
                *self == XtalfreqR::_16mhz
            }
            # [ doc = "Checks if the value of the field is `_32mhz`" ]
            # [ inline ( always ) ]
            pub fn is_32mhz(&self) -> bool {
                *self == XtalfreqR::_32mhz
            }
        }
        # [ doc = "Values that can be written to the field `XTALFREQ`" ]
        pub enum XtalfreqW {
            # [ doc = "16MHz Xtal is used." ]
            _16mhz,
            # [ doc = "32MHz Xtal is used." ]
            _32mhz,
        }
        impl XtalfreqW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    XtalfreqW::_16mhz => 255,
                    XtalfreqW::_32mhz => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _XtalfreqW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XtalfreqW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: XtalfreqW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "16MHz Xtal is used." ]
            # [ inline ( always ) ]
            pub fn _16mhz(self) -> &'a mut W {
                self.variant(XtalfreqW::_16mhz)
            }
            # [ doc = "32MHz Xtal is used." ]
            # [ inline ( always ) ]
            pub fn _32mhz(self) -> &'a mut W {
                self.variant(XtalfreqW::_32mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Reset value for CLOCK XTALFREQ register." ]
            # [ inline ( always ) ]
            pub fn xtalfreq(&self) -> XtalfreqR {
                XtalfreqR::_from(
                    {
                        const MASK: u8 = 255;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Reset value for CLOCK XTALFREQ register." ]
            # [ inline ( always ) ]
            pub fn xtalfreq(&mut self) -> _XtalfreqW {
                _XtalfreqW { w: self }
            }
        }
    }
    # [ doc = "Firmware ID." ]
    pub struct Fwid {
        register: VolatileCell<u32>,
    }
    # [ doc = "Firmware ID." ]
    pub mod fwid {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Fwid {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct FwidR {
            bits: u16,
        }
        impl FwidR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Identification number for the firmware loaded into the chip." ]
            # [ inline ( always ) ]
            pub fn fwid(&self) -> FwidR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                FwidR { bits }
            }
        }
    }
    # [ doc = "Bootloader start address." ]
    pub struct Bootloaderaddr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Bootloader start address." ]
    pub mod bootloaderaddr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Bootloaderaddr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Reserved for Nordic firmware design." ]
    pub struct Nrffw {
        register: VolatileCell<u32>,
    }
    # [ doc = "Reserved for Nordic firmware design." ]
    pub mod nrffw {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Nrffw {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Reserved for Nordic hardware design." ]
    pub struct Nrfhw {
        register: VolatileCell<u32>,
    }
    # [ doc = "Reserved for Nordic hardware design." ]
    pub mod nrfhw {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Nrfhw {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Reserved for customer." ]
    pub struct Customer {
        register: VolatileCell<u32>,
    }
    # [ doc = "Reserved for customer." ]
    pub mod customer {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Customer {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
# [ doc = "User Information Configuration." ]
pub struct Uicr {
    register_block: uicr::RegisterBlock,
}
impl Deref for Uicr {
    type Target = uicr::RegisterBlock;
    fn deref(&self) -> &uicr::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "General purpose input and output." ]
pub const GPIO: Peripheral<Gpio> = unsafe { Peripheral::new(1342177280) };
# [ doc = "General purpose input and output." ]
pub mod gpio {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 1284usize],
        # [ doc = "0x504 - Write GPIO port." ]
        pub out: Out,
        # [ doc = "0x508 - Set individual bits in GPIO port." ]
        pub outset: Outset,
        # [ doc = "0x50c - Clear individual bits in GPIO port." ]
        pub outclr: Outclr,
        # [ doc = "0x510 - Read GPIO port." ]
        pub in_: In,
        # [ doc = "0x514 - Direction of GPIO pins." ]
        pub dir: Dir,
        # [ doc = "0x518 - DIR set register." ]
        pub dirset: Dirset,
        # [ doc = "0x51c - DIR clear register." ]
        pub dirclr: Dirclr,
        _reserved1: [u8; 480usize],
        # [ doc = "0x700 - Configuration of GPIO pins." ]
        pub pin_cnf0: PinCnf,
        # [ doc = "0x704 - Configuration of GPIO pins." ]
        pub pin_cnf1: PinCnf,
        # [ doc = "0x708 - Configuration of GPIO pins." ]
        pub pin_cnf2: PinCnf,
        # [ doc = "0x70c - Configuration of GPIO pins." ]
        pub pin_cnf3: PinCnf,
        # [ doc = "0x710 - Configuration of GPIO pins." ]
        pub pin_cnf4: PinCnf,
        # [ doc = "0x714 - Configuration of GPIO pins." ]
        pub pin_cnf5: PinCnf,
        # [ doc = "0x718 - Configuration of GPIO pins." ]
        pub pin_cnf6: PinCnf,
        # [ doc = "0x71c - Configuration of GPIO pins." ]
        pub pin_cnf7: PinCnf,
        # [ doc = "0x720 - Configuration of GPIO pins." ]
        pub pin_cnf8: PinCnf,
        # [ doc = "0x724 - Configuration of GPIO pins." ]
        pub pin_cnf9: PinCnf,
        # [ doc = "0x728 - Configuration of GPIO pins." ]
        pub pin_cnf10: PinCnf,
        # [ doc = "0x72c - Configuration of GPIO pins." ]
        pub pin_cnf11: PinCnf,
        # [ doc = "0x730 - Configuration of GPIO pins." ]
        pub pin_cnf12: PinCnf,
        # [ doc = "0x734 - Configuration of GPIO pins." ]
        pub pin_cnf13: PinCnf,
        # [ doc = "0x738 - Configuration of GPIO pins." ]
        pub pin_cnf14: PinCnf,
        # [ doc = "0x73c - Configuration of GPIO pins." ]
        pub pin_cnf15: PinCnf,
        # [ doc = "0x740 - Configuration of GPIO pins." ]
        pub pin_cnf16: PinCnf,
        # [ doc = "0x744 - Configuration of GPIO pins." ]
        pub pin_cnf17: PinCnf,
        # [ doc = "0x748 - Configuration of GPIO pins." ]
        pub pin_cnf18: PinCnf,
        # [ doc = "0x74c - Configuration of GPIO pins." ]
        pub pin_cnf19: PinCnf,
        # [ doc = "0x750 - Configuration of GPIO pins." ]
        pub pin_cnf20: PinCnf,
        # [ doc = "0x754 - Configuration of GPIO pins." ]
        pub pin_cnf21: PinCnf,
        # [ doc = "0x758 - Configuration of GPIO pins." ]
        pub pin_cnf22: PinCnf,
        # [ doc = "0x75c - Configuration of GPIO pins." ]
        pub pin_cnf23: PinCnf,
        # [ doc = "0x760 - Configuration of GPIO pins." ]
        pub pin_cnf24: PinCnf,
        # [ doc = "0x764 - Configuration of GPIO pins." ]
        pub pin_cnf25: PinCnf,
        # [ doc = "0x768 - Configuration of GPIO pins." ]
        pub pin_cnf26: PinCnf,
        # [ doc = "0x76c - Configuration of GPIO pins." ]
        pub pin_cnf27: PinCnf,
        # [ doc = "0x770 - Configuration of GPIO pins." ]
        pub pin_cnf28: PinCnf,
        # [ doc = "0x774 - Configuration of GPIO pins." ]
        pub pin_cnf29: PinCnf,
        # [ doc = "0x778 - Configuration of GPIO pins." ]
        pub pin_cnf30: PinCnf,
        # [ doc = "0x77c - Configuration of GPIO pins." ]
        pub pin_cnf31: PinCnf,
    }
    # [ doc = "Write GPIO port." ]
    pub struct Out {
        register: VolatileCell<u32>,
    }
    # [ doc = "Write GPIO port." ]
    pub mod out {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Out {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `PIN0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin0R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin0R::Low => 0,
                    Pin0R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin0R {
                match bits {
                    0 => Pin0R::Low,
                    1 => Pin0R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin0R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin0R::High
            }
        }
        # [ doc = "Possible values of the field `PIN1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin1R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin1R::Low => 0,
                    Pin1R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin1R {
                match bits {
                    0 => Pin1R::Low,
                    1 => Pin1R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin1R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin1R::High
            }
        }
        # [ doc = "Possible values of the field `PIN2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin2R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin2R::Low => 0,
                    Pin2R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin2R {
                match bits {
                    0 => Pin2R::Low,
                    1 => Pin2R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin2R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin2R::High
            }
        }
        # [ doc = "Possible values of the field `PIN3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin3R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin3R::Low => 0,
                    Pin3R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin3R {
                match bits {
                    0 => Pin3R::Low,
                    1 => Pin3R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin3R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin3R::High
            }
        }
        # [ doc = "Possible values of the field `PIN4`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin4R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin4R::Low => 0,
                    Pin4R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin4R {
                match bits {
                    0 => Pin4R::Low,
                    1 => Pin4R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin4R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin4R::High
            }
        }
        # [ doc = "Possible values of the field `PIN5`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin5R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin5R::Low => 0,
                    Pin5R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin5R {
                match bits {
                    0 => Pin5R::Low,
                    1 => Pin5R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin5R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin5R::High
            }
        }
        # [ doc = "Possible values of the field `PIN6`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin6R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin6R::Low => 0,
                    Pin6R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin6R {
                match bits {
                    0 => Pin6R::Low,
                    1 => Pin6R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin6R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin6R::High
            }
        }
        # [ doc = "Possible values of the field `PIN7`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin7R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin7R::Low => 0,
                    Pin7R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin7R {
                match bits {
                    0 => Pin7R::Low,
                    1 => Pin7R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin7R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin7R::High
            }
        }
        # [ doc = "Possible values of the field `PIN8`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin8R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin8R::Low => 0,
                    Pin8R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin8R {
                match bits {
                    0 => Pin8R::Low,
                    1 => Pin8R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin8R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin8R::High
            }
        }
        # [ doc = "Possible values of the field `PIN9`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin9R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin9R::Low => 0,
                    Pin9R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin9R {
                match bits {
                    0 => Pin9R::Low,
                    1 => Pin9R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin9R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin9R::High
            }
        }
        # [ doc = "Possible values of the field `PIN10`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin10R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin10R::Low => 0,
                    Pin10R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin10R {
                match bits {
                    0 => Pin10R::Low,
                    1 => Pin10R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin10R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin10R::High
            }
        }
        # [ doc = "Possible values of the field `PIN11`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin11R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin11R::Low => 0,
                    Pin11R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin11R {
                match bits {
                    0 => Pin11R::Low,
                    1 => Pin11R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin11R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin11R::High
            }
        }
        # [ doc = "Possible values of the field `PIN12`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin12R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin12R::Low => 0,
                    Pin12R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin12R {
                match bits {
                    0 => Pin12R::Low,
                    1 => Pin12R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin12R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin12R::High
            }
        }
        # [ doc = "Possible values of the field `PIN13`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin13R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin13R::Low => 0,
                    Pin13R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin13R {
                match bits {
                    0 => Pin13R::Low,
                    1 => Pin13R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin13R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin13R::High
            }
        }
        # [ doc = "Possible values of the field `PIN14`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin14R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin14R::Low => 0,
                    Pin14R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin14R {
                match bits {
                    0 => Pin14R::Low,
                    1 => Pin14R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin14R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin14R::High
            }
        }
        # [ doc = "Possible values of the field `PIN15`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin15R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin15R::Low => 0,
                    Pin15R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin15R {
                match bits {
                    0 => Pin15R::Low,
                    1 => Pin15R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin15R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin15R::High
            }
        }
        # [ doc = "Possible values of the field `PIN16`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin16R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin16R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin16R::Low => 0,
                    Pin16R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin16R {
                match bits {
                    0 => Pin16R::Low,
                    1 => Pin16R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin16R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin16R::High
            }
        }
        # [ doc = "Possible values of the field `PIN17`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin17R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin17R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin17R::Low => 0,
                    Pin17R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin17R {
                match bits {
                    0 => Pin17R::Low,
                    1 => Pin17R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin17R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin17R::High
            }
        }
        # [ doc = "Possible values of the field `PIN18`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin18R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin18R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin18R::Low => 0,
                    Pin18R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin18R {
                match bits {
                    0 => Pin18R::Low,
                    1 => Pin18R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin18R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin18R::High
            }
        }
        # [ doc = "Possible values of the field `PIN19`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin19R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin19R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin19R::Low => 0,
                    Pin19R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin19R {
                match bits {
                    0 => Pin19R::Low,
                    1 => Pin19R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin19R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin19R::High
            }
        }
        # [ doc = "Possible values of the field `PIN20`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin20R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin20R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin20R::Low => 0,
                    Pin20R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin20R {
                match bits {
                    0 => Pin20R::Low,
                    1 => Pin20R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin20R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin20R::High
            }
        }
        # [ doc = "Possible values of the field `PIN21`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin21R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin21R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin21R::Low => 0,
                    Pin21R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin21R {
                match bits {
                    0 => Pin21R::Low,
                    1 => Pin21R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin21R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin21R::High
            }
        }
        # [ doc = "Possible values of the field `PIN22`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin22R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin22R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin22R::Low => 0,
                    Pin22R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin22R {
                match bits {
                    0 => Pin22R::Low,
                    1 => Pin22R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin22R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin22R::High
            }
        }
        # [ doc = "Possible values of the field `PIN23`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin23R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin23R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin23R::Low => 0,
                    Pin23R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin23R {
                match bits {
                    0 => Pin23R::Low,
                    1 => Pin23R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin23R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin23R::High
            }
        }
        # [ doc = "Possible values of the field `PIN24`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin24R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin24R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin24R::Low => 0,
                    Pin24R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin24R {
                match bits {
                    0 => Pin24R::Low,
                    1 => Pin24R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin24R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin24R::High
            }
        }
        # [ doc = "Possible values of the field `PIN25`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin25R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin25R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin25R::Low => 0,
                    Pin25R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin25R {
                match bits {
                    0 => Pin25R::Low,
                    1 => Pin25R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin25R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin25R::High
            }
        }
        # [ doc = "Possible values of the field `PIN26`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin26R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin26R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin26R::Low => 0,
                    Pin26R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin26R {
                match bits {
                    0 => Pin26R::Low,
                    1 => Pin26R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin26R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin26R::High
            }
        }
        # [ doc = "Possible values of the field `PIN27`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin27R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin27R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin27R::Low => 0,
                    Pin27R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin27R {
                match bits {
                    0 => Pin27R::Low,
                    1 => Pin27R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin27R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin27R::High
            }
        }
        # [ doc = "Possible values of the field `PIN28`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin28R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin28R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin28R::Low => 0,
                    Pin28R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin28R {
                match bits {
                    0 => Pin28R::Low,
                    1 => Pin28R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin28R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin28R::High
            }
        }
        # [ doc = "Possible values of the field `PIN29`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin29R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin29R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin29R::Low => 0,
                    Pin29R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin29R {
                match bits {
                    0 => Pin29R::Low,
                    1 => Pin29R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin29R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin29R::High
            }
        }
        # [ doc = "Possible values of the field `PIN30`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin30R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin30R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin30R::Low => 0,
                    Pin30R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin30R {
                match bits {
                    0 => Pin30R::Low,
                    1 => Pin30R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin30R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin30R::High
            }
        }
        # [ doc = "Possible values of the field `PIN31`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin31R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin31R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin31R::Low => 0,
                    Pin31R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin31R {
                match bits {
                    0 => Pin31R::Low,
                    1 => Pin31R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin31R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin31R::High
            }
        }
        # [ doc = "Values that can be written to the field `PIN0`" ]
        pub enum Pin0W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin0W::Low => 0,
                    Pin0W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin0W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin0W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN1`" ]
        pub enum Pin1W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin1W::Low => 0,
                    Pin1W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin1W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin1W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN2`" ]
        pub enum Pin2W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin2W::Low => 0,
                    Pin2W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin2W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin2W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN3`" ]
        pub enum Pin3W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin3W::Low => 0,
                    Pin3W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin3W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin3W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN4`" ]
        pub enum Pin4W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin4W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin4W::Low => 0,
                    Pin4W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin4W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin4W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN5`" ]
        pub enum Pin5W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin5W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin5W::Low => 0,
                    Pin5W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin5W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin5W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN6`" ]
        pub enum Pin6W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin6W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin6W::Low => 0,
                    Pin6W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin6W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin6W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN7`" ]
        pub enum Pin7W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin7W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin7W::Low => 0,
                    Pin7W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin7W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin7W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN8`" ]
        pub enum Pin8W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin8W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin8W::Low => 0,
                    Pin8W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin8W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin8W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin8W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN9`" ]
        pub enum Pin9W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin9W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin9W::Low => 0,
                    Pin9W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin9W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin9W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin9W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN10`" ]
        pub enum Pin10W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin10W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin10W::Low => 0,
                    Pin10W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin10W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin10W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin10W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN11`" ]
        pub enum Pin11W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin11W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin11W::Low => 0,
                    Pin11W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin11W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin11W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin11W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN12`" ]
        pub enum Pin12W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin12W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin12W::Low => 0,
                    Pin12W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin12W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin12W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin12W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN13`" ]
        pub enum Pin13W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin13W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin13W::Low => 0,
                    Pin13W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin13W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin13W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin13W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN14`" ]
        pub enum Pin14W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin14W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin14W::Low => 0,
                    Pin14W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin14W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin14W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin14W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN15`" ]
        pub enum Pin15W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin15W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin15W::Low => 0,
                    Pin15W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin15W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin15W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin15W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN16`" ]
        pub enum Pin16W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin16W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin16W::Low => 0,
                    Pin16W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin16W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin16W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin16W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin16W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN17`" ]
        pub enum Pin17W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin17W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin17W::Low => 0,
                    Pin17W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin17W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin17W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin17W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin17W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN18`" ]
        pub enum Pin18W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin18W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin18W::Low => 0,
                    Pin18W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin18W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin18W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin18W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin18W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN19`" ]
        pub enum Pin19W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin19W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin19W::Low => 0,
                    Pin19W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin19W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin19W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin19W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin19W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN20`" ]
        pub enum Pin20W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin20W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin20W::Low => 0,
                    Pin20W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin20W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin20W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin20W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin20W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN21`" ]
        pub enum Pin21W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin21W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin21W::Low => 0,
                    Pin21W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin21W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin21W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin21W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin21W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN22`" ]
        pub enum Pin22W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin22W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin22W::Low => 0,
                    Pin22W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin22W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin22W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin22W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin22W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN23`" ]
        pub enum Pin23W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin23W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin23W::Low => 0,
                    Pin23W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin23W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin23W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin23W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin23W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN24`" ]
        pub enum Pin24W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin24W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin24W::Low => 0,
                    Pin24W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin24W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin24W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin24W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin24W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN25`" ]
        pub enum Pin25W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin25W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin25W::Low => 0,
                    Pin25W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin25W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin25W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin25W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin25W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN26`" ]
        pub enum Pin26W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin26W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin26W::Low => 0,
                    Pin26W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin26W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin26W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin26W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin26W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN27`" ]
        pub enum Pin27W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin27W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin27W::Low => 0,
                    Pin27W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin27W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin27W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin27W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin27W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN28`" ]
        pub enum Pin28W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin28W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin28W::Low => 0,
                    Pin28W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin28W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin28W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin28W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin28W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN29`" ]
        pub enum Pin29W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin29W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin29W::Low => 0,
                    Pin29W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin29W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin29W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin29W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin29W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN30`" ]
        pub enum Pin30W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin30W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin30W::Low => 0,
                    Pin30W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin30W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin30W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin30W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin30W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN31`" ]
        pub enum Pin31W {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin31W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin31W::Low => 0,
                    Pin31W::High => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin31W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin31W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin driver is low." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(Pin31W::Low)
            }
            # [ doc = "Pin driver is high." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(Pin31W::High)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Pin 0." ]
            # [ inline ( always ) ]
            pub fn pin0(&self) -> Pin0R {
                Pin0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Pin 1." ]
            # [ inline ( always ) ]
            pub fn pin1(&self) -> Pin1R {
                Pin1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Pin 2." ]
            # [ inline ( always ) ]
            pub fn pin2(&self) -> Pin2R {
                Pin2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Pin 3." ]
            # [ inline ( always ) ]
            pub fn pin3(&self) -> Pin3R {
                Pin3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Pin 4." ]
            # [ inline ( always ) ]
            pub fn pin4(&self) -> Pin4R {
                Pin4R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Pin 5." ]
            # [ inline ( always ) ]
            pub fn pin5(&self) -> Pin5R {
                Pin5R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Pin 6." ]
            # [ inline ( always ) ]
            pub fn pin6(&self) -> Pin6R {
                Pin6R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Pin 7." ]
            # [ inline ( always ) ]
            pub fn pin7(&self) -> Pin7R {
                Pin7R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Pin 8." ]
            # [ inline ( always ) ]
            pub fn pin8(&self) -> Pin8R {
                Pin8R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Pin 9." ]
            # [ inline ( always ) ]
            pub fn pin9(&self) -> Pin9R {
                Pin9R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Pin 10." ]
            # [ inline ( always ) ]
            pub fn pin10(&self) -> Pin10R {
                Pin10R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 11 - Pin 11." ]
            # [ inline ( always ) ]
            pub fn pin11(&self) -> Pin11R {
                Pin11R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 12 - Pin 12." ]
            # [ inline ( always ) ]
            pub fn pin12(&self) -> Pin12R {
                Pin12R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 13 - Pin 13." ]
            # [ inline ( always ) ]
            pub fn pin13(&self) -> Pin13R {
                Pin13R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 13;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 14 - Pin 14." ]
            # [ inline ( always ) ]
            pub fn pin14(&self) -> Pin14R {
                Pin14R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 15 - Pin 15." ]
            # [ inline ( always ) ]
            pub fn pin15(&self) -> Pin15R {
                Pin15R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 15;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - Pin 16." ]
            # [ inline ( always ) ]
            pub fn pin16(&self) -> Pin16R {
                Pin16R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Pin 17." ]
            # [ inline ( always ) ]
            pub fn pin17(&self) -> Pin17R {
                Pin17R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Pin 18." ]
            # [ inline ( always ) ]
            pub fn pin18(&self) -> Pin18R {
                Pin18R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Pin 19." ]
            # [ inline ( always ) ]
            pub fn pin19(&self) -> Pin19R {
                Pin19R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 20 - Pin 20." ]
            # [ inline ( always ) ]
            pub fn pin20(&self) -> Pin20R {
                Pin20R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 20;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 21 - Pin 21." ]
            # [ inline ( always ) ]
            pub fn pin21(&self) -> Pin21R {
                Pin21R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 21;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 22 - Pin 22." ]
            # [ inline ( always ) ]
            pub fn pin22(&self) -> Pin22R {
                Pin22R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 22;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 23 - Pin 23." ]
            # [ inline ( always ) ]
            pub fn pin23(&self) -> Pin23R {
                Pin23R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 23;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 24 - Pin 24." ]
            # [ inline ( always ) ]
            pub fn pin24(&self) -> Pin24R {
                Pin24R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 24;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 25 - Pin 25." ]
            # [ inline ( always ) ]
            pub fn pin25(&self) -> Pin25R {
                Pin25R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 25;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 26 - Pin 26." ]
            # [ inline ( always ) ]
            pub fn pin26(&self) -> Pin26R {
                Pin26R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 26;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 27 - Pin 27." ]
            # [ inline ( always ) ]
            pub fn pin27(&self) -> Pin27R {
                Pin27R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 27;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 28 - Pin 28." ]
            # [ inline ( always ) ]
            pub fn pin28(&self) -> Pin28R {
                Pin28R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 28;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 29 - Pin 29." ]
            # [ inline ( always ) ]
            pub fn pin29(&self) -> Pin29R {
                Pin29R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 29;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 30 - Pin 30." ]
            # [ inline ( always ) ]
            pub fn pin30(&self) -> Pin30R {
                Pin30R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 30;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 31 - Pin 31." ]
            # [ inline ( always ) ]
            pub fn pin31(&self) -> Pin31R {
                Pin31R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Pin 0." ]
            # [ inline ( always ) ]
            pub fn pin0(&mut self) -> _Pin0W {
                _Pin0W { w: self }
            }
            # [ doc = "Bit 1 - Pin 1." ]
            # [ inline ( always ) ]
            pub fn pin1(&mut self) -> _Pin1W {
                _Pin1W { w: self }
            }
            # [ doc = "Bit 2 - Pin 2." ]
            # [ inline ( always ) ]
            pub fn pin2(&mut self) -> _Pin2W {
                _Pin2W { w: self }
            }
            # [ doc = "Bit 3 - Pin 3." ]
            # [ inline ( always ) ]
            pub fn pin3(&mut self) -> _Pin3W {
                _Pin3W { w: self }
            }
            # [ doc = "Bit 4 - Pin 4." ]
            # [ inline ( always ) ]
            pub fn pin4(&mut self) -> _Pin4W {
                _Pin4W { w: self }
            }
            # [ doc = "Bit 5 - Pin 5." ]
            # [ inline ( always ) ]
            pub fn pin5(&mut self) -> _Pin5W {
                _Pin5W { w: self }
            }
            # [ doc = "Bit 6 - Pin 6." ]
            # [ inline ( always ) ]
            pub fn pin6(&mut self) -> _Pin6W {
                _Pin6W { w: self }
            }
            # [ doc = "Bit 7 - Pin 7." ]
            # [ inline ( always ) ]
            pub fn pin7(&mut self) -> _Pin7W {
                _Pin7W { w: self }
            }
            # [ doc = "Bit 8 - Pin 8." ]
            # [ inline ( always ) ]
            pub fn pin8(&mut self) -> _Pin8W {
                _Pin8W { w: self }
            }
            # [ doc = "Bit 9 - Pin 9." ]
            # [ inline ( always ) ]
            pub fn pin9(&mut self) -> _Pin9W {
                _Pin9W { w: self }
            }
            # [ doc = "Bit 10 - Pin 10." ]
            # [ inline ( always ) ]
            pub fn pin10(&mut self) -> _Pin10W {
                _Pin10W { w: self }
            }
            # [ doc = "Bit 11 - Pin 11." ]
            # [ inline ( always ) ]
            pub fn pin11(&mut self) -> _Pin11W {
                _Pin11W { w: self }
            }
            # [ doc = "Bit 12 - Pin 12." ]
            # [ inline ( always ) ]
            pub fn pin12(&mut self) -> _Pin12W {
                _Pin12W { w: self }
            }
            # [ doc = "Bit 13 - Pin 13." ]
            # [ inline ( always ) ]
            pub fn pin13(&mut self) -> _Pin13W {
                _Pin13W { w: self }
            }
            # [ doc = "Bit 14 - Pin 14." ]
            # [ inline ( always ) ]
            pub fn pin14(&mut self) -> _Pin14W {
                _Pin14W { w: self }
            }
            # [ doc = "Bit 15 - Pin 15." ]
            # [ inline ( always ) ]
            pub fn pin15(&mut self) -> _Pin15W {
                _Pin15W { w: self }
            }
            # [ doc = "Bit 16 - Pin 16." ]
            # [ inline ( always ) ]
            pub fn pin16(&mut self) -> _Pin16W {
                _Pin16W { w: self }
            }
            # [ doc = "Bit 17 - Pin 17." ]
            # [ inline ( always ) ]
            pub fn pin17(&mut self) -> _Pin17W {
                _Pin17W { w: self }
            }
            # [ doc = "Bit 18 - Pin 18." ]
            # [ inline ( always ) ]
            pub fn pin18(&mut self) -> _Pin18W {
                _Pin18W { w: self }
            }
            # [ doc = "Bit 19 - Pin 19." ]
            # [ inline ( always ) ]
            pub fn pin19(&mut self) -> _Pin19W {
                _Pin19W { w: self }
            }
            # [ doc = "Bit 20 - Pin 20." ]
            # [ inline ( always ) ]
            pub fn pin20(&mut self) -> _Pin20W {
                _Pin20W { w: self }
            }
            # [ doc = "Bit 21 - Pin 21." ]
            # [ inline ( always ) ]
            pub fn pin21(&mut self) -> _Pin21W {
                _Pin21W { w: self }
            }
            # [ doc = "Bit 22 - Pin 22." ]
            # [ inline ( always ) ]
            pub fn pin22(&mut self) -> _Pin22W {
                _Pin22W { w: self }
            }
            # [ doc = "Bit 23 - Pin 23." ]
            # [ inline ( always ) ]
            pub fn pin23(&mut self) -> _Pin23W {
                _Pin23W { w: self }
            }
            # [ doc = "Bit 24 - Pin 24." ]
            # [ inline ( always ) ]
            pub fn pin24(&mut self) -> _Pin24W {
                _Pin24W { w: self }
            }
            # [ doc = "Bit 25 - Pin 25." ]
            # [ inline ( always ) ]
            pub fn pin25(&mut self) -> _Pin25W {
                _Pin25W { w: self }
            }
            # [ doc = "Bit 26 - Pin 26." ]
            # [ inline ( always ) ]
            pub fn pin26(&mut self) -> _Pin26W {
                _Pin26W { w: self }
            }
            # [ doc = "Bit 27 - Pin 27." ]
            # [ inline ( always ) ]
            pub fn pin27(&mut self) -> _Pin27W {
                _Pin27W { w: self }
            }
            # [ doc = "Bit 28 - Pin 28." ]
            # [ inline ( always ) ]
            pub fn pin28(&mut self) -> _Pin28W {
                _Pin28W { w: self }
            }
            # [ doc = "Bit 29 - Pin 29." ]
            # [ inline ( always ) ]
            pub fn pin29(&mut self) -> _Pin29W {
                _Pin29W { w: self }
            }
            # [ doc = "Bit 30 - Pin 30." ]
            # [ inline ( always ) ]
            pub fn pin30(&mut self) -> _Pin30W {
                _Pin30W { w: self }
            }
            # [ doc = "Bit 31 - Pin 31." ]
            # [ inline ( always ) ]
            pub fn pin31(&mut self) -> _Pin31W {
                _Pin31W { w: self }
            }
        }
    }
    # [ doc = "Set individual bits in GPIO port." ]
    pub struct Outset {
        register: VolatileCell<u32>,
    }
    # [ doc = "Set individual bits in GPIO port." ]
    pub mod outset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Outset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `PIN0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin0R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin0R::Low => 0,
                    Pin0R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin0R {
                match bits {
                    0 => Pin0R::Low,
                    1 => Pin0R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin0R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin0R::High
            }
        }
        # [ doc = "Possible values of the field `PIN1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin1R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin1R::Low => 0,
                    Pin1R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin1R {
                match bits {
                    0 => Pin1R::Low,
                    1 => Pin1R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin1R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin1R::High
            }
        }
        # [ doc = "Possible values of the field `PIN2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin2R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin2R::Low => 0,
                    Pin2R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin2R {
                match bits {
                    0 => Pin2R::Low,
                    1 => Pin2R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin2R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin2R::High
            }
        }
        # [ doc = "Possible values of the field `PIN3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin3R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin3R::Low => 0,
                    Pin3R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin3R {
                match bits {
                    0 => Pin3R::Low,
                    1 => Pin3R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin3R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin3R::High
            }
        }
        # [ doc = "Possible values of the field `PIN4`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin4R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin4R::Low => 0,
                    Pin4R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin4R {
                match bits {
                    0 => Pin4R::Low,
                    1 => Pin4R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin4R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin4R::High
            }
        }
        # [ doc = "Possible values of the field `PIN5`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin5R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin5R::Low => 0,
                    Pin5R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin5R {
                match bits {
                    0 => Pin5R::Low,
                    1 => Pin5R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin5R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin5R::High
            }
        }
        # [ doc = "Possible values of the field `PIN6`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin6R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin6R::Low => 0,
                    Pin6R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin6R {
                match bits {
                    0 => Pin6R::Low,
                    1 => Pin6R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin6R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin6R::High
            }
        }
        # [ doc = "Possible values of the field `PIN7`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin7R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin7R::Low => 0,
                    Pin7R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin7R {
                match bits {
                    0 => Pin7R::Low,
                    1 => Pin7R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin7R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin7R::High
            }
        }
        # [ doc = "Possible values of the field `PIN8`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin8R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin8R::Low => 0,
                    Pin8R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin8R {
                match bits {
                    0 => Pin8R::Low,
                    1 => Pin8R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin8R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin8R::High
            }
        }
        # [ doc = "Possible values of the field `PIN9`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin9R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin9R::Low => 0,
                    Pin9R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin9R {
                match bits {
                    0 => Pin9R::Low,
                    1 => Pin9R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin9R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin9R::High
            }
        }
        # [ doc = "Possible values of the field `PIN10`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin10R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin10R::Low => 0,
                    Pin10R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin10R {
                match bits {
                    0 => Pin10R::Low,
                    1 => Pin10R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin10R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin10R::High
            }
        }
        # [ doc = "Possible values of the field `PIN11`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin11R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin11R::Low => 0,
                    Pin11R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin11R {
                match bits {
                    0 => Pin11R::Low,
                    1 => Pin11R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin11R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin11R::High
            }
        }
        # [ doc = "Possible values of the field `PIN12`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin12R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin12R::Low => 0,
                    Pin12R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin12R {
                match bits {
                    0 => Pin12R::Low,
                    1 => Pin12R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin12R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin12R::High
            }
        }
        # [ doc = "Possible values of the field `PIN13`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin13R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin13R::Low => 0,
                    Pin13R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin13R {
                match bits {
                    0 => Pin13R::Low,
                    1 => Pin13R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin13R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin13R::High
            }
        }
        # [ doc = "Possible values of the field `PIN14`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin14R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin14R::Low => 0,
                    Pin14R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin14R {
                match bits {
                    0 => Pin14R::Low,
                    1 => Pin14R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin14R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin14R::High
            }
        }
        # [ doc = "Possible values of the field `PIN15`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin15R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin15R::Low => 0,
                    Pin15R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin15R {
                match bits {
                    0 => Pin15R::Low,
                    1 => Pin15R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin15R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin15R::High
            }
        }
        # [ doc = "Possible values of the field `PIN16`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin16R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin16R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin16R::Low => 0,
                    Pin16R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin16R {
                match bits {
                    0 => Pin16R::Low,
                    1 => Pin16R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin16R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin16R::High
            }
        }
        # [ doc = "Possible values of the field `PIN17`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin17R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin17R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin17R::Low => 0,
                    Pin17R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin17R {
                match bits {
                    0 => Pin17R::Low,
                    1 => Pin17R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin17R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin17R::High
            }
        }
        # [ doc = "Possible values of the field `PIN18`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin18R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin18R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin18R::Low => 0,
                    Pin18R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin18R {
                match bits {
                    0 => Pin18R::Low,
                    1 => Pin18R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin18R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin18R::High
            }
        }
        # [ doc = "Possible values of the field `PIN19`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin19R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin19R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin19R::Low => 0,
                    Pin19R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin19R {
                match bits {
                    0 => Pin19R::Low,
                    1 => Pin19R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin19R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin19R::High
            }
        }
        # [ doc = "Possible values of the field `PIN20`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin20R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin20R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin20R::Low => 0,
                    Pin20R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin20R {
                match bits {
                    0 => Pin20R::Low,
                    1 => Pin20R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin20R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin20R::High
            }
        }
        # [ doc = "Possible values of the field `PIN21`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin21R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin21R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin21R::Low => 0,
                    Pin21R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin21R {
                match bits {
                    0 => Pin21R::Low,
                    1 => Pin21R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin21R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin21R::High
            }
        }
        # [ doc = "Possible values of the field `PIN22`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin22R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin22R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin22R::Low => 0,
                    Pin22R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin22R {
                match bits {
                    0 => Pin22R::Low,
                    1 => Pin22R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin22R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin22R::High
            }
        }
        # [ doc = "Possible values of the field `PIN23`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin23R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin23R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin23R::Low => 0,
                    Pin23R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin23R {
                match bits {
                    0 => Pin23R::Low,
                    1 => Pin23R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin23R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin23R::High
            }
        }
        # [ doc = "Possible values of the field `PIN24`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin24R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin24R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin24R::Low => 0,
                    Pin24R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin24R {
                match bits {
                    0 => Pin24R::Low,
                    1 => Pin24R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin24R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin24R::High
            }
        }
        # [ doc = "Possible values of the field `PIN25`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin25R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin25R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin25R::Low => 0,
                    Pin25R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin25R {
                match bits {
                    0 => Pin25R::Low,
                    1 => Pin25R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin25R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin25R::High
            }
        }
        # [ doc = "Possible values of the field `PIN26`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin26R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin26R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin26R::Low => 0,
                    Pin26R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin26R {
                match bits {
                    0 => Pin26R::Low,
                    1 => Pin26R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin26R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin26R::High
            }
        }
        # [ doc = "Possible values of the field `PIN27`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin27R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin27R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin27R::Low => 0,
                    Pin27R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin27R {
                match bits {
                    0 => Pin27R::Low,
                    1 => Pin27R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin27R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin27R::High
            }
        }
        # [ doc = "Possible values of the field `PIN28`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin28R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin28R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin28R::Low => 0,
                    Pin28R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin28R {
                match bits {
                    0 => Pin28R::Low,
                    1 => Pin28R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin28R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin28R::High
            }
        }
        # [ doc = "Possible values of the field `PIN29`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin29R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin29R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin29R::Low => 0,
                    Pin29R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin29R {
                match bits {
                    0 => Pin29R::Low,
                    1 => Pin29R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin29R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin29R::High
            }
        }
        # [ doc = "Possible values of the field `PIN30`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin30R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin30R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin30R::Low => 0,
                    Pin30R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin30R {
                match bits {
                    0 => Pin30R::Low,
                    1 => Pin30R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin30R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin30R::High
            }
        }
        # [ doc = "Possible values of the field `PIN31`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin31R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin31R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin31R::Low => 0,
                    Pin31R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin31R {
                match bits {
                    0 => Pin31R::Low,
                    1 => Pin31R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin31R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin31R::High
            }
        }
        # [ doc = "Values that can be written to the field `PIN0`" ]
        pub enum Pin0W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin0W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN1`" ]
        pub enum Pin1W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin1W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin1W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN2`" ]
        pub enum Pin2W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin2W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin2W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN3`" ]
        pub enum Pin3W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin3W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin3W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN4`" ]
        pub enum Pin4W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin4W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin4W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin4W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin4W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN5`" ]
        pub enum Pin5W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin5W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin5W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin5W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin5W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN6`" ]
        pub enum Pin6W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin6W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin6W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin6W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin6W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN7`" ]
        pub enum Pin7W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin7W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin7W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin7W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin7W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN8`" ]
        pub enum Pin8W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin8W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin8W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin8W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin8W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN9`" ]
        pub enum Pin9W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin9W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin9W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin9W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin9W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN10`" ]
        pub enum Pin10W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin10W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin10W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin10W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin10W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN11`" ]
        pub enum Pin11W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin11W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin11W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin11W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin11W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN12`" ]
        pub enum Pin12W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin12W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin12W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin12W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin12W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN13`" ]
        pub enum Pin13W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin13W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin13W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin13W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin13W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN14`" ]
        pub enum Pin14W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin14W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin14W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin14W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin14W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN15`" ]
        pub enum Pin15W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin15W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin15W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin15W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin15W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN16`" ]
        pub enum Pin16W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin16W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin16W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin16W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin16W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin16W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN17`" ]
        pub enum Pin17W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin17W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin17W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin17W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin17W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin17W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN18`" ]
        pub enum Pin18W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin18W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin18W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin18W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin18W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin18W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN19`" ]
        pub enum Pin19W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin19W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin19W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin19W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin19W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin19W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN20`" ]
        pub enum Pin20W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin20W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin20W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin20W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin20W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin20W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN21`" ]
        pub enum Pin21W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin21W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin21W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin21W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin21W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin21W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN22`" ]
        pub enum Pin22W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin22W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin22W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin22W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin22W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin22W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN23`" ]
        pub enum Pin23W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin23W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin23W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin23W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin23W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin23W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN24`" ]
        pub enum Pin24W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin24W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin24W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin24W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin24W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin24W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN25`" ]
        pub enum Pin25W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin25W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin25W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin25W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin25W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin25W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN26`" ]
        pub enum Pin26W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin26W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin26W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin26W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin26W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin26W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN27`" ]
        pub enum Pin27W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin27W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin27W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin27W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin27W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin27W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN28`" ]
        pub enum Pin28W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin28W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin28W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin28W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin28W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin28W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN29`" ]
        pub enum Pin29W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin29W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin29W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin29W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin29W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin29W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN30`" ]
        pub enum Pin30W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin30W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin30W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin30W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin30W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin30W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN31`" ]
        pub enum Pin31W {
            # [ doc = "Set pin driver high." ]
            Set,
        }
        impl Pin31W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin31W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin31W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin31W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver high." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin31W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Pin 0." ]
            # [ inline ( always ) ]
            pub fn pin0(&self) -> Pin0R {
                Pin0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Pin 1." ]
            # [ inline ( always ) ]
            pub fn pin1(&self) -> Pin1R {
                Pin1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Pin 2." ]
            # [ inline ( always ) ]
            pub fn pin2(&self) -> Pin2R {
                Pin2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Pin 3." ]
            # [ inline ( always ) ]
            pub fn pin3(&self) -> Pin3R {
                Pin3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Pin 4." ]
            # [ inline ( always ) ]
            pub fn pin4(&self) -> Pin4R {
                Pin4R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Pin 5." ]
            # [ inline ( always ) ]
            pub fn pin5(&self) -> Pin5R {
                Pin5R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Pin 6." ]
            # [ inline ( always ) ]
            pub fn pin6(&self) -> Pin6R {
                Pin6R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Pin 7." ]
            # [ inline ( always ) ]
            pub fn pin7(&self) -> Pin7R {
                Pin7R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Pin 8." ]
            # [ inline ( always ) ]
            pub fn pin8(&self) -> Pin8R {
                Pin8R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Pin 9." ]
            # [ inline ( always ) ]
            pub fn pin9(&self) -> Pin9R {
                Pin9R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Pin 10." ]
            # [ inline ( always ) ]
            pub fn pin10(&self) -> Pin10R {
                Pin10R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 11 - Pin 11." ]
            # [ inline ( always ) ]
            pub fn pin11(&self) -> Pin11R {
                Pin11R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 12 - Pin 12." ]
            # [ inline ( always ) ]
            pub fn pin12(&self) -> Pin12R {
                Pin12R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 13 - Pin 13." ]
            # [ inline ( always ) ]
            pub fn pin13(&self) -> Pin13R {
                Pin13R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 13;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 14 - Pin 14." ]
            # [ inline ( always ) ]
            pub fn pin14(&self) -> Pin14R {
                Pin14R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 15 - Pin 15." ]
            # [ inline ( always ) ]
            pub fn pin15(&self) -> Pin15R {
                Pin15R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 15;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - Pin 16." ]
            # [ inline ( always ) ]
            pub fn pin16(&self) -> Pin16R {
                Pin16R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Pin 17." ]
            # [ inline ( always ) ]
            pub fn pin17(&self) -> Pin17R {
                Pin17R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Pin 18." ]
            # [ inline ( always ) ]
            pub fn pin18(&self) -> Pin18R {
                Pin18R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Pin 19." ]
            # [ inline ( always ) ]
            pub fn pin19(&self) -> Pin19R {
                Pin19R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 20 - Pin 20." ]
            # [ inline ( always ) ]
            pub fn pin20(&self) -> Pin20R {
                Pin20R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 20;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 21 - Pin 21." ]
            # [ inline ( always ) ]
            pub fn pin21(&self) -> Pin21R {
                Pin21R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 21;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 22 - Pin 22." ]
            # [ inline ( always ) ]
            pub fn pin22(&self) -> Pin22R {
                Pin22R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 22;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 23 - Pin 23." ]
            # [ inline ( always ) ]
            pub fn pin23(&self) -> Pin23R {
                Pin23R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 23;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 24 - Pin 24." ]
            # [ inline ( always ) ]
            pub fn pin24(&self) -> Pin24R {
                Pin24R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 24;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 25 - Pin 25." ]
            # [ inline ( always ) ]
            pub fn pin25(&self) -> Pin25R {
                Pin25R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 25;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 26 - Pin 26." ]
            # [ inline ( always ) ]
            pub fn pin26(&self) -> Pin26R {
                Pin26R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 26;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 27 - Pin 27." ]
            # [ inline ( always ) ]
            pub fn pin27(&self) -> Pin27R {
                Pin27R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 27;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 28 - Pin 28." ]
            # [ inline ( always ) ]
            pub fn pin28(&self) -> Pin28R {
                Pin28R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 28;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 29 - Pin 29." ]
            # [ inline ( always ) ]
            pub fn pin29(&self) -> Pin29R {
                Pin29R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 29;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 30 - Pin 30." ]
            # [ inline ( always ) ]
            pub fn pin30(&self) -> Pin30R {
                Pin30R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 30;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 31 - Pin 31." ]
            # [ inline ( always ) ]
            pub fn pin31(&self) -> Pin31R {
                Pin31R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Pin 0." ]
            # [ inline ( always ) ]
            pub fn pin0(&mut self) -> _Pin0W {
                _Pin0W { w: self }
            }
            # [ doc = "Bit 1 - Pin 1." ]
            # [ inline ( always ) ]
            pub fn pin1(&mut self) -> _Pin1W {
                _Pin1W { w: self }
            }
            # [ doc = "Bit 2 - Pin 2." ]
            # [ inline ( always ) ]
            pub fn pin2(&mut self) -> _Pin2W {
                _Pin2W { w: self }
            }
            # [ doc = "Bit 3 - Pin 3." ]
            # [ inline ( always ) ]
            pub fn pin3(&mut self) -> _Pin3W {
                _Pin3W { w: self }
            }
            # [ doc = "Bit 4 - Pin 4." ]
            # [ inline ( always ) ]
            pub fn pin4(&mut self) -> _Pin4W {
                _Pin4W { w: self }
            }
            # [ doc = "Bit 5 - Pin 5." ]
            # [ inline ( always ) ]
            pub fn pin5(&mut self) -> _Pin5W {
                _Pin5W { w: self }
            }
            # [ doc = "Bit 6 - Pin 6." ]
            # [ inline ( always ) ]
            pub fn pin6(&mut self) -> _Pin6W {
                _Pin6W { w: self }
            }
            # [ doc = "Bit 7 - Pin 7." ]
            # [ inline ( always ) ]
            pub fn pin7(&mut self) -> _Pin7W {
                _Pin7W { w: self }
            }
            # [ doc = "Bit 8 - Pin 8." ]
            # [ inline ( always ) ]
            pub fn pin8(&mut self) -> _Pin8W {
                _Pin8W { w: self }
            }
            # [ doc = "Bit 9 - Pin 9." ]
            # [ inline ( always ) ]
            pub fn pin9(&mut self) -> _Pin9W {
                _Pin9W { w: self }
            }
            # [ doc = "Bit 10 - Pin 10." ]
            # [ inline ( always ) ]
            pub fn pin10(&mut self) -> _Pin10W {
                _Pin10W { w: self }
            }
            # [ doc = "Bit 11 - Pin 11." ]
            # [ inline ( always ) ]
            pub fn pin11(&mut self) -> _Pin11W {
                _Pin11W { w: self }
            }
            # [ doc = "Bit 12 - Pin 12." ]
            # [ inline ( always ) ]
            pub fn pin12(&mut self) -> _Pin12W {
                _Pin12W { w: self }
            }
            # [ doc = "Bit 13 - Pin 13." ]
            # [ inline ( always ) ]
            pub fn pin13(&mut self) -> _Pin13W {
                _Pin13W { w: self }
            }
            # [ doc = "Bit 14 - Pin 14." ]
            # [ inline ( always ) ]
            pub fn pin14(&mut self) -> _Pin14W {
                _Pin14W { w: self }
            }
            # [ doc = "Bit 15 - Pin 15." ]
            # [ inline ( always ) ]
            pub fn pin15(&mut self) -> _Pin15W {
                _Pin15W { w: self }
            }
            # [ doc = "Bit 16 - Pin 16." ]
            # [ inline ( always ) ]
            pub fn pin16(&mut self) -> _Pin16W {
                _Pin16W { w: self }
            }
            # [ doc = "Bit 17 - Pin 17." ]
            # [ inline ( always ) ]
            pub fn pin17(&mut self) -> _Pin17W {
                _Pin17W { w: self }
            }
            # [ doc = "Bit 18 - Pin 18." ]
            # [ inline ( always ) ]
            pub fn pin18(&mut self) -> _Pin18W {
                _Pin18W { w: self }
            }
            # [ doc = "Bit 19 - Pin 19." ]
            # [ inline ( always ) ]
            pub fn pin19(&mut self) -> _Pin19W {
                _Pin19W { w: self }
            }
            # [ doc = "Bit 20 - Pin 20." ]
            # [ inline ( always ) ]
            pub fn pin20(&mut self) -> _Pin20W {
                _Pin20W { w: self }
            }
            # [ doc = "Bit 21 - Pin 21." ]
            # [ inline ( always ) ]
            pub fn pin21(&mut self) -> _Pin21W {
                _Pin21W { w: self }
            }
            # [ doc = "Bit 22 - Pin 22." ]
            # [ inline ( always ) ]
            pub fn pin22(&mut self) -> _Pin22W {
                _Pin22W { w: self }
            }
            # [ doc = "Bit 23 - Pin 23." ]
            # [ inline ( always ) ]
            pub fn pin23(&mut self) -> _Pin23W {
                _Pin23W { w: self }
            }
            # [ doc = "Bit 24 - Pin 24." ]
            # [ inline ( always ) ]
            pub fn pin24(&mut self) -> _Pin24W {
                _Pin24W { w: self }
            }
            # [ doc = "Bit 25 - Pin 25." ]
            # [ inline ( always ) ]
            pub fn pin25(&mut self) -> _Pin25W {
                _Pin25W { w: self }
            }
            # [ doc = "Bit 26 - Pin 26." ]
            # [ inline ( always ) ]
            pub fn pin26(&mut self) -> _Pin26W {
                _Pin26W { w: self }
            }
            # [ doc = "Bit 27 - Pin 27." ]
            # [ inline ( always ) ]
            pub fn pin27(&mut self) -> _Pin27W {
                _Pin27W { w: self }
            }
            # [ doc = "Bit 28 - Pin 28." ]
            # [ inline ( always ) ]
            pub fn pin28(&mut self) -> _Pin28W {
                _Pin28W { w: self }
            }
            # [ doc = "Bit 29 - Pin 29." ]
            # [ inline ( always ) ]
            pub fn pin29(&mut self) -> _Pin29W {
                _Pin29W { w: self }
            }
            # [ doc = "Bit 30 - Pin 30." ]
            # [ inline ( always ) ]
            pub fn pin30(&mut self) -> _Pin30W {
                _Pin30W { w: self }
            }
            # [ doc = "Bit 31 - Pin 31." ]
            # [ inline ( always ) ]
            pub fn pin31(&mut self) -> _Pin31W {
                _Pin31W { w: self }
            }
        }
    }
    # [ doc = "Clear individual bits in GPIO port." ]
    pub struct Outclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Clear individual bits in GPIO port." ]
    pub mod outclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Outclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `PIN0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin0R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin0R::Low => 0,
                    Pin0R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin0R {
                match bits {
                    0 => Pin0R::Low,
                    1 => Pin0R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin0R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin0R::High
            }
        }
        # [ doc = "Possible values of the field `PIN1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin1R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin1R::Low => 0,
                    Pin1R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin1R {
                match bits {
                    0 => Pin1R::Low,
                    1 => Pin1R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin1R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin1R::High
            }
        }
        # [ doc = "Possible values of the field `PIN2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin2R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin2R::Low => 0,
                    Pin2R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin2R {
                match bits {
                    0 => Pin2R::Low,
                    1 => Pin2R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin2R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin2R::High
            }
        }
        # [ doc = "Possible values of the field `PIN3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin3R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin3R::Low => 0,
                    Pin3R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin3R {
                match bits {
                    0 => Pin3R::Low,
                    1 => Pin3R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin3R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin3R::High
            }
        }
        # [ doc = "Possible values of the field `PIN4`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin4R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin4R::Low => 0,
                    Pin4R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin4R {
                match bits {
                    0 => Pin4R::Low,
                    1 => Pin4R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin4R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin4R::High
            }
        }
        # [ doc = "Possible values of the field `PIN5`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin5R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin5R::Low => 0,
                    Pin5R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin5R {
                match bits {
                    0 => Pin5R::Low,
                    1 => Pin5R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin5R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin5R::High
            }
        }
        # [ doc = "Possible values of the field `PIN6`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin6R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin6R::Low => 0,
                    Pin6R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin6R {
                match bits {
                    0 => Pin6R::Low,
                    1 => Pin6R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin6R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin6R::High
            }
        }
        # [ doc = "Possible values of the field `PIN7`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin7R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin7R::Low => 0,
                    Pin7R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin7R {
                match bits {
                    0 => Pin7R::Low,
                    1 => Pin7R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin7R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin7R::High
            }
        }
        # [ doc = "Possible values of the field `PIN8`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin8R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin8R::Low => 0,
                    Pin8R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin8R {
                match bits {
                    0 => Pin8R::Low,
                    1 => Pin8R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin8R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin8R::High
            }
        }
        # [ doc = "Possible values of the field `PIN9`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin9R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin9R::Low => 0,
                    Pin9R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin9R {
                match bits {
                    0 => Pin9R::Low,
                    1 => Pin9R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin9R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin9R::High
            }
        }
        # [ doc = "Possible values of the field `PIN10`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin10R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin10R::Low => 0,
                    Pin10R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin10R {
                match bits {
                    0 => Pin10R::Low,
                    1 => Pin10R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin10R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin10R::High
            }
        }
        # [ doc = "Possible values of the field `PIN11`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin11R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin11R::Low => 0,
                    Pin11R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin11R {
                match bits {
                    0 => Pin11R::Low,
                    1 => Pin11R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin11R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin11R::High
            }
        }
        # [ doc = "Possible values of the field `PIN12`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin12R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin12R::Low => 0,
                    Pin12R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin12R {
                match bits {
                    0 => Pin12R::Low,
                    1 => Pin12R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin12R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin12R::High
            }
        }
        # [ doc = "Possible values of the field `PIN13`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin13R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin13R::Low => 0,
                    Pin13R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin13R {
                match bits {
                    0 => Pin13R::Low,
                    1 => Pin13R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin13R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin13R::High
            }
        }
        # [ doc = "Possible values of the field `PIN14`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin14R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin14R::Low => 0,
                    Pin14R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin14R {
                match bits {
                    0 => Pin14R::Low,
                    1 => Pin14R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin14R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin14R::High
            }
        }
        # [ doc = "Possible values of the field `PIN15`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin15R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin15R::Low => 0,
                    Pin15R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin15R {
                match bits {
                    0 => Pin15R::Low,
                    1 => Pin15R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin15R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin15R::High
            }
        }
        # [ doc = "Possible values of the field `PIN16`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin16R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin16R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin16R::Low => 0,
                    Pin16R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin16R {
                match bits {
                    0 => Pin16R::Low,
                    1 => Pin16R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin16R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin16R::High
            }
        }
        # [ doc = "Possible values of the field `PIN17`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin17R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin17R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin17R::Low => 0,
                    Pin17R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin17R {
                match bits {
                    0 => Pin17R::Low,
                    1 => Pin17R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin17R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin17R::High
            }
        }
        # [ doc = "Possible values of the field `PIN18`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin18R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin18R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin18R::Low => 0,
                    Pin18R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin18R {
                match bits {
                    0 => Pin18R::Low,
                    1 => Pin18R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin18R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin18R::High
            }
        }
        # [ doc = "Possible values of the field `PIN19`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin19R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin19R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin19R::Low => 0,
                    Pin19R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin19R {
                match bits {
                    0 => Pin19R::Low,
                    1 => Pin19R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin19R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin19R::High
            }
        }
        # [ doc = "Possible values of the field `PIN20`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin20R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin20R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin20R::Low => 0,
                    Pin20R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin20R {
                match bits {
                    0 => Pin20R::Low,
                    1 => Pin20R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin20R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin20R::High
            }
        }
        # [ doc = "Possible values of the field `PIN21`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin21R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin21R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin21R::Low => 0,
                    Pin21R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin21R {
                match bits {
                    0 => Pin21R::Low,
                    1 => Pin21R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin21R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin21R::High
            }
        }
        # [ doc = "Possible values of the field `PIN22`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin22R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin22R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin22R::Low => 0,
                    Pin22R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin22R {
                match bits {
                    0 => Pin22R::Low,
                    1 => Pin22R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin22R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin22R::High
            }
        }
        # [ doc = "Possible values of the field `PIN23`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin23R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin23R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin23R::Low => 0,
                    Pin23R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin23R {
                match bits {
                    0 => Pin23R::Low,
                    1 => Pin23R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin23R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin23R::High
            }
        }
        # [ doc = "Possible values of the field `PIN24`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin24R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin24R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin24R::Low => 0,
                    Pin24R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin24R {
                match bits {
                    0 => Pin24R::Low,
                    1 => Pin24R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin24R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin24R::High
            }
        }
        # [ doc = "Possible values of the field `PIN25`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin25R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin25R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin25R::Low => 0,
                    Pin25R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin25R {
                match bits {
                    0 => Pin25R::Low,
                    1 => Pin25R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin25R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin25R::High
            }
        }
        # [ doc = "Possible values of the field `PIN26`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin26R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin26R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin26R::Low => 0,
                    Pin26R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin26R {
                match bits {
                    0 => Pin26R::Low,
                    1 => Pin26R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin26R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin26R::High
            }
        }
        # [ doc = "Possible values of the field `PIN27`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin27R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin27R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin27R::Low => 0,
                    Pin27R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin27R {
                match bits {
                    0 => Pin27R::Low,
                    1 => Pin27R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin27R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin27R::High
            }
        }
        # [ doc = "Possible values of the field `PIN28`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin28R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin28R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin28R::Low => 0,
                    Pin28R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin28R {
                match bits {
                    0 => Pin28R::Low,
                    1 => Pin28R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin28R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin28R::High
            }
        }
        # [ doc = "Possible values of the field `PIN29`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin29R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin29R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin29R::Low => 0,
                    Pin29R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin29R {
                match bits {
                    0 => Pin29R::Low,
                    1 => Pin29R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin29R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin29R::High
            }
        }
        # [ doc = "Possible values of the field `PIN30`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin30R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin30R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin30R::Low => 0,
                    Pin30R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin30R {
                match bits {
                    0 => Pin30R::Low,
                    1 => Pin30R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin30R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin30R::High
            }
        }
        # [ doc = "Possible values of the field `PIN31`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin31R {
            # [ doc = "Pin driver is low." ]
            Low,
            # [ doc = "Pin driver is high." ]
            High,
        }
        impl Pin31R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin31R::Low => 0,
                    Pin31R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin31R {
                match bits {
                    0 => Pin31R::Low,
                    1 => Pin31R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin31R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin31R::High
            }
        }
        # [ doc = "Values that can be written to the field `PIN0`" ]
        pub enum Pin0W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin0W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin0W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN1`" ]
        pub enum Pin1W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin1W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin1W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN2`" ]
        pub enum Pin2W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin2W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin2W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN3`" ]
        pub enum Pin3W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin3W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin3W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN4`" ]
        pub enum Pin4W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin4W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin4W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin4W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin4W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN5`" ]
        pub enum Pin5W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin5W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin5W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin5W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin5W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN6`" ]
        pub enum Pin6W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin6W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin6W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin6W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin6W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN7`" ]
        pub enum Pin7W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin7W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin7W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin7W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin7W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN8`" ]
        pub enum Pin8W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin8W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin8W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin8W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin8W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN9`" ]
        pub enum Pin9W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin9W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin9W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin9W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin9W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN10`" ]
        pub enum Pin10W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin10W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin10W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin10W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin10W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN11`" ]
        pub enum Pin11W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin11W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin11W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin11W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin11W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN12`" ]
        pub enum Pin12W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin12W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin12W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin12W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin12W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN13`" ]
        pub enum Pin13W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin13W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin13W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin13W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin13W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN14`" ]
        pub enum Pin14W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin14W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin14W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin14W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin14W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN15`" ]
        pub enum Pin15W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin15W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin15W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin15W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin15W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN16`" ]
        pub enum Pin16W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin16W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin16W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin16W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin16W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin16W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN17`" ]
        pub enum Pin17W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin17W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin17W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin17W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin17W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin17W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN18`" ]
        pub enum Pin18W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin18W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin18W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin18W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin18W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin18W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN19`" ]
        pub enum Pin19W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin19W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin19W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin19W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin19W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin19W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN20`" ]
        pub enum Pin20W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin20W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin20W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin20W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin20W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin20W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN21`" ]
        pub enum Pin21W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin21W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin21W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin21W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin21W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin21W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN22`" ]
        pub enum Pin22W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin22W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin22W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin22W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin22W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin22W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN23`" ]
        pub enum Pin23W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin23W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin23W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin23W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin23W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin23W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN24`" ]
        pub enum Pin24W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin24W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin24W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin24W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin24W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin24W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN25`" ]
        pub enum Pin25W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin25W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin25W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin25W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin25W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin25W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN26`" ]
        pub enum Pin26W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin26W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin26W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin26W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin26W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin26W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN27`" ]
        pub enum Pin27W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin27W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin27W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin27W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin27W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin27W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN28`" ]
        pub enum Pin28W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin28W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin28W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin28W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin28W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin28W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN29`" ]
        pub enum Pin29W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin29W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin29W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin29W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin29W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin29W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN30`" ]
        pub enum Pin30W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin30W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin30W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin30W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin30W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin30W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN31`" ]
        pub enum Pin31W {
            # [ doc = "Set pin driver low." ]
            Clear,
        }
        impl Pin31W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin31W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin31W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin31W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin driver low." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin31W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Pin 0." ]
            # [ inline ( always ) ]
            pub fn pin0(&self) -> Pin0R {
                Pin0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Pin 1." ]
            # [ inline ( always ) ]
            pub fn pin1(&self) -> Pin1R {
                Pin1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Pin 2." ]
            # [ inline ( always ) ]
            pub fn pin2(&self) -> Pin2R {
                Pin2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Pin 3." ]
            # [ inline ( always ) ]
            pub fn pin3(&self) -> Pin3R {
                Pin3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Pin 4." ]
            # [ inline ( always ) ]
            pub fn pin4(&self) -> Pin4R {
                Pin4R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Pin 5." ]
            # [ inline ( always ) ]
            pub fn pin5(&self) -> Pin5R {
                Pin5R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Pin 6." ]
            # [ inline ( always ) ]
            pub fn pin6(&self) -> Pin6R {
                Pin6R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Pin 7." ]
            # [ inline ( always ) ]
            pub fn pin7(&self) -> Pin7R {
                Pin7R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Pin 8." ]
            # [ inline ( always ) ]
            pub fn pin8(&self) -> Pin8R {
                Pin8R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Pin 9." ]
            # [ inline ( always ) ]
            pub fn pin9(&self) -> Pin9R {
                Pin9R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Pin 10." ]
            # [ inline ( always ) ]
            pub fn pin10(&self) -> Pin10R {
                Pin10R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 11 - Pin 11." ]
            # [ inline ( always ) ]
            pub fn pin11(&self) -> Pin11R {
                Pin11R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 12 - Pin 12." ]
            # [ inline ( always ) ]
            pub fn pin12(&self) -> Pin12R {
                Pin12R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 13 - Pin 13." ]
            # [ inline ( always ) ]
            pub fn pin13(&self) -> Pin13R {
                Pin13R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 13;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 14 - Pin 14." ]
            # [ inline ( always ) ]
            pub fn pin14(&self) -> Pin14R {
                Pin14R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 15 - Pin 15." ]
            # [ inline ( always ) ]
            pub fn pin15(&self) -> Pin15R {
                Pin15R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 15;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - Pin 16." ]
            # [ inline ( always ) ]
            pub fn pin16(&self) -> Pin16R {
                Pin16R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Pin 17." ]
            # [ inline ( always ) ]
            pub fn pin17(&self) -> Pin17R {
                Pin17R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Pin 18." ]
            # [ inline ( always ) ]
            pub fn pin18(&self) -> Pin18R {
                Pin18R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Pin 19." ]
            # [ inline ( always ) ]
            pub fn pin19(&self) -> Pin19R {
                Pin19R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 20 - Pin 20." ]
            # [ inline ( always ) ]
            pub fn pin20(&self) -> Pin20R {
                Pin20R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 20;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 21 - Pin 21." ]
            # [ inline ( always ) ]
            pub fn pin21(&self) -> Pin21R {
                Pin21R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 21;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 22 - Pin 22." ]
            # [ inline ( always ) ]
            pub fn pin22(&self) -> Pin22R {
                Pin22R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 22;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 23 - Pin 23." ]
            # [ inline ( always ) ]
            pub fn pin23(&self) -> Pin23R {
                Pin23R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 23;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 24 - Pin 24." ]
            # [ inline ( always ) ]
            pub fn pin24(&self) -> Pin24R {
                Pin24R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 24;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 25 - Pin 25." ]
            # [ inline ( always ) ]
            pub fn pin25(&self) -> Pin25R {
                Pin25R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 25;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 26 - Pin 26." ]
            # [ inline ( always ) ]
            pub fn pin26(&self) -> Pin26R {
                Pin26R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 26;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 27 - Pin 27." ]
            # [ inline ( always ) ]
            pub fn pin27(&self) -> Pin27R {
                Pin27R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 27;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 28 - Pin 28." ]
            # [ inline ( always ) ]
            pub fn pin28(&self) -> Pin28R {
                Pin28R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 28;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 29 - Pin 29." ]
            # [ inline ( always ) ]
            pub fn pin29(&self) -> Pin29R {
                Pin29R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 29;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 30 - Pin 30." ]
            # [ inline ( always ) ]
            pub fn pin30(&self) -> Pin30R {
                Pin30R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 30;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 31 - Pin 31." ]
            # [ inline ( always ) ]
            pub fn pin31(&self) -> Pin31R {
                Pin31R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Pin 0." ]
            # [ inline ( always ) ]
            pub fn pin0(&mut self) -> _Pin0W {
                _Pin0W { w: self }
            }
            # [ doc = "Bit 1 - Pin 1." ]
            # [ inline ( always ) ]
            pub fn pin1(&mut self) -> _Pin1W {
                _Pin1W { w: self }
            }
            # [ doc = "Bit 2 - Pin 2." ]
            # [ inline ( always ) ]
            pub fn pin2(&mut self) -> _Pin2W {
                _Pin2W { w: self }
            }
            # [ doc = "Bit 3 - Pin 3." ]
            # [ inline ( always ) ]
            pub fn pin3(&mut self) -> _Pin3W {
                _Pin3W { w: self }
            }
            # [ doc = "Bit 4 - Pin 4." ]
            # [ inline ( always ) ]
            pub fn pin4(&mut self) -> _Pin4W {
                _Pin4W { w: self }
            }
            # [ doc = "Bit 5 - Pin 5." ]
            # [ inline ( always ) ]
            pub fn pin5(&mut self) -> _Pin5W {
                _Pin5W { w: self }
            }
            # [ doc = "Bit 6 - Pin 6." ]
            # [ inline ( always ) ]
            pub fn pin6(&mut self) -> _Pin6W {
                _Pin6W { w: self }
            }
            # [ doc = "Bit 7 - Pin 7." ]
            # [ inline ( always ) ]
            pub fn pin7(&mut self) -> _Pin7W {
                _Pin7W { w: self }
            }
            # [ doc = "Bit 8 - Pin 8." ]
            # [ inline ( always ) ]
            pub fn pin8(&mut self) -> _Pin8W {
                _Pin8W { w: self }
            }
            # [ doc = "Bit 9 - Pin 9." ]
            # [ inline ( always ) ]
            pub fn pin9(&mut self) -> _Pin9W {
                _Pin9W { w: self }
            }
            # [ doc = "Bit 10 - Pin 10." ]
            # [ inline ( always ) ]
            pub fn pin10(&mut self) -> _Pin10W {
                _Pin10W { w: self }
            }
            # [ doc = "Bit 11 - Pin 11." ]
            # [ inline ( always ) ]
            pub fn pin11(&mut self) -> _Pin11W {
                _Pin11W { w: self }
            }
            # [ doc = "Bit 12 - Pin 12." ]
            # [ inline ( always ) ]
            pub fn pin12(&mut self) -> _Pin12W {
                _Pin12W { w: self }
            }
            # [ doc = "Bit 13 - Pin 13." ]
            # [ inline ( always ) ]
            pub fn pin13(&mut self) -> _Pin13W {
                _Pin13W { w: self }
            }
            # [ doc = "Bit 14 - Pin 14." ]
            # [ inline ( always ) ]
            pub fn pin14(&mut self) -> _Pin14W {
                _Pin14W { w: self }
            }
            # [ doc = "Bit 15 - Pin 15." ]
            # [ inline ( always ) ]
            pub fn pin15(&mut self) -> _Pin15W {
                _Pin15W { w: self }
            }
            # [ doc = "Bit 16 - Pin 16." ]
            # [ inline ( always ) ]
            pub fn pin16(&mut self) -> _Pin16W {
                _Pin16W { w: self }
            }
            # [ doc = "Bit 17 - Pin 17." ]
            # [ inline ( always ) ]
            pub fn pin17(&mut self) -> _Pin17W {
                _Pin17W { w: self }
            }
            # [ doc = "Bit 18 - Pin 18." ]
            # [ inline ( always ) ]
            pub fn pin18(&mut self) -> _Pin18W {
                _Pin18W { w: self }
            }
            # [ doc = "Bit 19 - Pin 19." ]
            # [ inline ( always ) ]
            pub fn pin19(&mut self) -> _Pin19W {
                _Pin19W { w: self }
            }
            # [ doc = "Bit 20 - Pin 20." ]
            # [ inline ( always ) ]
            pub fn pin20(&mut self) -> _Pin20W {
                _Pin20W { w: self }
            }
            # [ doc = "Bit 21 - Pin 21." ]
            # [ inline ( always ) ]
            pub fn pin21(&mut self) -> _Pin21W {
                _Pin21W { w: self }
            }
            # [ doc = "Bit 22 - Pin 22." ]
            # [ inline ( always ) ]
            pub fn pin22(&mut self) -> _Pin22W {
                _Pin22W { w: self }
            }
            # [ doc = "Bit 23 - Pin 23." ]
            # [ inline ( always ) ]
            pub fn pin23(&mut self) -> _Pin23W {
                _Pin23W { w: self }
            }
            # [ doc = "Bit 24 - Pin 24." ]
            # [ inline ( always ) ]
            pub fn pin24(&mut self) -> _Pin24W {
                _Pin24W { w: self }
            }
            # [ doc = "Bit 25 - Pin 25." ]
            # [ inline ( always ) ]
            pub fn pin25(&mut self) -> _Pin25W {
                _Pin25W { w: self }
            }
            # [ doc = "Bit 26 - Pin 26." ]
            # [ inline ( always ) ]
            pub fn pin26(&mut self) -> _Pin26W {
                _Pin26W { w: self }
            }
            # [ doc = "Bit 27 - Pin 27." ]
            # [ inline ( always ) ]
            pub fn pin27(&mut self) -> _Pin27W {
                _Pin27W { w: self }
            }
            # [ doc = "Bit 28 - Pin 28." ]
            # [ inline ( always ) ]
            pub fn pin28(&mut self) -> _Pin28W {
                _Pin28W { w: self }
            }
            # [ doc = "Bit 29 - Pin 29." ]
            # [ inline ( always ) ]
            pub fn pin29(&mut self) -> _Pin29W {
                _Pin29W { w: self }
            }
            # [ doc = "Bit 30 - Pin 30." ]
            # [ inline ( always ) ]
            pub fn pin30(&mut self) -> _Pin30W {
                _Pin30W { w: self }
            }
            # [ doc = "Bit 31 - Pin 31." ]
            # [ inline ( always ) ]
            pub fn pin31(&mut self) -> _Pin31W {
                _Pin31W { w: self }
            }
        }
    }
    # [ doc = "Read GPIO port." ]
    pub struct In {
        register: VolatileCell<u32>,
    }
    # [ doc = "Read GPIO port." ]
    pub mod in_ {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::In {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = "Possible values of the field `PIN0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin0R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin0R::Low => 0,
                    Pin0R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin0R {
                match bits {
                    0 => Pin0R::Low,
                    1 => Pin0R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin0R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin0R::High
            }
        }
        # [ doc = "Possible values of the field `PIN1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin1R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin1R::Low => 0,
                    Pin1R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin1R {
                match bits {
                    0 => Pin1R::Low,
                    1 => Pin1R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin1R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin1R::High
            }
        }
        # [ doc = "Possible values of the field `PIN2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin2R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin2R::Low => 0,
                    Pin2R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin2R {
                match bits {
                    0 => Pin2R::Low,
                    1 => Pin2R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin2R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin2R::High
            }
        }
        # [ doc = "Possible values of the field `PIN3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin3R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin3R::Low => 0,
                    Pin3R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin3R {
                match bits {
                    0 => Pin3R::Low,
                    1 => Pin3R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin3R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin3R::High
            }
        }
        # [ doc = "Possible values of the field `PIN4`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin4R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin4R::Low => 0,
                    Pin4R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin4R {
                match bits {
                    0 => Pin4R::Low,
                    1 => Pin4R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin4R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin4R::High
            }
        }
        # [ doc = "Possible values of the field `PIN5`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin5R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin5R::Low => 0,
                    Pin5R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin5R {
                match bits {
                    0 => Pin5R::Low,
                    1 => Pin5R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin5R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin5R::High
            }
        }
        # [ doc = "Possible values of the field `PIN6`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin6R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin6R::Low => 0,
                    Pin6R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin6R {
                match bits {
                    0 => Pin6R::Low,
                    1 => Pin6R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin6R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin6R::High
            }
        }
        # [ doc = "Possible values of the field `PIN7`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin7R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin7R::Low => 0,
                    Pin7R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin7R {
                match bits {
                    0 => Pin7R::Low,
                    1 => Pin7R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin7R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin7R::High
            }
        }
        # [ doc = "Possible values of the field `PIN8`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin8R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin8R::Low => 0,
                    Pin8R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin8R {
                match bits {
                    0 => Pin8R::Low,
                    1 => Pin8R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin8R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin8R::High
            }
        }
        # [ doc = "Possible values of the field `PIN9`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin9R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin9R::Low => 0,
                    Pin9R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin9R {
                match bits {
                    0 => Pin9R::Low,
                    1 => Pin9R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin9R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin9R::High
            }
        }
        # [ doc = "Possible values of the field `PIN10`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin10R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin10R::Low => 0,
                    Pin10R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin10R {
                match bits {
                    0 => Pin10R::Low,
                    1 => Pin10R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin10R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin10R::High
            }
        }
        # [ doc = "Possible values of the field `PIN11`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin11R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin11R::Low => 0,
                    Pin11R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin11R {
                match bits {
                    0 => Pin11R::Low,
                    1 => Pin11R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin11R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin11R::High
            }
        }
        # [ doc = "Possible values of the field `PIN12`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin12R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin12R::Low => 0,
                    Pin12R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin12R {
                match bits {
                    0 => Pin12R::Low,
                    1 => Pin12R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin12R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin12R::High
            }
        }
        # [ doc = "Possible values of the field `PIN13`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin13R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin13R::Low => 0,
                    Pin13R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin13R {
                match bits {
                    0 => Pin13R::Low,
                    1 => Pin13R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin13R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin13R::High
            }
        }
        # [ doc = "Possible values of the field `PIN14`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin14R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin14R::Low => 0,
                    Pin14R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin14R {
                match bits {
                    0 => Pin14R::Low,
                    1 => Pin14R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin14R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin14R::High
            }
        }
        # [ doc = "Possible values of the field `PIN15`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin15R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin15R::Low => 0,
                    Pin15R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin15R {
                match bits {
                    0 => Pin15R::Low,
                    1 => Pin15R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin15R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin15R::High
            }
        }
        # [ doc = "Possible values of the field `PIN16`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin16R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin16R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin16R::Low => 0,
                    Pin16R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin16R {
                match bits {
                    0 => Pin16R::Low,
                    1 => Pin16R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin16R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin16R::High
            }
        }
        # [ doc = "Possible values of the field `PIN17`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin17R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin17R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin17R::Low => 0,
                    Pin17R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin17R {
                match bits {
                    0 => Pin17R::Low,
                    1 => Pin17R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin17R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin17R::High
            }
        }
        # [ doc = "Possible values of the field `PIN18`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin18R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin18R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin18R::Low => 0,
                    Pin18R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin18R {
                match bits {
                    0 => Pin18R::Low,
                    1 => Pin18R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin18R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin18R::High
            }
        }
        # [ doc = "Possible values of the field `PIN19`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin19R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin19R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin19R::Low => 0,
                    Pin19R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin19R {
                match bits {
                    0 => Pin19R::Low,
                    1 => Pin19R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin19R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin19R::High
            }
        }
        # [ doc = "Possible values of the field `PIN20`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin20R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin20R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin20R::Low => 0,
                    Pin20R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin20R {
                match bits {
                    0 => Pin20R::Low,
                    1 => Pin20R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin20R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin20R::High
            }
        }
        # [ doc = "Possible values of the field `PIN21`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin21R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin21R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin21R::Low => 0,
                    Pin21R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin21R {
                match bits {
                    0 => Pin21R::Low,
                    1 => Pin21R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin21R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin21R::High
            }
        }
        # [ doc = "Possible values of the field `PIN22`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin22R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin22R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin22R::Low => 0,
                    Pin22R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin22R {
                match bits {
                    0 => Pin22R::Low,
                    1 => Pin22R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin22R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin22R::High
            }
        }
        # [ doc = "Possible values of the field `PIN23`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin23R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin23R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin23R::Low => 0,
                    Pin23R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin23R {
                match bits {
                    0 => Pin23R::Low,
                    1 => Pin23R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin23R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin23R::High
            }
        }
        # [ doc = "Possible values of the field `PIN24`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin24R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin24R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin24R::Low => 0,
                    Pin24R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin24R {
                match bits {
                    0 => Pin24R::Low,
                    1 => Pin24R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin24R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin24R::High
            }
        }
        # [ doc = "Possible values of the field `PIN25`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin25R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin25R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin25R::Low => 0,
                    Pin25R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin25R {
                match bits {
                    0 => Pin25R::Low,
                    1 => Pin25R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin25R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin25R::High
            }
        }
        # [ doc = "Possible values of the field `PIN26`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin26R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin26R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin26R::Low => 0,
                    Pin26R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin26R {
                match bits {
                    0 => Pin26R::Low,
                    1 => Pin26R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin26R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin26R::High
            }
        }
        # [ doc = "Possible values of the field `PIN27`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin27R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin27R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin27R::Low => 0,
                    Pin27R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin27R {
                match bits {
                    0 => Pin27R::Low,
                    1 => Pin27R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin27R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin27R::High
            }
        }
        # [ doc = "Possible values of the field `PIN28`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin28R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin28R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin28R::Low => 0,
                    Pin28R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin28R {
                match bits {
                    0 => Pin28R::Low,
                    1 => Pin28R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin28R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin28R::High
            }
        }
        # [ doc = "Possible values of the field `PIN29`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin29R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin29R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin29R::Low => 0,
                    Pin29R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin29R {
                match bits {
                    0 => Pin29R::Low,
                    1 => Pin29R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin29R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin29R::High
            }
        }
        # [ doc = "Possible values of the field `PIN30`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin30R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin30R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin30R::Low => 0,
                    Pin30R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin30R {
                match bits {
                    0 => Pin30R::Low,
                    1 => Pin30R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin30R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin30R::High
            }
        }
        # [ doc = "Possible values of the field `PIN31`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin31R {
            # [ doc = "Pin input is low." ]
            Low,
            # [ doc = "Pin input is high." ]
            High,
        }
        impl Pin31R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin31R::Low => 0,
                    Pin31R::High => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin31R {
                match bits {
                    0 => Pin31R::Low,
                    1 => Pin31R::High,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == Pin31R::Low
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == Pin31R::High
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Pin 0." ]
            # [ inline ( always ) ]
            pub fn pin0(&self) -> Pin0R {
                Pin0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Pin 1." ]
            # [ inline ( always ) ]
            pub fn pin1(&self) -> Pin1R {
                Pin1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Pin 2." ]
            # [ inline ( always ) ]
            pub fn pin2(&self) -> Pin2R {
                Pin2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Pin 3." ]
            # [ inline ( always ) ]
            pub fn pin3(&self) -> Pin3R {
                Pin3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Pin 4." ]
            # [ inline ( always ) ]
            pub fn pin4(&self) -> Pin4R {
                Pin4R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Pin 5." ]
            # [ inline ( always ) ]
            pub fn pin5(&self) -> Pin5R {
                Pin5R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Pin 6." ]
            # [ inline ( always ) ]
            pub fn pin6(&self) -> Pin6R {
                Pin6R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Pin 7." ]
            # [ inline ( always ) ]
            pub fn pin7(&self) -> Pin7R {
                Pin7R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Pin 8." ]
            # [ inline ( always ) ]
            pub fn pin8(&self) -> Pin8R {
                Pin8R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Pin 9." ]
            # [ inline ( always ) ]
            pub fn pin9(&self) -> Pin9R {
                Pin9R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Pin 10." ]
            # [ inline ( always ) ]
            pub fn pin10(&self) -> Pin10R {
                Pin10R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 11 - Pin 11." ]
            # [ inline ( always ) ]
            pub fn pin11(&self) -> Pin11R {
                Pin11R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 12 - Pin 12." ]
            # [ inline ( always ) ]
            pub fn pin12(&self) -> Pin12R {
                Pin12R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 13 - Pin 13." ]
            # [ inline ( always ) ]
            pub fn pin13(&self) -> Pin13R {
                Pin13R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 13;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 14 - Pin 14." ]
            # [ inline ( always ) ]
            pub fn pin14(&self) -> Pin14R {
                Pin14R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 15 - Pin 15." ]
            # [ inline ( always ) ]
            pub fn pin15(&self) -> Pin15R {
                Pin15R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 15;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - Pin 16." ]
            # [ inline ( always ) ]
            pub fn pin16(&self) -> Pin16R {
                Pin16R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Pin 17." ]
            # [ inline ( always ) ]
            pub fn pin17(&self) -> Pin17R {
                Pin17R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Pin 18." ]
            # [ inline ( always ) ]
            pub fn pin18(&self) -> Pin18R {
                Pin18R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Pin 19." ]
            # [ inline ( always ) ]
            pub fn pin19(&self) -> Pin19R {
                Pin19R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 20 - Pin 20." ]
            # [ inline ( always ) ]
            pub fn pin20(&self) -> Pin20R {
                Pin20R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 20;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 21 - Pin 21." ]
            # [ inline ( always ) ]
            pub fn pin21(&self) -> Pin21R {
                Pin21R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 21;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 22 - Pin 22." ]
            # [ inline ( always ) ]
            pub fn pin22(&self) -> Pin22R {
                Pin22R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 22;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 23 - Pin 23." ]
            # [ inline ( always ) ]
            pub fn pin23(&self) -> Pin23R {
                Pin23R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 23;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 24 - Pin 24." ]
            # [ inline ( always ) ]
            pub fn pin24(&self) -> Pin24R {
                Pin24R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 24;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 25 - Pin 25." ]
            # [ inline ( always ) ]
            pub fn pin25(&self) -> Pin25R {
                Pin25R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 25;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 26 - Pin 26." ]
            # [ inline ( always ) ]
            pub fn pin26(&self) -> Pin26R {
                Pin26R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 26;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 27 - Pin 27." ]
            # [ inline ( always ) ]
            pub fn pin27(&self) -> Pin27R {
                Pin27R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 27;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 28 - Pin 28." ]
            # [ inline ( always ) ]
            pub fn pin28(&self) -> Pin28R {
                Pin28R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 28;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 29 - Pin 29." ]
            # [ inline ( always ) ]
            pub fn pin29(&self) -> Pin29R {
                Pin29R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 29;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 30 - Pin 30." ]
            # [ inline ( always ) ]
            pub fn pin30(&self) -> Pin30R {
                Pin30R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 30;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 31 - Pin 31." ]
            # [ inline ( always ) ]
            pub fn pin31(&self) -> Pin31R {
                Pin31R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
    }
    # [ doc = "Direction of GPIO pins." ]
    pub struct Dir {
        register: VolatileCell<u32>,
    }
    # [ doc = "Direction of GPIO pins." ]
    pub mod dir {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dir {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `PIN0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin0R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin0R::Input => 0,
                    Pin0R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin0R {
                match bits {
                    0 => Pin0R::Input,
                    1 => Pin0R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin0R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin0R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin1R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin1R::Input => 0,
                    Pin1R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin1R {
                match bits {
                    0 => Pin1R::Input,
                    1 => Pin1R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin1R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin1R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin2R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin2R::Input => 0,
                    Pin2R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin2R {
                match bits {
                    0 => Pin2R::Input,
                    1 => Pin2R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin2R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin2R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin3R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin3R::Input => 0,
                    Pin3R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin3R {
                match bits {
                    0 => Pin3R::Input,
                    1 => Pin3R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin3R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin3R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN4`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin4R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin4R::Input => 0,
                    Pin4R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin4R {
                match bits {
                    0 => Pin4R::Input,
                    1 => Pin4R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin4R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin4R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN5`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin5R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin5R::Input => 0,
                    Pin5R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin5R {
                match bits {
                    0 => Pin5R::Input,
                    1 => Pin5R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin5R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin5R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN6`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin6R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin6R::Input => 0,
                    Pin6R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin6R {
                match bits {
                    0 => Pin6R::Input,
                    1 => Pin6R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin6R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin6R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN7`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin7R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin7R::Input => 0,
                    Pin7R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin7R {
                match bits {
                    0 => Pin7R::Input,
                    1 => Pin7R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin7R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin7R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN8`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin8R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin8R::Input => 0,
                    Pin8R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin8R {
                match bits {
                    0 => Pin8R::Input,
                    1 => Pin8R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin8R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin8R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN9`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin9R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin9R::Input => 0,
                    Pin9R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin9R {
                match bits {
                    0 => Pin9R::Input,
                    1 => Pin9R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin9R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin9R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN10`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin10R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin10R::Input => 0,
                    Pin10R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin10R {
                match bits {
                    0 => Pin10R::Input,
                    1 => Pin10R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin10R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin10R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN11`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin11R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin11R::Input => 0,
                    Pin11R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin11R {
                match bits {
                    0 => Pin11R::Input,
                    1 => Pin11R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin11R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin11R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN12`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin12R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin12R::Input => 0,
                    Pin12R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin12R {
                match bits {
                    0 => Pin12R::Input,
                    1 => Pin12R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin12R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin12R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN13`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin13R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin13R::Input => 0,
                    Pin13R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin13R {
                match bits {
                    0 => Pin13R::Input,
                    1 => Pin13R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin13R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin13R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN14`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin14R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin14R::Input => 0,
                    Pin14R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin14R {
                match bits {
                    0 => Pin14R::Input,
                    1 => Pin14R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin14R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin14R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN15`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin15R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin15R::Input => 0,
                    Pin15R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin15R {
                match bits {
                    0 => Pin15R::Input,
                    1 => Pin15R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin15R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin15R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN16`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin16R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin16R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin16R::Input => 0,
                    Pin16R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin16R {
                match bits {
                    0 => Pin16R::Input,
                    1 => Pin16R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin16R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin16R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN17`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin17R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin17R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin17R::Input => 0,
                    Pin17R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin17R {
                match bits {
                    0 => Pin17R::Input,
                    1 => Pin17R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin17R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin17R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN18`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin18R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin18R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin18R::Input => 0,
                    Pin18R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin18R {
                match bits {
                    0 => Pin18R::Input,
                    1 => Pin18R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin18R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin18R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN19`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin19R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin19R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin19R::Input => 0,
                    Pin19R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin19R {
                match bits {
                    0 => Pin19R::Input,
                    1 => Pin19R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin19R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin19R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN20`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin20R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin20R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin20R::Input => 0,
                    Pin20R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin20R {
                match bits {
                    0 => Pin20R::Input,
                    1 => Pin20R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin20R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin20R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN21`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin21R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin21R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin21R::Input => 0,
                    Pin21R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin21R {
                match bits {
                    0 => Pin21R::Input,
                    1 => Pin21R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin21R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin21R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN22`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin22R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin22R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin22R::Input => 0,
                    Pin22R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin22R {
                match bits {
                    0 => Pin22R::Input,
                    1 => Pin22R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin22R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin22R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN23`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin23R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin23R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin23R::Input => 0,
                    Pin23R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin23R {
                match bits {
                    0 => Pin23R::Input,
                    1 => Pin23R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin23R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin23R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN24`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin24R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin24R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin24R::Input => 0,
                    Pin24R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin24R {
                match bits {
                    0 => Pin24R::Input,
                    1 => Pin24R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin24R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin24R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN25`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin25R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin25R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin25R::Input => 0,
                    Pin25R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin25R {
                match bits {
                    0 => Pin25R::Input,
                    1 => Pin25R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin25R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin25R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN26`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin26R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin26R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin26R::Input => 0,
                    Pin26R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin26R {
                match bits {
                    0 => Pin26R::Input,
                    1 => Pin26R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin26R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin26R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN27`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin27R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin27R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin27R::Input => 0,
                    Pin27R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin27R {
                match bits {
                    0 => Pin27R::Input,
                    1 => Pin27R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin27R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin27R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN28`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin28R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin28R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin28R::Input => 0,
                    Pin28R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin28R {
                match bits {
                    0 => Pin28R::Input,
                    1 => Pin28R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin28R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin28R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN29`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin29R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin29R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin29R::Input => 0,
                    Pin29R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin29R {
                match bits {
                    0 => Pin29R::Input,
                    1 => Pin29R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin29R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin29R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN30`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin30R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin30R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin30R::Input => 0,
                    Pin30R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin30R {
                match bits {
                    0 => Pin30R::Input,
                    1 => Pin30R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin30R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin30R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN31`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin31R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin31R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin31R::Input => 0,
                    Pin31R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin31R {
                match bits {
                    0 => Pin31R::Input,
                    1 => Pin31R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin31R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin31R::Output
            }
        }
        # [ doc = "Values that can be written to the field `PIN0`" ]
        pub enum Pin0W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin0W::Input => 0,
                    Pin0W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin0W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin0W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN1`" ]
        pub enum Pin1W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin1W::Input => 0,
                    Pin1W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin1W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin1W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN2`" ]
        pub enum Pin2W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin2W::Input => 0,
                    Pin2W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin2W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin2W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN3`" ]
        pub enum Pin3W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin3W::Input => 0,
                    Pin3W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin3W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin3W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN4`" ]
        pub enum Pin4W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin4W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin4W::Input => 0,
                    Pin4W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin4W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin4W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN5`" ]
        pub enum Pin5W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin5W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin5W::Input => 0,
                    Pin5W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin5W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin5W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN6`" ]
        pub enum Pin6W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin6W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin6W::Input => 0,
                    Pin6W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin6W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin6W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN7`" ]
        pub enum Pin7W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin7W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin7W::Input => 0,
                    Pin7W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin7W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin7W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN8`" ]
        pub enum Pin8W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin8W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin8W::Input => 0,
                    Pin8W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin8W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin8W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin8W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN9`" ]
        pub enum Pin9W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin9W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin9W::Input => 0,
                    Pin9W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin9W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin9W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin9W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN10`" ]
        pub enum Pin10W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin10W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin10W::Input => 0,
                    Pin10W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin10W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin10W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin10W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN11`" ]
        pub enum Pin11W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin11W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin11W::Input => 0,
                    Pin11W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin11W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin11W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin11W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN12`" ]
        pub enum Pin12W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin12W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin12W::Input => 0,
                    Pin12W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin12W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin12W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin12W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN13`" ]
        pub enum Pin13W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin13W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin13W::Input => 0,
                    Pin13W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin13W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin13W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin13W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN14`" ]
        pub enum Pin14W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin14W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin14W::Input => 0,
                    Pin14W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin14W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin14W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin14W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN15`" ]
        pub enum Pin15W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin15W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin15W::Input => 0,
                    Pin15W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin15W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin15W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin15W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN16`" ]
        pub enum Pin16W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin16W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin16W::Input => 0,
                    Pin16W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin16W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin16W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin16W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin16W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN17`" ]
        pub enum Pin17W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin17W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin17W::Input => 0,
                    Pin17W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin17W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin17W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin17W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin17W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN18`" ]
        pub enum Pin18W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin18W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin18W::Input => 0,
                    Pin18W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin18W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin18W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin18W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin18W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN19`" ]
        pub enum Pin19W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin19W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin19W::Input => 0,
                    Pin19W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin19W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin19W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin19W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin19W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN20`" ]
        pub enum Pin20W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin20W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin20W::Input => 0,
                    Pin20W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin20W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin20W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin20W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin20W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN21`" ]
        pub enum Pin21W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin21W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin21W::Input => 0,
                    Pin21W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin21W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin21W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin21W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin21W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN22`" ]
        pub enum Pin22W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin22W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin22W::Input => 0,
                    Pin22W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin22W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin22W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin22W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin22W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN23`" ]
        pub enum Pin23W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin23W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin23W::Input => 0,
                    Pin23W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin23W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin23W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin23W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin23W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN24`" ]
        pub enum Pin24W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin24W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin24W::Input => 0,
                    Pin24W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin24W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin24W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin24W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin24W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN25`" ]
        pub enum Pin25W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin25W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin25W::Input => 0,
                    Pin25W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin25W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin25W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin25W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin25W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN26`" ]
        pub enum Pin26W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin26W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin26W::Input => 0,
                    Pin26W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin26W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin26W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin26W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin26W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN27`" ]
        pub enum Pin27W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin27W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin27W::Input => 0,
                    Pin27W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin27W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin27W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin27W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin27W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN28`" ]
        pub enum Pin28W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin28W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin28W::Input => 0,
                    Pin28W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin28W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin28W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin28W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin28W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN29`" ]
        pub enum Pin29W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin29W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin29W::Input => 0,
                    Pin29W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin29W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin29W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin29W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin29W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN30`" ]
        pub enum Pin30W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin30W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin30W::Input => 0,
                    Pin30W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin30W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin30W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin30W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin30W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN31`" ]
        pub enum Pin31W {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin31W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin31W::Input => 0,
                    Pin31W::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin31W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin31W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Pin set as input." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Pin31W::Input)
            }
            # [ doc = "Pin set as output." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(Pin31W::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Pin 0." ]
            # [ inline ( always ) ]
            pub fn pin0(&self) -> Pin0R {
                Pin0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Pin 1." ]
            # [ inline ( always ) ]
            pub fn pin1(&self) -> Pin1R {
                Pin1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Pin 2." ]
            # [ inline ( always ) ]
            pub fn pin2(&self) -> Pin2R {
                Pin2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Pin 3." ]
            # [ inline ( always ) ]
            pub fn pin3(&self) -> Pin3R {
                Pin3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Pin 4." ]
            # [ inline ( always ) ]
            pub fn pin4(&self) -> Pin4R {
                Pin4R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Pin 5." ]
            # [ inline ( always ) ]
            pub fn pin5(&self) -> Pin5R {
                Pin5R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Pin 6." ]
            # [ inline ( always ) ]
            pub fn pin6(&self) -> Pin6R {
                Pin6R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Pin 7." ]
            # [ inline ( always ) ]
            pub fn pin7(&self) -> Pin7R {
                Pin7R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Pin 8." ]
            # [ inline ( always ) ]
            pub fn pin8(&self) -> Pin8R {
                Pin8R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Pin 9." ]
            # [ inline ( always ) ]
            pub fn pin9(&self) -> Pin9R {
                Pin9R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Pin 10." ]
            # [ inline ( always ) ]
            pub fn pin10(&self) -> Pin10R {
                Pin10R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 11 - Pin 11." ]
            # [ inline ( always ) ]
            pub fn pin11(&self) -> Pin11R {
                Pin11R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 12 - Pin 12." ]
            # [ inline ( always ) ]
            pub fn pin12(&self) -> Pin12R {
                Pin12R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 13 - Pin 13." ]
            # [ inline ( always ) ]
            pub fn pin13(&self) -> Pin13R {
                Pin13R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 13;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 14 - Pin 14." ]
            # [ inline ( always ) ]
            pub fn pin14(&self) -> Pin14R {
                Pin14R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 15 - Pin 15." ]
            # [ inline ( always ) ]
            pub fn pin15(&self) -> Pin15R {
                Pin15R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 15;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - Pin 16." ]
            # [ inline ( always ) ]
            pub fn pin16(&self) -> Pin16R {
                Pin16R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Pin 17." ]
            # [ inline ( always ) ]
            pub fn pin17(&self) -> Pin17R {
                Pin17R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Pin 18." ]
            # [ inline ( always ) ]
            pub fn pin18(&self) -> Pin18R {
                Pin18R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Pin 19." ]
            # [ inline ( always ) ]
            pub fn pin19(&self) -> Pin19R {
                Pin19R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 20 - Pin 20." ]
            # [ inline ( always ) ]
            pub fn pin20(&self) -> Pin20R {
                Pin20R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 20;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 21 - Pin 21." ]
            # [ inline ( always ) ]
            pub fn pin21(&self) -> Pin21R {
                Pin21R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 21;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 22 - Pin 22." ]
            # [ inline ( always ) ]
            pub fn pin22(&self) -> Pin22R {
                Pin22R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 22;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 23 - Pin 23." ]
            # [ inline ( always ) ]
            pub fn pin23(&self) -> Pin23R {
                Pin23R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 23;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 24 - Pin 24." ]
            # [ inline ( always ) ]
            pub fn pin24(&self) -> Pin24R {
                Pin24R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 24;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 25 - Pin 25." ]
            # [ inline ( always ) ]
            pub fn pin25(&self) -> Pin25R {
                Pin25R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 25;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 26 - Pin 26." ]
            # [ inline ( always ) ]
            pub fn pin26(&self) -> Pin26R {
                Pin26R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 26;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 27 - Pin 27." ]
            # [ inline ( always ) ]
            pub fn pin27(&self) -> Pin27R {
                Pin27R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 27;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 28 - Pin 28." ]
            # [ inline ( always ) ]
            pub fn pin28(&self) -> Pin28R {
                Pin28R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 28;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 29 - Pin 29." ]
            # [ inline ( always ) ]
            pub fn pin29(&self) -> Pin29R {
                Pin29R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 29;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 30 - Pin 30." ]
            # [ inline ( always ) ]
            pub fn pin30(&self) -> Pin30R {
                Pin30R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 30;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 31 - Pin 31." ]
            # [ inline ( always ) ]
            pub fn pin31(&self) -> Pin31R {
                Pin31R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Pin 0." ]
            # [ inline ( always ) ]
            pub fn pin0(&mut self) -> _Pin0W {
                _Pin0W { w: self }
            }
            # [ doc = "Bit 1 - Pin 1." ]
            # [ inline ( always ) ]
            pub fn pin1(&mut self) -> _Pin1W {
                _Pin1W { w: self }
            }
            # [ doc = "Bit 2 - Pin 2." ]
            # [ inline ( always ) ]
            pub fn pin2(&mut self) -> _Pin2W {
                _Pin2W { w: self }
            }
            # [ doc = "Bit 3 - Pin 3." ]
            # [ inline ( always ) ]
            pub fn pin3(&mut self) -> _Pin3W {
                _Pin3W { w: self }
            }
            # [ doc = "Bit 4 - Pin 4." ]
            # [ inline ( always ) ]
            pub fn pin4(&mut self) -> _Pin4W {
                _Pin4W { w: self }
            }
            # [ doc = "Bit 5 - Pin 5." ]
            # [ inline ( always ) ]
            pub fn pin5(&mut self) -> _Pin5W {
                _Pin5W { w: self }
            }
            # [ doc = "Bit 6 - Pin 6." ]
            # [ inline ( always ) ]
            pub fn pin6(&mut self) -> _Pin6W {
                _Pin6W { w: self }
            }
            # [ doc = "Bit 7 - Pin 7." ]
            # [ inline ( always ) ]
            pub fn pin7(&mut self) -> _Pin7W {
                _Pin7W { w: self }
            }
            # [ doc = "Bit 8 - Pin 8." ]
            # [ inline ( always ) ]
            pub fn pin8(&mut self) -> _Pin8W {
                _Pin8W { w: self }
            }
            # [ doc = "Bit 9 - Pin 9." ]
            # [ inline ( always ) ]
            pub fn pin9(&mut self) -> _Pin9W {
                _Pin9W { w: self }
            }
            # [ doc = "Bit 10 - Pin 10." ]
            # [ inline ( always ) ]
            pub fn pin10(&mut self) -> _Pin10W {
                _Pin10W { w: self }
            }
            # [ doc = "Bit 11 - Pin 11." ]
            # [ inline ( always ) ]
            pub fn pin11(&mut self) -> _Pin11W {
                _Pin11W { w: self }
            }
            # [ doc = "Bit 12 - Pin 12." ]
            # [ inline ( always ) ]
            pub fn pin12(&mut self) -> _Pin12W {
                _Pin12W { w: self }
            }
            # [ doc = "Bit 13 - Pin 13." ]
            # [ inline ( always ) ]
            pub fn pin13(&mut self) -> _Pin13W {
                _Pin13W { w: self }
            }
            # [ doc = "Bit 14 - Pin 14." ]
            # [ inline ( always ) ]
            pub fn pin14(&mut self) -> _Pin14W {
                _Pin14W { w: self }
            }
            # [ doc = "Bit 15 - Pin 15." ]
            # [ inline ( always ) ]
            pub fn pin15(&mut self) -> _Pin15W {
                _Pin15W { w: self }
            }
            # [ doc = "Bit 16 - Pin 16." ]
            # [ inline ( always ) ]
            pub fn pin16(&mut self) -> _Pin16W {
                _Pin16W { w: self }
            }
            # [ doc = "Bit 17 - Pin 17." ]
            # [ inline ( always ) ]
            pub fn pin17(&mut self) -> _Pin17W {
                _Pin17W { w: self }
            }
            # [ doc = "Bit 18 - Pin 18." ]
            # [ inline ( always ) ]
            pub fn pin18(&mut self) -> _Pin18W {
                _Pin18W { w: self }
            }
            # [ doc = "Bit 19 - Pin 19." ]
            # [ inline ( always ) ]
            pub fn pin19(&mut self) -> _Pin19W {
                _Pin19W { w: self }
            }
            # [ doc = "Bit 20 - Pin 20." ]
            # [ inline ( always ) ]
            pub fn pin20(&mut self) -> _Pin20W {
                _Pin20W { w: self }
            }
            # [ doc = "Bit 21 - Pin 21." ]
            # [ inline ( always ) ]
            pub fn pin21(&mut self) -> _Pin21W {
                _Pin21W { w: self }
            }
            # [ doc = "Bit 22 - Pin 22." ]
            # [ inline ( always ) ]
            pub fn pin22(&mut self) -> _Pin22W {
                _Pin22W { w: self }
            }
            # [ doc = "Bit 23 - Pin 23." ]
            # [ inline ( always ) ]
            pub fn pin23(&mut self) -> _Pin23W {
                _Pin23W { w: self }
            }
            # [ doc = "Bit 24 - Pin 24." ]
            # [ inline ( always ) ]
            pub fn pin24(&mut self) -> _Pin24W {
                _Pin24W { w: self }
            }
            # [ doc = "Bit 25 - Pin 25." ]
            # [ inline ( always ) ]
            pub fn pin25(&mut self) -> _Pin25W {
                _Pin25W { w: self }
            }
            # [ doc = "Bit 26 - Pin 26." ]
            # [ inline ( always ) ]
            pub fn pin26(&mut self) -> _Pin26W {
                _Pin26W { w: self }
            }
            # [ doc = "Bit 27 - Pin 27." ]
            # [ inline ( always ) ]
            pub fn pin27(&mut self) -> _Pin27W {
                _Pin27W { w: self }
            }
            # [ doc = "Bit 28 - Pin 28." ]
            # [ inline ( always ) ]
            pub fn pin28(&mut self) -> _Pin28W {
                _Pin28W { w: self }
            }
            # [ doc = "Bit 29 - Pin 29." ]
            # [ inline ( always ) ]
            pub fn pin29(&mut self) -> _Pin29W {
                _Pin29W { w: self }
            }
            # [ doc = "Bit 30 - Pin 30." ]
            # [ inline ( always ) ]
            pub fn pin30(&mut self) -> _Pin30W {
                _Pin30W { w: self }
            }
            # [ doc = "Bit 31 - Pin 31." ]
            # [ inline ( always ) ]
            pub fn pin31(&mut self) -> _Pin31W {
                _Pin31W { w: self }
            }
        }
    }
    # [ doc = "DIR set register." ]
    pub struct Dirset {
        register: VolatileCell<u32>,
    }
    # [ doc = "DIR set register." ]
    pub mod dirset {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dirset {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `PIN0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin0R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin0R::Input => 0,
                    Pin0R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin0R {
                match bits {
                    0 => Pin0R::Input,
                    1 => Pin0R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin0R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin0R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin1R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin1R::Input => 0,
                    Pin1R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin1R {
                match bits {
                    0 => Pin1R::Input,
                    1 => Pin1R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin1R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin1R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin2R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin2R::Input => 0,
                    Pin2R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin2R {
                match bits {
                    0 => Pin2R::Input,
                    1 => Pin2R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin2R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin2R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin3R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin3R::Input => 0,
                    Pin3R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin3R {
                match bits {
                    0 => Pin3R::Input,
                    1 => Pin3R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin3R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin3R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN4`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin4R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin4R::Input => 0,
                    Pin4R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin4R {
                match bits {
                    0 => Pin4R::Input,
                    1 => Pin4R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin4R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin4R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN5`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin5R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin5R::Input => 0,
                    Pin5R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin5R {
                match bits {
                    0 => Pin5R::Input,
                    1 => Pin5R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin5R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin5R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN6`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin6R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin6R::Input => 0,
                    Pin6R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin6R {
                match bits {
                    0 => Pin6R::Input,
                    1 => Pin6R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin6R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin6R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN7`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin7R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin7R::Input => 0,
                    Pin7R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin7R {
                match bits {
                    0 => Pin7R::Input,
                    1 => Pin7R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin7R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin7R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN8`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin8R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin8R::Input => 0,
                    Pin8R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin8R {
                match bits {
                    0 => Pin8R::Input,
                    1 => Pin8R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin8R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin8R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN9`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin9R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin9R::Input => 0,
                    Pin9R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin9R {
                match bits {
                    0 => Pin9R::Input,
                    1 => Pin9R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin9R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin9R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN10`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin10R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin10R::Input => 0,
                    Pin10R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin10R {
                match bits {
                    0 => Pin10R::Input,
                    1 => Pin10R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin10R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin10R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN11`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin11R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin11R::Input => 0,
                    Pin11R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin11R {
                match bits {
                    0 => Pin11R::Input,
                    1 => Pin11R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin11R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin11R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN12`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin12R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin12R::Input => 0,
                    Pin12R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin12R {
                match bits {
                    0 => Pin12R::Input,
                    1 => Pin12R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin12R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin12R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN13`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin13R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin13R::Input => 0,
                    Pin13R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin13R {
                match bits {
                    0 => Pin13R::Input,
                    1 => Pin13R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin13R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin13R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN14`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin14R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin14R::Input => 0,
                    Pin14R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin14R {
                match bits {
                    0 => Pin14R::Input,
                    1 => Pin14R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin14R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin14R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN15`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin15R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin15R::Input => 0,
                    Pin15R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin15R {
                match bits {
                    0 => Pin15R::Input,
                    1 => Pin15R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin15R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin15R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN16`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin16R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin16R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin16R::Input => 0,
                    Pin16R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin16R {
                match bits {
                    0 => Pin16R::Input,
                    1 => Pin16R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin16R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin16R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN17`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin17R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin17R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin17R::Input => 0,
                    Pin17R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin17R {
                match bits {
                    0 => Pin17R::Input,
                    1 => Pin17R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin17R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin17R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN18`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin18R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin18R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin18R::Input => 0,
                    Pin18R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin18R {
                match bits {
                    0 => Pin18R::Input,
                    1 => Pin18R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin18R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin18R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN19`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin19R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin19R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin19R::Input => 0,
                    Pin19R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin19R {
                match bits {
                    0 => Pin19R::Input,
                    1 => Pin19R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin19R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin19R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN20`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin20R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin20R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin20R::Input => 0,
                    Pin20R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin20R {
                match bits {
                    0 => Pin20R::Input,
                    1 => Pin20R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin20R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin20R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN21`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin21R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin21R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin21R::Input => 0,
                    Pin21R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin21R {
                match bits {
                    0 => Pin21R::Input,
                    1 => Pin21R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin21R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin21R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN22`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin22R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin22R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin22R::Input => 0,
                    Pin22R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin22R {
                match bits {
                    0 => Pin22R::Input,
                    1 => Pin22R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin22R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin22R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN23`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin23R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin23R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin23R::Input => 0,
                    Pin23R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin23R {
                match bits {
                    0 => Pin23R::Input,
                    1 => Pin23R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin23R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin23R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN24`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin24R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin24R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin24R::Input => 0,
                    Pin24R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin24R {
                match bits {
                    0 => Pin24R::Input,
                    1 => Pin24R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin24R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin24R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN25`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin25R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin25R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin25R::Input => 0,
                    Pin25R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin25R {
                match bits {
                    0 => Pin25R::Input,
                    1 => Pin25R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin25R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin25R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN26`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin26R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin26R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin26R::Input => 0,
                    Pin26R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin26R {
                match bits {
                    0 => Pin26R::Input,
                    1 => Pin26R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin26R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin26R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN27`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin27R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin27R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin27R::Input => 0,
                    Pin27R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin27R {
                match bits {
                    0 => Pin27R::Input,
                    1 => Pin27R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin27R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin27R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN28`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin28R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin28R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin28R::Input => 0,
                    Pin28R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin28R {
                match bits {
                    0 => Pin28R::Input,
                    1 => Pin28R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin28R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin28R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN29`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin29R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin29R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin29R::Input => 0,
                    Pin29R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin29R {
                match bits {
                    0 => Pin29R::Input,
                    1 => Pin29R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin29R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin29R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN30`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin30R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin30R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin30R::Input => 0,
                    Pin30R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin30R {
                match bits {
                    0 => Pin30R::Input,
                    1 => Pin30R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin30R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin30R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN31`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin31R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin31R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin31R::Input => 0,
                    Pin31R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin31R {
                match bits {
                    0 => Pin31R::Input,
                    1 => Pin31R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin31R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin31R::Output
            }
        }
        # [ doc = "Values that can be written to the field `PIN0`" ]
        pub enum Pin0W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin0W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN1`" ]
        pub enum Pin1W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin1W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin1W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN2`" ]
        pub enum Pin2W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin2W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin2W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN3`" ]
        pub enum Pin3W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin3W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin3W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN4`" ]
        pub enum Pin4W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin4W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin4W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin4W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin4W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN5`" ]
        pub enum Pin5W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin5W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin5W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin5W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin5W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN6`" ]
        pub enum Pin6W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin6W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin6W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin6W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin6W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN7`" ]
        pub enum Pin7W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin7W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin7W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin7W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin7W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN8`" ]
        pub enum Pin8W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin8W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin8W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin8W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin8W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN9`" ]
        pub enum Pin9W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin9W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin9W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin9W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin9W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN10`" ]
        pub enum Pin10W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin10W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin10W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin10W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin10W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN11`" ]
        pub enum Pin11W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin11W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin11W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin11W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin11W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN12`" ]
        pub enum Pin12W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin12W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin12W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin12W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin12W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN13`" ]
        pub enum Pin13W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin13W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin13W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin13W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin13W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN14`" ]
        pub enum Pin14W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin14W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin14W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin14W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin14W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN15`" ]
        pub enum Pin15W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin15W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin15W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin15W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin15W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN16`" ]
        pub enum Pin16W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin16W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin16W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin16W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin16W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin16W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN17`" ]
        pub enum Pin17W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin17W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin17W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin17W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin17W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin17W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN18`" ]
        pub enum Pin18W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin18W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin18W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin18W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin18W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin18W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN19`" ]
        pub enum Pin19W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin19W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin19W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin19W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin19W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin19W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN20`" ]
        pub enum Pin20W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin20W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin20W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin20W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin20W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin20W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN21`" ]
        pub enum Pin21W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin21W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin21W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin21W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin21W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin21W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN22`" ]
        pub enum Pin22W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin22W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin22W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin22W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin22W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin22W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN23`" ]
        pub enum Pin23W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin23W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin23W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin23W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin23W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin23W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN24`" ]
        pub enum Pin24W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin24W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin24W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin24W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin24W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin24W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN25`" ]
        pub enum Pin25W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin25W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin25W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin25W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin25W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin25W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN26`" ]
        pub enum Pin26W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin26W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin26W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin26W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin26W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin26W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN27`" ]
        pub enum Pin27W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin27W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin27W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin27W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin27W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin27W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN28`" ]
        pub enum Pin28W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin28W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin28W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin28W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin28W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin28W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN29`" ]
        pub enum Pin29W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin29W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin29W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin29W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin29W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin29W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN30`" ]
        pub enum Pin30W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin30W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin30W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin30W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin30W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin30W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN31`" ]
        pub enum Pin31W {
            # [ doc = "Set pin as output." ]
            Set,
        }
        impl Pin31W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin31W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin31W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin31W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as output." ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Pin31W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Set as output pin 0." ]
            # [ inline ( always ) ]
            pub fn pin0(&self) -> Pin0R {
                Pin0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Set as output pin 1." ]
            # [ inline ( always ) ]
            pub fn pin1(&self) -> Pin1R {
                Pin1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Set as output pin 2." ]
            # [ inline ( always ) ]
            pub fn pin2(&self) -> Pin2R {
                Pin2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Set as output pin 3." ]
            # [ inline ( always ) ]
            pub fn pin3(&self) -> Pin3R {
                Pin3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Set as output pin 4." ]
            # [ inline ( always ) ]
            pub fn pin4(&self) -> Pin4R {
                Pin4R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Set as output pin 5." ]
            # [ inline ( always ) ]
            pub fn pin5(&self) -> Pin5R {
                Pin5R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Set as output pin 6." ]
            # [ inline ( always ) ]
            pub fn pin6(&self) -> Pin6R {
                Pin6R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Set as output pin 7." ]
            # [ inline ( always ) ]
            pub fn pin7(&self) -> Pin7R {
                Pin7R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Set as output pin 8." ]
            # [ inline ( always ) ]
            pub fn pin8(&self) -> Pin8R {
                Pin8R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Set as output pin 9." ]
            # [ inline ( always ) ]
            pub fn pin9(&self) -> Pin9R {
                Pin9R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Set as output pin 10." ]
            # [ inline ( always ) ]
            pub fn pin10(&self) -> Pin10R {
                Pin10R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 11 - Set as output pin 11." ]
            # [ inline ( always ) ]
            pub fn pin11(&self) -> Pin11R {
                Pin11R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 12 - Set as output pin 12." ]
            # [ inline ( always ) ]
            pub fn pin12(&self) -> Pin12R {
                Pin12R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 13 - Set as output pin 13." ]
            # [ inline ( always ) ]
            pub fn pin13(&self) -> Pin13R {
                Pin13R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 13;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 14 - Set as output pin 14." ]
            # [ inline ( always ) ]
            pub fn pin14(&self) -> Pin14R {
                Pin14R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 15 - Set as output pin 15." ]
            # [ inline ( always ) ]
            pub fn pin15(&self) -> Pin15R {
                Pin15R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 15;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - Set as output pin 16." ]
            # [ inline ( always ) ]
            pub fn pin16(&self) -> Pin16R {
                Pin16R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Set as output pin 17." ]
            # [ inline ( always ) ]
            pub fn pin17(&self) -> Pin17R {
                Pin17R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Set as output pin 18." ]
            # [ inline ( always ) ]
            pub fn pin18(&self) -> Pin18R {
                Pin18R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Set as output pin 19." ]
            # [ inline ( always ) ]
            pub fn pin19(&self) -> Pin19R {
                Pin19R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 20 - Set as output pin 20." ]
            # [ inline ( always ) ]
            pub fn pin20(&self) -> Pin20R {
                Pin20R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 20;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 21 - Set as output pin 21." ]
            # [ inline ( always ) ]
            pub fn pin21(&self) -> Pin21R {
                Pin21R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 21;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 22 - Set as output pin 22." ]
            # [ inline ( always ) ]
            pub fn pin22(&self) -> Pin22R {
                Pin22R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 22;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 23 - Set as output pin 23." ]
            # [ inline ( always ) ]
            pub fn pin23(&self) -> Pin23R {
                Pin23R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 23;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 24 - Set as output pin 24." ]
            # [ inline ( always ) ]
            pub fn pin24(&self) -> Pin24R {
                Pin24R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 24;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 25 - Set as output pin 25." ]
            # [ inline ( always ) ]
            pub fn pin25(&self) -> Pin25R {
                Pin25R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 25;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 26 - Set as output pin 26." ]
            # [ inline ( always ) ]
            pub fn pin26(&self) -> Pin26R {
                Pin26R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 26;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 27 - Set as output pin 27." ]
            # [ inline ( always ) ]
            pub fn pin27(&self) -> Pin27R {
                Pin27R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 27;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 28 - Set as output pin 28." ]
            # [ inline ( always ) ]
            pub fn pin28(&self) -> Pin28R {
                Pin28R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 28;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 29 - Set as output pin 29." ]
            # [ inline ( always ) ]
            pub fn pin29(&self) -> Pin29R {
                Pin29R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 29;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 30 - Set as output pin 30." ]
            # [ inline ( always ) ]
            pub fn pin30(&self) -> Pin30R {
                Pin30R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 30;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 31 - Set as output pin 31." ]
            # [ inline ( always ) ]
            pub fn pin31(&self) -> Pin31R {
                Pin31R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Set as output pin 0." ]
            # [ inline ( always ) ]
            pub fn pin0(&mut self) -> _Pin0W {
                _Pin0W { w: self }
            }
            # [ doc = "Bit 1 - Set as output pin 1." ]
            # [ inline ( always ) ]
            pub fn pin1(&mut self) -> _Pin1W {
                _Pin1W { w: self }
            }
            # [ doc = "Bit 2 - Set as output pin 2." ]
            # [ inline ( always ) ]
            pub fn pin2(&mut self) -> _Pin2W {
                _Pin2W { w: self }
            }
            # [ doc = "Bit 3 - Set as output pin 3." ]
            # [ inline ( always ) ]
            pub fn pin3(&mut self) -> _Pin3W {
                _Pin3W { w: self }
            }
            # [ doc = "Bit 4 - Set as output pin 4." ]
            # [ inline ( always ) ]
            pub fn pin4(&mut self) -> _Pin4W {
                _Pin4W { w: self }
            }
            # [ doc = "Bit 5 - Set as output pin 5." ]
            # [ inline ( always ) ]
            pub fn pin5(&mut self) -> _Pin5W {
                _Pin5W { w: self }
            }
            # [ doc = "Bit 6 - Set as output pin 6." ]
            # [ inline ( always ) ]
            pub fn pin6(&mut self) -> _Pin6W {
                _Pin6W { w: self }
            }
            # [ doc = "Bit 7 - Set as output pin 7." ]
            # [ inline ( always ) ]
            pub fn pin7(&mut self) -> _Pin7W {
                _Pin7W { w: self }
            }
            # [ doc = "Bit 8 - Set as output pin 8." ]
            # [ inline ( always ) ]
            pub fn pin8(&mut self) -> _Pin8W {
                _Pin8W { w: self }
            }
            # [ doc = "Bit 9 - Set as output pin 9." ]
            # [ inline ( always ) ]
            pub fn pin9(&mut self) -> _Pin9W {
                _Pin9W { w: self }
            }
            # [ doc = "Bit 10 - Set as output pin 10." ]
            # [ inline ( always ) ]
            pub fn pin10(&mut self) -> _Pin10W {
                _Pin10W { w: self }
            }
            # [ doc = "Bit 11 - Set as output pin 11." ]
            # [ inline ( always ) ]
            pub fn pin11(&mut self) -> _Pin11W {
                _Pin11W { w: self }
            }
            # [ doc = "Bit 12 - Set as output pin 12." ]
            # [ inline ( always ) ]
            pub fn pin12(&mut self) -> _Pin12W {
                _Pin12W { w: self }
            }
            # [ doc = "Bit 13 - Set as output pin 13." ]
            # [ inline ( always ) ]
            pub fn pin13(&mut self) -> _Pin13W {
                _Pin13W { w: self }
            }
            # [ doc = "Bit 14 - Set as output pin 14." ]
            # [ inline ( always ) ]
            pub fn pin14(&mut self) -> _Pin14W {
                _Pin14W { w: self }
            }
            # [ doc = "Bit 15 - Set as output pin 15." ]
            # [ inline ( always ) ]
            pub fn pin15(&mut self) -> _Pin15W {
                _Pin15W { w: self }
            }
            # [ doc = "Bit 16 - Set as output pin 16." ]
            # [ inline ( always ) ]
            pub fn pin16(&mut self) -> _Pin16W {
                _Pin16W { w: self }
            }
            # [ doc = "Bit 17 - Set as output pin 17." ]
            # [ inline ( always ) ]
            pub fn pin17(&mut self) -> _Pin17W {
                _Pin17W { w: self }
            }
            # [ doc = "Bit 18 - Set as output pin 18." ]
            # [ inline ( always ) ]
            pub fn pin18(&mut self) -> _Pin18W {
                _Pin18W { w: self }
            }
            # [ doc = "Bit 19 - Set as output pin 19." ]
            # [ inline ( always ) ]
            pub fn pin19(&mut self) -> _Pin19W {
                _Pin19W { w: self }
            }
            # [ doc = "Bit 20 - Set as output pin 20." ]
            # [ inline ( always ) ]
            pub fn pin20(&mut self) -> _Pin20W {
                _Pin20W { w: self }
            }
            # [ doc = "Bit 21 - Set as output pin 21." ]
            # [ inline ( always ) ]
            pub fn pin21(&mut self) -> _Pin21W {
                _Pin21W { w: self }
            }
            # [ doc = "Bit 22 - Set as output pin 22." ]
            # [ inline ( always ) ]
            pub fn pin22(&mut self) -> _Pin22W {
                _Pin22W { w: self }
            }
            # [ doc = "Bit 23 - Set as output pin 23." ]
            # [ inline ( always ) ]
            pub fn pin23(&mut self) -> _Pin23W {
                _Pin23W { w: self }
            }
            # [ doc = "Bit 24 - Set as output pin 24." ]
            # [ inline ( always ) ]
            pub fn pin24(&mut self) -> _Pin24W {
                _Pin24W { w: self }
            }
            # [ doc = "Bit 25 - Set as output pin 25." ]
            # [ inline ( always ) ]
            pub fn pin25(&mut self) -> _Pin25W {
                _Pin25W { w: self }
            }
            # [ doc = "Bit 26 - Set as output pin 26." ]
            # [ inline ( always ) ]
            pub fn pin26(&mut self) -> _Pin26W {
                _Pin26W { w: self }
            }
            # [ doc = "Bit 27 - Set as output pin 27." ]
            # [ inline ( always ) ]
            pub fn pin27(&mut self) -> _Pin27W {
                _Pin27W { w: self }
            }
            # [ doc = "Bit 28 - Set as output pin 28." ]
            # [ inline ( always ) ]
            pub fn pin28(&mut self) -> _Pin28W {
                _Pin28W { w: self }
            }
            # [ doc = "Bit 29 - Set as output pin 29." ]
            # [ inline ( always ) ]
            pub fn pin29(&mut self) -> _Pin29W {
                _Pin29W { w: self }
            }
            # [ doc = "Bit 30 - Set as output pin 30." ]
            # [ inline ( always ) ]
            pub fn pin30(&mut self) -> _Pin30W {
                _Pin30W { w: self }
            }
            # [ doc = "Bit 31 - Set as output pin 31." ]
            # [ inline ( always ) ]
            pub fn pin31(&mut self) -> _Pin31W {
                _Pin31W { w: self }
            }
        }
    }
    # [ doc = "DIR clear register." ]
    pub struct Dirclr {
        register: VolatileCell<u32>,
    }
    # [ doc = "DIR clear register." ]
    pub mod dirclr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dirclr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `PIN0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin0R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin0R::Input => 0,
                    Pin0R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin0R {
                match bits {
                    0 => Pin0R::Input,
                    1 => Pin0R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin0R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin0R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin1R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin1R::Input => 0,
                    Pin1R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin1R {
                match bits {
                    0 => Pin1R::Input,
                    1 => Pin1R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin1R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin1R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN2`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin2R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin2R::Input => 0,
                    Pin2R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin2R {
                match bits {
                    0 => Pin2R::Input,
                    1 => Pin2R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin2R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin2R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN3`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin3R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin3R::Input => 0,
                    Pin3R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin3R {
                match bits {
                    0 => Pin3R::Input,
                    1 => Pin3R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin3R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin3R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN4`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin4R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin4R::Input => 0,
                    Pin4R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin4R {
                match bits {
                    0 => Pin4R::Input,
                    1 => Pin4R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin4R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin4R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN5`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin5R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin5R::Input => 0,
                    Pin5R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin5R {
                match bits {
                    0 => Pin5R::Input,
                    1 => Pin5R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin5R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin5R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN6`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin6R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin6R::Input => 0,
                    Pin6R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin6R {
                match bits {
                    0 => Pin6R::Input,
                    1 => Pin6R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin6R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin6R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN7`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin7R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin7R::Input => 0,
                    Pin7R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin7R {
                match bits {
                    0 => Pin7R::Input,
                    1 => Pin7R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin7R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin7R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN8`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin8R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin8R::Input => 0,
                    Pin8R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin8R {
                match bits {
                    0 => Pin8R::Input,
                    1 => Pin8R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin8R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin8R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN9`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin9R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin9R::Input => 0,
                    Pin9R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin9R {
                match bits {
                    0 => Pin9R::Input,
                    1 => Pin9R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin9R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin9R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN10`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin10R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin10R::Input => 0,
                    Pin10R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin10R {
                match bits {
                    0 => Pin10R::Input,
                    1 => Pin10R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin10R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin10R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN11`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin11R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin11R::Input => 0,
                    Pin11R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin11R {
                match bits {
                    0 => Pin11R::Input,
                    1 => Pin11R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin11R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin11R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN12`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin12R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin12R::Input => 0,
                    Pin12R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin12R {
                match bits {
                    0 => Pin12R::Input,
                    1 => Pin12R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin12R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin12R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN13`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin13R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin13R::Input => 0,
                    Pin13R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin13R {
                match bits {
                    0 => Pin13R::Input,
                    1 => Pin13R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin13R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin13R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN14`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin14R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin14R::Input => 0,
                    Pin14R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin14R {
                match bits {
                    0 => Pin14R::Input,
                    1 => Pin14R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin14R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin14R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN15`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin15R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin15R::Input => 0,
                    Pin15R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin15R {
                match bits {
                    0 => Pin15R::Input,
                    1 => Pin15R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin15R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin15R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN16`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin16R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin16R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin16R::Input => 0,
                    Pin16R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin16R {
                match bits {
                    0 => Pin16R::Input,
                    1 => Pin16R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin16R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin16R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN17`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin17R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin17R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin17R::Input => 0,
                    Pin17R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin17R {
                match bits {
                    0 => Pin17R::Input,
                    1 => Pin17R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin17R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin17R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN18`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin18R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin18R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin18R::Input => 0,
                    Pin18R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin18R {
                match bits {
                    0 => Pin18R::Input,
                    1 => Pin18R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin18R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin18R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN19`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin19R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin19R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin19R::Input => 0,
                    Pin19R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin19R {
                match bits {
                    0 => Pin19R::Input,
                    1 => Pin19R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin19R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin19R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN20`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin20R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin20R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin20R::Input => 0,
                    Pin20R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin20R {
                match bits {
                    0 => Pin20R::Input,
                    1 => Pin20R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin20R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin20R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN21`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin21R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin21R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin21R::Input => 0,
                    Pin21R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin21R {
                match bits {
                    0 => Pin21R::Input,
                    1 => Pin21R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin21R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin21R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN22`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin22R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin22R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin22R::Input => 0,
                    Pin22R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin22R {
                match bits {
                    0 => Pin22R::Input,
                    1 => Pin22R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin22R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin22R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN23`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin23R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin23R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin23R::Input => 0,
                    Pin23R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin23R {
                match bits {
                    0 => Pin23R::Input,
                    1 => Pin23R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin23R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin23R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN24`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin24R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin24R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin24R::Input => 0,
                    Pin24R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin24R {
                match bits {
                    0 => Pin24R::Input,
                    1 => Pin24R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin24R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin24R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN25`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin25R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin25R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin25R::Input => 0,
                    Pin25R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin25R {
                match bits {
                    0 => Pin25R::Input,
                    1 => Pin25R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin25R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin25R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN26`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin26R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin26R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin26R::Input => 0,
                    Pin26R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin26R {
                match bits {
                    0 => Pin26R::Input,
                    1 => Pin26R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin26R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin26R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN27`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin27R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin27R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin27R::Input => 0,
                    Pin27R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin27R {
                match bits {
                    0 => Pin27R::Input,
                    1 => Pin27R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin27R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin27R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN28`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin28R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin28R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin28R::Input => 0,
                    Pin28R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin28R {
                match bits {
                    0 => Pin28R::Input,
                    1 => Pin28R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin28R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin28R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN29`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin29R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin29R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin29R::Input => 0,
                    Pin29R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin29R {
                match bits {
                    0 => Pin29R::Input,
                    1 => Pin29R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin29R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin29R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN30`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin30R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin30R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin30R::Input => 0,
                    Pin30R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin30R {
                match bits {
                    0 => Pin30R::Input,
                    1 => Pin30R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin30R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin30R::Output
            }
        }
        # [ doc = "Possible values of the field `PIN31`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Pin31R {
            # [ doc = "Pin set as input." ]
            Input,
            # [ doc = "Pin set as output." ]
            Output,
        }
        impl Pin31R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pin31R::Input => 0,
                    Pin31R::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Pin31R {
                match bits {
                    0 => Pin31R::Input,
                    1 => Pin31R::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Pin31R::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == Pin31R::Output
            }
        }
        # [ doc = "Values that can be written to the field `PIN0`" ]
        pub enum Pin0W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin0W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin0W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN1`" ]
        pub enum Pin1W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin1W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin1W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN2`" ]
        pub enum Pin2W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin2W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin2W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin2W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN3`" ]
        pub enum Pin3W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin3W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin3W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin3W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN4`" ]
        pub enum Pin4W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin4W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin4W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin4W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin4W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN5`" ]
        pub enum Pin5W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin5W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin5W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin5W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin5W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN6`" ]
        pub enum Pin6W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin6W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin6W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin6W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin6W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN7`" ]
        pub enum Pin7W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin7W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin7W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin7W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin7W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN8`" ]
        pub enum Pin8W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin8W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin8W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin8W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin8W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN9`" ]
        pub enum Pin9W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin9W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin9W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin9W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin9W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN10`" ]
        pub enum Pin10W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin10W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin10W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin10W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin10W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN11`" ]
        pub enum Pin11W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin11W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin11W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin11W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin11W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN12`" ]
        pub enum Pin12W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin12W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin12W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin12W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin12W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN13`" ]
        pub enum Pin13W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin13W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin13W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin13W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin13W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN14`" ]
        pub enum Pin14W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin14W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin14W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin14W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin14W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN15`" ]
        pub enum Pin15W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin15W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin15W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin15W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin15W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN16`" ]
        pub enum Pin16W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin16W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin16W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin16W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin16W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin16W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN17`" ]
        pub enum Pin17W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin17W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin17W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin17W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin17W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin17W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN18`" ]
        pub enum Pin18W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin18W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin18W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin18W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin18W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin18W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN19`" ]
        pub enum Pin19W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin19W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin19W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin19W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin19W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin19W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN20`" ]
        pub enum Pin20W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin20W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin20W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin20W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin20W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin20W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN21`" ]
        pub enum Pin21W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin21W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin21W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin21W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin21W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin21W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN22`" ]
        pub enum Pin22W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin22W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin22W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin22W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin22W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin22W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN23`" ]
        pub enum Pin23W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin23W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin23W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin23W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin23W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin23W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN24`" ]
        pub enum Pin24W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin24W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin24W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin24W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin24W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin24W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN25`" ]
        pub enum Pin25W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin25W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin25W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin25W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin25W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin25W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN26`" ]
        pub enum Pin26W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin26W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin26W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin26W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin26W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin26W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN27`" ]
        pub enum Pin27W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin27W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin27W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin27W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin27W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin27W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN28`" ]
        pub enum Pin28W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin28W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin28W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin28W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin28W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin28W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN29`" ]
        pub enum Pin29W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin29W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin29W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin29W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin29W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin29W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN30`" ]
        pub enum Pin30W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin30W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin30W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin30W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin30W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin30W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PIN31`" ]
        pub enum Pin31W {
            # [ doc = "Set pin as input." ]
            Clear,
        }
        impl Pin31W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pin31W::Clear => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pin31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pin31W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Pin31W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Set pin as input." ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(Pin31W::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Set as input pin 0." ]
            # [ inline ( always ) ]
            pub fn pin0(&self) -> Pin0R {
                Pin0R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Set as input pin 1." ]
            # [ inline ( always ) ]
            pub fn pin1(&self) -> Pin1R {
                Pin1R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 2 - Set as input pin 2." ]
            # [ inline ( always ) ]
            pub fn pin2(&self) -> Pin2R {
                Pin2R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 3 - Set as input pin 3." ]
            # [ inline ( always ) ]
            pub fn pin3(&self) -> Pin3R {
                Pin3R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 4 - Set as input pin 4." ]
            # [ inline ( always ) ]
            pub fn pin4(&self) -> Pin4R {
                Pin4R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 5 - Set as input pin 5." ]
            # [ inline ( always ) ]
            pub fn pin5(&self) -> Pin5R {
                Pin5R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 6 - Set as input pin 6." ]
            # [ inline ( always ) ]
            pub fn pin6(&self) -> Pin6R {
                Pin6R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 7 - Set as input pin 7." ]
            # [ inline ( always ) ]
            pub fn pin7(&self) -> Pin7R {
                Pin7R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 8 - Set as input pin 8." ]
            # [ inline ( always ) ]
            pub fn pin8(&self) -> Pin8R {
                Pin8R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 9 - Set as input pin 9." ]
            # [ inline ( always ) ]
            pub fn pin9(&self) -> Pin9R {
                Pin9R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 10 - Set as input pin 10." ]
            # [ inline ( always ) ]
            pub fn pin10(&self) -> Pin10R {
                Pin10R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 11 - Set as input pin 11." ]
            # [ inline ( always ) ]
            pub fn pin11(&self) -> Pin11R {
                Pin11R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 12 - Set as input pin 12." ]
            # [ inline ( always ) ]
            pub fn pin12(&self) -> Pin12R {
                Pin12R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 13 - Set as input pin 13." ]
            # [ inline ( always ) ]
            pub fn pin13(&self) -> Pin13R {
                Pin13R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 13;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 14 - Set as input pin 14." ]
            # [ inline ( always ) ]
            pub fn pin14(&self) -> Pin14R {
                Pin14R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 15 - Set as input pin 15." ]
            # [ inline ( always ) ]
            pub fn pin15(&self) -> Pin15R {
                Pin15R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 15;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 16 - Set as input pin 16." ]
            # [ inline ( always ) ]
            pub fn pin16(&self) -> Pin16R {
                Pin16R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 17 - Set as input pin 17." ]
            # [ inline ( always ) ]
            pub fn pin17(&self) -> Pin17R {
                Pin17R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 17;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 18 - Set as input pin 18." ]
            # [ inline ( always ) ]
            pub fn pin18(&self) -> Pin18R {
                Pin18R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 19 - Set as input pin 19." ]
            # [ inline ( always ) ]
            pub fn pin19(&self) -> Pin19R {
                Pin19R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 19;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 20 - Set as input pin 20." ]
            # [ inline ( always ) ]
            pub fn pin20(&self) -> Pin20R {
                Pin20R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 20;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 21 - Set as input pin 21." ]
            # [ inline ( always ) ]
            pub fn pin21(&self) -> Pin21R {
                Pin21R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 21;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 22 - Set as input pin 22." ]
            # [ inline ( always ) ]
            pub fn pin22(&self) -> Pin22R {
                Pin22R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 22;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 23 - Set as input pin 23." ]
            # [ inline ( always ) ]
            pub fn pin23(&self) -> Pin23R {
                Pin23R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 23;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 24 - Set as input pin 24." ]
            # [ inline ( always ) ]
            pub fn pin24(&self) -> Pin24R {
                Pin24R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 24;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 25 - Set as input pin 25." ]
            # [ inline ( always ) ]
            pub fn pin25(&self) -> Pin25R {
                Pin25R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 25;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 26 - Set as input pin 26." ]
            # [ inline ( always ) ]
            pub fn pin26(&self) -> Pin26R {
                Pin26R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 26;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 27 - Set as input pin 27." ]
            # [ inline ( always ) ]
            pub fn pin27(&self) -> Pin27R {
                Pin27R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 27;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 28 - Set as input pin 28." ]
            # [ inline ( always ) ]
            pub fn pin28(&self) -> Pin28R {
                Pin28R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 28;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 29 - Set as input pin 29." ]
            # [ inline ( always ) ]
            pub fn pin29(&self) -> Pin29R {
                Pin29R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 29;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 30 - Set as input pin 30." ]
            # [ inline ( always ) ]
            pub fn pin30(&self) -> Pin30R {
                Pin30R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 30;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 31 - Set as input pin 31." ]
            # [ inline ( always ) ]
            pub fn pin31(&self) -> Pin31R {
                Pin31R::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 31;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Set as input pin 0." ]
            # [ inline ( always ) ]
            pub fn pin0(&mut self) -> _Pin0W {
                _Pin0W { w: self }
            }
            # [ doc = "Bit 1 - Set as input pin 1." ]
            # [ inline ( always ) ]
            pub fn pin1(&mut self) -> _Pin1W {
                _Pin1W { w: self }
            }
            # [ doc = "Bit 2 - Set as input pin 2." ]
            # [ inline ( always ) ]
            pub fn pin2(&mut self) -> _Pin2W {
                _Pin2W { w: self }
            }
            # [ doc = "Bit 3 - Set as input pin 3." ]
            # [ inline ( always ) ]
            pub fn pin3(&mut self) -> _Pin3W {
                _Pin3W { w: self }
            }
            # [ doc = "Bit 4 - Set as input pin 4." ]
            # [ inline ( always ) ]
            pub fn pin4(&mut self) -> _Pin4W {
                _Pin4W { w: self }
            }
            # [ doc = "Bit 5 - Set as input pin 5." ]
            # [ inline ( always ) ]
            pub fn pin5(&mut self) -> _Pin5W {
                _Pin5W { w: self }
            }
            # [ doc = "Bit 6 - Set as input pin 6." ]
            # [ inline ( always ) ]
            pub fn pin6(&mut self) -> _Pin6W {
                _Pin6W { w: self }
            }
            # [ doc = "Bit 7 - Set as input pin 7." ]
            # [ inline ( always ) ]
            pub fn pin7(&mut self) -> _Pin7W {
                _Pin7W { w: self }
            }
            # [ doc = "Bit 8 - Set as input pin 8." ]
            # [ inline ( always ) ]
            pub fn pin8(&mut self) -> _Pin8W {
                _Pin8W { w: self }
            }
            # [ doc = "Bit 9 - Set as input pin 9." ]
            # [ inline ( always ) ]
            pub fn pin9(&mut self) -> _Pin9W {
                _Pin9W { w: self }
            }
            # [ doc = "Bit 10 - Set as input pin 10." ]
            # [ inline ( always ) ]
            pub fn pin10(&mut self) -> _Pin10W {
                _Pin10W { w: self }
            }
            # [ doc = "Bit 11 - Set as input pin 11." ]
            # [ inline ( always ) ]
            pub fn pin11(&mut self) -> _Pin11W {
                _Pin11W { w: self }
            }
            # [ doc = "Bit 12 - Set as input pin 12." ]
            # [ inline ( always ) ]
            pub fn pin12(&mut self) -> _Pin12W {
                _Pin12W { w: self }
            }
            # [ doc = "Bit 13 - Set as input pin 13." ]
            # [ inline ( always ) ]
            pub fn pin13(&mut self) -> _Pin13W {
                _Pin13W { w: self }
            }
            # [ doc = "Bit 14 - Set as input pin 14." ]
            # [ inline ( always ) ]
            pub fn pin14(&mut self) -> _Pin14W {
                _Pin14W { w: self }
            }
            # [ doc = "Bit 15 - Set as input pin 15." ]
            # [ inline ( always ) ]
            pub fn pin15(&mut self) -> _Pin15W {
                _Pin15W { w: self }
            }
            # [ doc = "Bit 16 - Set as input pin 16." ]
            # [ inline ( always ) ]
            pub fn pin16(&mut self) -> _Pin16W {
                _Pin16W { w: self }
            }
            # [ doc = "Bit 17 - Set as input pin 17." ]
            # [ inline ( always ) ]
            pub fn pin17(&mut self) -> _Pin17W {
                _Pin17W { w: self }
            }
            # [ doc = "Bit 18 - Set as input pin 18." ]
            # [ inline ( always ) ]
            pub fn pin18(&mut self) -> _Pin18W {
                _Pin18W { w: self }
            }
            # [ doc = "Bit 19 - Set as input pin 19." ]
            # [ inline ( always ) ]
            pub fn pin19(&mut self) -> _Pin19W {
                _Pin19W { w: self }
            }
            # [ doc = "Bit 20 - Set as input pin 20." ]
            # [ inline ( always ) ]
            pub fn pin20(&mut self) -> _Pin20W {
                _Pin20W { w: self }
            }
            # [ doc = "Bit 21 - Set as input pin 21." ]
            # [ inline ( always ) ]
            pub fn pin21(&mut self) -> _Pin21W {
                _Pin21W { w: self }
            }
            # [ doc = "Bit 22 - Set as input pin 22." ]
            # [ inline ( always ) ]
            pub fn pin22(&mut self) -> _Pin22W {
                _Pin22W { w: self }
            }
            # [ doc = "Bit 23 - Set as input pin 23." ]
            # [ inline ( always ) ]
            pub fn pin23(&mut self) -> _Pin23W {
                _Pin23W { w: self }
            }
            # [ doc = "Bit 24 - Set as input pin 24." ]
            # [ inline ( always ) ]
            pub fn pin24(&mut self) -> _Pin24W {
                _Pin24W { w: self }
            }
            # [ doc = "Bit 25 - Set as input pin 25." ]
            # [ inline ( always ) ]
            pub fn pin25(&mut self) -> _Pin25W {
                _Pin25W { w: self }
            }
            # [ doc = "Bit 26 - Set as input pin 26." ]
            # [ inline ( always ) ]
            pub fn pin26(&mut self) -> _Pin26W {
                _Pin26W { w: self }
            }
            # [ doc = "Bit 27 - Set as input pin 27." ]
            # [ inline ( always ) ]
            pub fn pin27(&mut self) -> _Pin27W {
                _Pin27W { w: self }
            }
            # [ doc = "Bit 28 - Set as input pin 28." ]
            # [ inline ( always ) ]
            pub fn pin28(&mut self) -> _Pin28W {
                _Pin28W { w: self }
            }
            # [ doc = "Bit 29 - Set as input pin 29." ]
            # [ inline ( always ) ]
            pub fn pin29(&mut self) -> _Pin29W {
                _Pin29W { w: self }
            }
            # [ doc = "Bit 30 - Set as input pin 30." ]
            # [ inline ( always ) ]
            pub fn pin30(&mut self) -> _Pin30W {
                _Pin30W { w: self }
            }
            # [ doc = "Bit 31 - Set as input pin 31." ]
            # [ inline ( always ) ]
            pub fn pin31(&mut self) -> _Pin31W {
                _Pin31W { w: self }
            }
        }
    }
    # [ doc = "Configuration of GPIO pins." ]
    pub struct PinCnf {
        register: VolatileCell<u32>,
    }
    # [ doc = "Configuration of GPIO pins." ]
    pub mod pin_cnf {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::PinCnf {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `DIR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DirR {
            # [ doc = "Configure pin as an input pin." ]
            Input,
            # [ doc = "Configure pin as an output pin." ]
            Output,
        }
        impl DirR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DirR::Input => 0,
                    DirR::Output => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DirR {
                match bits {
                    0 => DirR::Input,
                    1 => DirR::Output,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == DirR::Input
            }
            # [ doc = "Checks if the value of the field is `Output`" ]
            # [ inline ( always ) ]
            pub fn is_output(&self) -> bool {
                *self == DirR::Output
            }
        }
        # [ doc = "Possible values of the field `INPUT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum InputR {
            # [ doc = "Connect input pin." ]
            Connect,
            # [ doc = "Disconnect input pin." ]
            Disconnect,
        }
        impl InputR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    InputR::Connect => 0,
                    InputR::Disconnect => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> InputR {
                match bits {
                    0 => InputR::Connect,
                    1 => InputR::Disconnect,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Connect`" ]
            # [ inline ( always ) ]
            pub fn is_connect(&self) -> bool {
                *self == InputR::Connect
            }
            # [ doc = "Checks if the value of the field is `Disconnect`" ]
            # [ inline ( always ) ]
            pub fn is_disconnect(&self) -> bool {
                *self == InputR::Disconnect
            }
        }
        # [ doc = "Possible values of the field `PULL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PullR {
            # [ doc = "No pull." ]
            Disabled,
            # [ doc = "Pulldown on pin." ]
            Pulldown,
            # [ doc = "Pullup on pin." ]
            Pullup,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl PullR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PullR::Disabled => 0,
                    PullR::Pulldown => 1,
                    PullR::Pullup => 3,
                    PullR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PullR {
                match bits {
                    0 => PullR::Disabled,
                    1 => PullR::Pulldown,
                    3 => PullR::Pullup,
                    i => PullR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == PullR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Pulldown`" ]
            # [ inline ( always ) ]
            pub fn is_pulldown(&self) -> bool {
                *self == PullR::Pulldown
            }
            # [ doc = "Checks if the value of the field is `Pullup`" ]
            # [ inline ( always ) ]
            pub fn is_pullup(&self) -> bool {
                *self == PullR::Pullup
            }
        }
        # [ doc = "Possible values of the field `DRIVE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DriveR {
            # [ doc = "Standard '0', Standard '1'." ]
            S0s1,
            # [ doc = "High '0', Standard '1'." ]
            H0s1,
            # [ doc = "Standard '0', High '1'." ]
            S0h1,
            # [ doc = "High '0', High '1'." ]
            H0h1,
            # [ doc = "Disconnected '0', Standard '1'." ]
            D0s1,
            # [ doc = "Disconnected '0', High '1'." ]
            D0h1,
            # [ doc = "Standard '0', Disconnected '1'." ]
            S0d1,
            # [ doc = "High '0', Disconnected '1'." ]
            H0d1,
        }
        impl DriveR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DriveR::S0s1 => 0,
                    DriveR::H0s1 => 1,
                    DriveR::S0h1 => 2,
                    DriveR::H0h1 => 3,
                    DriveR::D0s1 => 4,
                    DriveR::D0h1 => 5,
                    DriveR::S0d1 => 6,
                    DriveR::H0d1 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DriveR {
                match bits {
                    0 => DriveR::S0s1,
                    1 => DriveR::H0s1,
                    2 => DriveR::S0h1,
                    3 => DriveR::H0h1,
                    4 => DriveR::D0s1,
                    5 => DriveR::D0h1,
                    6 => DriveR::S0d1,
                    7 => DriveR::H0d1,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `S0s1`" ]
            # [ inline ( always ) ]
            pub fn is_s0s1(&self) -> bool {
                *self == DriveR::S0s1
            }
            # [ doc = "Checks if the value of the field is `H0s1`" ]
            # [ inline ( always ) ]
            pub fn is_h0s1(&self) -> bool {
                *self == DriveR::H0s1
            }
            # [ doc = "Checks if the value of the field is `S0h1`" ]
            # [ inline ( always ) ]
            pub fn is_s0h1(&self) -> bool {
                *self == DriveR::S0h1
            }
            # [ doc = "Checks if the value of the field is `H0h1`" ]
            # [ inline ( always ) ]
            pub fn is_h0h1(&self) -> bool {
                *self == DriveR::H0h1
            }
            # [ doc = "Checks if the value of the field is `D0s1`" ]
            # [ inline ( always ) ]
            pub fn is_d0s1(&self) -> bool {
                *self == DriveR::D0s1
            }
            # [ doc = "Checks if the value of the field is `D0h1`" ]
            # [ inline ( always ) ]
            pub fn is_d0h1(&self) -> bool {
                *self == DriveR::D0h1
            }
            # [ doc = "Checks if the value of the field is `S0d1`" ]
            # [ inline ( always ) ]
            pub fn is_s0d1(&self) -> bool {
                *self == DriveR::S0d1
            }
            # [ doc = "Checks if the value of the field is `H0d1`" ]
            # [ inline ( always ) ]
            pub fn is_h0d1(&self) -> bool {
                *self == DriveR::H0d1
            }
        }
        # [ doc = "Possible values of the field `SENSE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SenseR {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Wakeup on high level." ]
            High,
            # [ doc = "Wakeup on low level." ]
            Low,
            # [ doc = r" Reserved" ]
            _Reserved(u8),
        }
        impl SenseR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SenseR::Disabled => 0,
                    SenseR::High => 2,
                    SenseR::Low => 3,
                    SenseR::_Reserved(bits) => bits,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SenseR {
                match bits {
                    0 => SenseR::Disabled,
                    2 => SenseR::High,
                    3 => SenseR::Low,
                    i => SenseR::_Reserved(i),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == SenseR::Disabled
            }
            # [ doc = "Checks if the value of the field is `High`" ]
            # [ inline ( always ) ]
            pub fn is_high(&self) -> bool {
                *self == SenseR::High
            }
            # [ doc = "Checks if the value of the field is `Low`" ]
            # [ inline ( always ) ]
            pub fn is_low(&self) -> bool {
                *self == SenseR::Low
            }
        }
        # [ doc = "Values that can be written to the field `DIR`" ]
        pub enum DirW {
            # [ doc = "Configure pin as an input pin." ]
            Input,
            # [ doc = "Configure pin as an output pin." ]
            Output,
        }
        impl DirW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DirW::Input => 0,
                    DirW::Output => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DirW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Configure pin as an input pin." ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(DirW::Input)
            }
            # [ doc = "Configure pin as an output pin." ]
            # [ inline ( always ) ]
            pub fn output(self) -> &'a mut W {
                self.variant(DirW::Output)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `INPUT`" ]
        pub enum InputW {
            # [ doc = "Connect input pin." ]
            Connect,
            # [ doc = "Disconnect input pin." ]
            Disconnect,
        }
        impl InputW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    InputW::Connect => 0,
                    InputW::Disconnect => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _InputW<'a> {
            w: &'a mut W,
        }
        impl<'a> _InputW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: InputW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Connect input pin." ]
            # [ inline ( always ) ]
            pub fn connect(self) -> &'a mut W {
                self.variant(InputW::Connect)
            }
            # [ doc = "Disconnect input pin." ]
            # [ inline ( always ) ]
            pub fn disconnect(self) -> &'a mut W {
                self.variant(InputW::Disconnect)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PULL`" ]
        pub enum PullW {
            # [ doc = "No pull." ]
            Disabled,
            # [ doc = "Pulldown on pin." ]
            Pulldown,
            # [ doc = "Pullup on pin." ]
            Pullup,
        }
        impl PullW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PullW::Disabled => 0,
                    PullW::Pulldown => 1,
                    PullW::Pullup => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PullW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PullW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PullW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "No pull." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PullW::Disabled)
            }
            # [ doc = "Pulldown on pin." ]
            # [ inline ( always ) ]
            pub fn pulldown(self) -> &'a mut W {
                self.variant(PullW::Pulldown)
            }
            # [ doc = "Pullup on pin." ]
            # [ inline ( always ) ]
            pub fn pullup(self) -> &'a mut W {
                self.variant(PullW::Pullup)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DRIVE`" ]
        pub enum DriveW {
            # [ doc = "Standard '0', Standard '1'." ]
            S0s1,
            # [ doc = "High '0', Standard '1'." ]
            H0s1,
            # [ doc = "Standard '0', High '1'." ]
            S0h1,
            # [ doc = "High '0', High '1'." ]
            H0h1,
            # [ doc = "Disconnected '0', Standard '1'." ]
            D0s1,
            # [ doc = "Disconnected '0', High '1'." ]
            D0h1,
            # [ doc = "Standard '0', Disconnected '1'." ]
            S0d1,
            # [ doc = "High '0', Disconnected '1'." ]
            H0d1,
        }
        impl DriveW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DriveW::S0s1 => 0,
                    DriveW::H0s1 => 1,
                    DriveW::S0h1 => 2,
                    DriveW::H0h1 => 3,
                    DriveW::D0s1 => 4,
                    DriveW::D0h1 => 5,
                    DriveW::S0d1 => 6,
                    DriveW::H0d1 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DriveW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DriveW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DriveW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Standard '0', Standard '1'." ]
            # [ inline ( always ) ]
            pub fn s0s1(self) -> &'a mut W {
                self.variant(DriveW::S0s1)
            }
            # [ doc = "High '0', Standard '1'." ]
            # [ inline ( always ) ]
            pub fn h0s1(self) -> &'a mut W {
                self.variant(DriveW::H0s1)
            }
            # [ doc = "Standard '0', High '1'." ]
            # [ inline ( always ) ]
            pub fn s0h1(self) -> &'a mut W {
                self.variant(DriveW::S0h1)
            }
            # [ doc = "High '0', High '1'." ]
            # [ inline ( always ) ]
            pub fn h0h1(self) -> &'a mut W {
                self.variant(DriveW::H0h1)
            }
            # [ doc = "Disconnected '0', Standard '1'." ]
            # [ inline ( always ) ]
            pub fn d0s1(self) -> &'a mut W {
                self.variant(DriveW::D0s1)
            }
            # [ doc = "Disconnected '0', High '1'." ]
            # [ inline ( always ) ]
            pub fn d0h1(self) -> &'a mut W {
                self.variant(DriveW::D0h1)
            }
            # [ doc = "Standard '0', Disconnected '1'." ]
            # [ inline ( always ) ]
            pub fn s0d1(self) -> &'a mut W {
                self.variant(DriveW::S0d1)
            }
            # [ doc = "High '0', Disconnected '1'." ]
            # [ inline ( always ) ]
            pub fn h0d1(self) -> &'a mut W {
                self.variant(DriveW::H0d1)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `SENSE`" ]
        pub enum SenseW {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Wakeup on high level." ]
            High,
            # [ doc = "Wakeup on low level." ]
            Low,
        }
        impl SenseW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SenseW::Disabled => 0,
                    SenseW::High => 2,
                    SenseW::Low => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SenseW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SenseW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SenseW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SenseW::Disabled)
            }
            # [ doc = "Wakeup on high level." ]
            # [ inline ( always ) ]
            pub fn high(self) -> &'a mut W {
                self.variant(SenseW::High)
            }
            # [ doc = "Wakeup on low level." ]
            # [ inline ( always ) ]
            pub fn low(self) -> &'a mut W {
                self.variant(SenseW::Low)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Pin direction." ]
            # [ inline ( always ) ]
            pub fn dir(&self) -> DirR {
                DirR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bit 1 - Connect or disconnect input path." ]
            # [ inline ( always ) ]
            pub fn input(&self) -> InputR {
                InputR::_from(
                    {
                        const MASK: u8 = 1;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bits 2:3 - Pull-up or -down configuration." ]
            # [ inline ( always ) ]
            pub fn pull(&self) -> PullR {
                PullR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bits 8:10 - Drive configuration." ]
            # [ inline ( always ) ]
            pub fn drive(&self) -> DriveR {
                DriveR::_from(
                    {
                        const MASK: u8 = 7;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
            # [ doc = "Bits 16:17 - Pin sensing mechanism." ]
            # [ inline ( always ) ]
            pub fn sense(&self) -> SenseR {
                SenseR::_from(
                    {
                        const MASK: u8 = 3;
                        const OFFSET: u8 = 16;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    },
                )
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 2 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Pin direction." ]
            # [ inline ( always ) ]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            # [ doc = "Bit 1 - Connect or disconnect input path." ]
            # [ inline ( always ) ]
            pub fn input(&mut self) -> _InputW {
                _InputW { w: self }
            }
            # [ doc = "Bits 2:3 - Pull-up or -down configuration." ]
            # [ inline ( always ) ]
            pub fn pull(&mut self) -> _PullW {
                _PullW { w: self }
            }
            # [ doc = "Bits 8:10 - Drive configuration." ]
            # [ inline ( always ) ]
            pub fn drive(&mut self) -> _DriveW {
                _DriveW { w: self }
            }
            # [ doc = "Bits 16:17 - Pin sensing mechanism." ]
            # [ inline ( always ) ]
            pub fn sense(&mut self) -> _SenseW {
                _SenseW { w: self }
            }
        }
    }
}
# [ doc = "General purpose input and output." ]
pub struct Gpio {
    register_block: gpio::RegisterBlock,
}
impl Deref for Gpio {
    type Target = gpio::RegisterBlock;
    fn deref(&self) -> &gpio::RegisterBlock {
        &self.register_block
    }
}
